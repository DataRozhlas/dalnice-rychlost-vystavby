<!DOCTYPE html>
<!-- saved from url=(0052)http://rozhlas2017.superkoderi.cz/tpl/14-datari.html -->
<html lang="cs" class="js fonts-loaded no-touchevents"><!--<![endif]--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	
	<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><![endif]-->
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=0">

	<meta name="twitter:card" content="summary">
	<meta name="twitter:title" content="Dataři">
	<meta name="twitter:description" content="">
	<meta name="twitter:image" content="../img/illust/twitter.jpg">

	<meta property="og:title" content="Dataři">
	<meta property="og:description" content="">
	<meta property="og:image" content="../img/illust/facebook.jpg">
	<meta property="og:site_name" content="Project">
	<meta property="og:url" content="http://www.rozhlas.cz/zpravy/portal/">

	<title>Dataři | iRozhlas</title>

	<link rel="stylesheet" href="./wrapper_files/style.css" media="screen, handheld">

	<link rel="icon" href="http://rozhlas2017.superkoderi.cz/img/favicon.ico">
	<link rel="apple-touch-icon" href="http://rozhlas2017.superkoderi.cz/img/apple-touch-icon-iphone.png">
	<link rel="apple-touch-icon" sizes="72x72" href="http://rozhlas2017.superkoderi.cz/img/apple-touch-icon-ipad.png">
	<link rel="apple-touch-icon" sizes="114x114" href="http://rozhlas2017.superkoderi.cz/img/apple-touch-icon-large.png">

	<!--[if lt IE 9]>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
	<![endif]-->

	<script>
		(function () {
			var className = document.documentElement.className;
			isOperaMini = (navigator.userAgent.indexOf('Opera Mini') > -1);

			function getCookie(name) {
				var value = '; ' + document.cookie;
				var parts = value.split('; ' + name + '=');
				if (parts.length === 2) return parts.pop().split(';').shift();
			}

			var textSize = getCookie('textSize');

			if (textSize) {
				document.documentElement.setAttribute('data-fz', textSize);
			}

			className = className.replace('no-js', 'js');

			if(document.cookie.indexOf('fontsLoaded') > -1) {
				className += ' fonts-loaded';
			}

			if(document.cookie.indexOf('inverseVersion') > -1) {
				className += ' page-inverse';
			}

			if(document.cookie.indexOf('textVersion') > -1 || isOperaMini) {
				className += ' page-text-version';
			}

			if(isOperaMini) {
				className += ' operamini';
			}

			if(/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream) {
				className += ' ios';
			}

			if(document.querySelector && document.cookie.indexOf('forceDesktop') > -1) {
				var viewport = document.querySelector("meta[name=viewport]");
				viewport.setAttribute('content', 'width=1200');
				className += ' page-forced-desktop';
			}

			document.documentElement.className = className;
		}());
	</script>

	<script src="./wrapper_files/modernizr.min.js"></script>
<style type="text/css">
:root #content > #center > .dose > .dosesingle,
:root #content > #right > .dose > .dosesingle
{ display: none !important; }</style><style type="text/css">
:root #content > #right > .dose > .dosesingle,
:root #content > #center > .dose > .dosesingle
{ display: none !important; }</style></head>

	<body id="top" class="">
<nav class="m-accessibility" aria-labelledby="m-accessibility">
	<p id="m-accessibility" class="vhide">Přístupnostní navigace</p>
	<a title="Přejít k obsahu (Klávesová zkratka: Alt + 2)" accesskey="2" href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#main">Přejít k obsahu</a>
	<span class="hide">|</span>
	<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#menu-main">Přejít k hlavnímu menu</a>
	<span class="hide">|</span>
	<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#form-search">Přejít k vyhledávání</a>
</nav>

		<header class="header header--simple" role="banner">
			<div class="row-main">
				<div class="header__top hide--m">
<div class="header__search">
	<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="header__login">Přihlásit</a>

	<form id="form-search" action="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html?" class="f-search f-search--header" role="search">
		<p class="inp">
			<label for="search-header" class="inp__label js-search">
				<span class="icon-svg icon-svg--search">
	<svg class="icon-svg__svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		<use xlink:href="./wrapper_files/icons-svg.svg#icon-search" x="0" y="0" width="100%" height="100%"></use>
</svg><span class="icon-svg__fallback">Vyhledávání</span>	
</span>

			</label>
			<span class="inp__fix">
				<input type="text" placeholder="Zadejte hledaný výraz" class="inp__text inp__text--icon-after" id="search-header" name="search-header">

				<button class="btn btn--icon-blank" type="submit">
					<span class="btn__text">
						<span class="icon-svg icon-svg--search">
	<svg class="icon-svg__svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		<use xlink:href="./wrapper_files/icons-svg.svg#icon-search" x="0" y="0" width="100%" height="100%"></use>
</svg><span class="icon-svg__fallback">Vyhledat</span>	
</span>

					</span>
				</button>
			</span>
		</p>
	</form>
</div>
				</div>

				<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="header__images js-text-version--icon">
					<span class="icon-svg icon-svg--images">
	<svg class="icon-svg__svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		<use xlink:href="./wrapper_files/icons-svg.svg#icon-images" x="0" y="0" width="100%" height="100%"></use>
	</svg>
</span>

					<span class="vhide">Zobrazit obrázky</span>
				</a>

	<p class="header__logo">
		<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#">
			<span class="vhide">iRozhlas</span>
			<span class="icon-svg icon-svg--logo-irozhlas">
	<svg class="icon-svg__svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		<use xlink:href="./wrapper_files/icons-svg.svg#icon-logo-irozhlas" x="0" y="0" width="100%" height="100%"></use>
</svg><span class="icon-svg__fallback">iRozhlas</span>	
</span>

		</a>
	</p>

				<nav id="menu-main" class="m-main m-main--simple" role="navigation" aria-labelledby="m-main">
					<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-main__toggle js-mobile-menu" id="m-main">
						<span class="vhide">Hlavní menu</span>
						<span class="icon-svg icon-svg--menu">
	<svg class="icon-svg__svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		<use xlink:href="./wrapper_files/icons-svg.svg#icon-menu" x="0" y="0" width="100%" height="100%"></use>
	</svg>
</span>

					</a>

					<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-main__link m-main__link--home js-static-menu" data-src="./m-static.html">
						<span class="vhide">Český rozhlas - Zprávy</span>
						<span class="icon-svg icon-svg--symbol">
	<svg class="icon-svg__svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		<use xlink:href="./wrapper_files/icons-svg.svg#icon-symbol" x="0" y="0" width="100%" height="100%"></use>
	</svg>
</span>

					</a>
				</nav>
			</div>

			<p class="header__socials">
				<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#">
					<span class="icon-svg icon-svg--facebook">
	<svg class="icon-svg__svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		<use xlink:href="./wrapper_files/icons-svg.svg#icon-facebook" x="0" y="0" width="100%" height="100%"></use>
	</svg>
</span>

					<span class="vhide">Facebook</span>
				</a>
				<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#">
					<span class="icon-svg icon-svg--twitter">
	<svg class="icon-svg__svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		<use xlink:href="./wrapper_files/icons-svg.svg#icon-twitter" x="0" y="0" width="100%" height="100%"></use>
	</svg>
</span>

					<span class="vhide">Twitter</span>
				</a>
			</p>
		</header>

		<main id="main" class="main" role="main">	
		<article role="article" class="b-data"> 			
			<div class="b-data__bg" style="background-image: url('./graphics/dalnice4.jpg');"><span class="b-data__caption">Foto <a href='#'>ČTK</a></span></div>
<header class="b-data__header">
<div class="row-main">
	<h1 class="b-data__title">
		<strong>Dálnice by stavěl rychleji jen superman, tvrdí ministr Ťok. Poláci to dokázali. Jak?</strong>
	</h1>
	<p class="meta meta--lg">
	<!--[[ZPRAVY_SNOWFALL_AUTHORS:HEADER]]-->
	<span class="meta__separator">|</span>
	<time>14. ledna 2019</time>
	</p>	
	<p>
	<a href="#content" class="b-data__link js-scroll-to">
	Čtěte dále
	<span class="b-data__link-icon">
	<span class="icon-svg icon-svg--arrow-down">
	<svg class="icon-svg__svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		<use xlink:href="/sites/all/themes/custom/irozhlas/img/bg/icons-svg.svg#icon-arrow-down" x="0" y="0" width="100%" height="100%"></use>
	</svg>
</span>
</span>
</a>
</p>
</div>
</header> 

<div class="b-data__content" id="content">
<script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
<script src="https://cdn.datatables.net/1.10.19/js/jquery.dataTables.min.js"></script>
<script src="https://cdn.datatables.net/responsive/2.2.3/js/dataTables.responsive.min.js"></script>

<link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.10.19/css/jquery.dataTables.min.css">
<link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/responsive/2.2.3/css/responsive.dataTables.min.css">
<style>li{background:0 0!important;margin:0!important;padding:0!important}ol,ul{list-style:initial!important;font-size:medium!important;line-height:1.5!important}hr{max-width:none!important}#container{min-width:310px;max-width:800px;height:400px;margin:0 auto}</style>
<div class="row-main row-main--narrow">

<p class="text-bold text-lg">ffff</p>

<div id="container"></div>


<div class="b-inline b-inline--left"><div class="b-inline__wrap"><div class="b-inline__content"><div class="text-sm">
    <strong>Poláci přidali plyn</strong>
    <p>
        Jak v posledních letech akcelerovala výstavba sítě dálnic v Polsku ukazuje animovaná mapa. 
    </p>
</div></div></div></div>



<p class="meta meta--right meta--big">
<!--[[ZPRAVY_SNOWFALL_AUTHORS:FOOTER]]-->
</p>
</div>
<!--[[ZPRAVY_SNOWFALL_RELATED:ARTICLES]]-->
</div>
<script>/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/script.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/graf1.js":
/*!*********************!*\
  !*** ./js/graf1.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("Highcharts.chart('container', {\n  title: {\n    text: 'Solar Employment Growth by Sector, 2010-2016'\n  },\n  subtitle: {\n    text: 'Source: thesolarfoundation.com'\n  },\n  yAxis: {\n    title: {\n      text: 'Number of Employees'\n    }\n  },\n  legend: {\n    layout: 'vertical',\n    align: 'right',\n    verticalAlign: 'middle'\n  },\n  plotOptions: {\n    series: {\n      label: {\n        connectorAllowed: false\n      },\n      pointStart: 2010\n    }\n  },\n  series: [{\n    name: 'Installation',\n    data: [43934, null, 57177, 69658, 97031, 119931, 137133, 154175]\n  }, {\n    name: 'Manufacturing',\n    data: [24916, 24064, 29742, 29851, 32490, 30282, 38121, 40434]\n  }, {\n    name: 'Sales & Distribution',\n    data: [11744, 17722, 16005, 19771, 20185, 24377, 32147, 39387]\n  }, {\n    name: 'Project Development',\n    data: [null, null, 7988, 12169, 15112, 22452, 34400, 34227]\n  }, {\n    name: 'Other',\n    data: [12908, 5948, 8105, 11248, 8989, 11816, 18274, 18111]\n  }],\n  responsive: {\n    rules: [{\n      condition: {\n        maxWidth: 500\n      },\n      chartOptions: {\n        legend: {\n          layout: 'horizontal',\n          align: 'center',\n          verticalAlign: 'bottom'\n        }\n      }\n    }]\n  }\n});\n\n//# sourceURL=webpack:///./js/graf1.js?");

/***/ }),

/***/ "./js/highcharts.js":
/*!**************************!*\
  !*** ./js/highcharts.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*\n Highcharts JS v7.0.1 (2018-12-19)\n\n (c) 2009-2018 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (O, J) {\n  \"object\" === ( false ? undefined : _typeof(module)) && module.exports ? module.exports = O.document ? J(O) : J :  true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n    return J(O);\n  }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;\n})(\"undefined\" !== typeof window ? window : this, function (O) {\n  var J = function () {\n    var a = \"undefined\" === typeof O ? window : O,\n        y = a.document,\n        G = a.navigator && a.navigator.userAgent || \"\",\n        E = y && y.createElementNS && !!y.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGRect,\n        h = /(edge|msie|trident)/i.test(G) && !a.opera,\n        c = -1 !== G.indexOf(\"Firefox\"),\n        r = -1 !== G.indexOf(\"Chrome\"),\n        u = c && 4 > parseInt(G.split(\"Firefox/\")[1], 10);\n    return a.Highcharts ? a.Highcharts.error(16, !0) : {\n      product: \"Highcharts\",\n      version: \"7.0.1\",\n      deg2rad: 2 * Math.PI / 360,\n      doc: y,\n      hasBidiBug: u,\n      hasTouch: y && void 0 !== y.documentElement.ontouchstart,\n      isMS: h,\n      isWebKit: -1 !== G.indexOf(\"AppleWebKit\"),\n      isFirefox: c,\n      isChrome: r,\n      isSafari: !r && -1 !== G.indexOf(\"Safari\"),\n      isTouchDevice: /(Mobile|Android|Windows Phone)/.test(G),\n      SVG_NS: \"http://www.w3.org/2000/svg\",\n      chartCount: 0,\n      seriesTypes: {},\n      symbolSizes: {},\n      svg: E,\n      win: a,\n      marginNames: [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"],\n      noop: function noop() {},\n      charts: []\n    };\n  }();\n\n  (function (a) {\n    a.timers = [];\n    var y = a.charts,\n        G = a.doc,\n        E = a.win;\n\n    a.error = function (h, c, r) {\n      var u = a.isNumber(h) ? \"Highcharts error #\" + h + \": www.highcharts.com/errors/\" + h : h;\n      r && a.fireEvent(r, \"displayError\", {\n        code: h\n      });\n      if (c) throw Error(u);\n      E.console && console.log(u);\n    };\n\n    a.Fx = function (a, c, r) {\n      this.options = c;\n      this.elem = a;\n      this.prop = r;\n    };\n\n    a.Fx.prototype = {\n      dSetter: function dSetter() {\n        var a = this.paths[0],\n            c = this.paths[1],\n            r = [],\n            u = this.now,\n            v = a.length,\n            w;\n        if (1 === u) r = this.toD;else if (v === c.length && 1 > u) for (; v--;) {\n          w = parseFloat(a[v]), r[v] = isNaN(w) ? c[v] : u * parseFloat(c[v] - w) + w;\n        } else r = c;\n        this.elem.attr(\"d\", r, null, !0);\n      },\n      update: function update() {\n        var a = this.elem,\n            c = this.prop,\n            r = this.now,\n            u = this.options.step;\n        if (this[c + \"Setter\"]) this[c + \"Setter\"]();else a.attr ? a.element && a.attr(c, r, null, !0) : a.style[c] = r + this.unit;\n        u && u.call(a, r, this);\n      },\n      run: function run(h, c, r) {\n        var u = this,\n            v = u.options,\n            w = function w(a) {\n          return w.stopped ? !1 : u.step(a);\n        },\n            n = E.requestAnimationFrame || function (a) {\n          setTimeout(a, 13);\n        },\n            g = function g() {\n          for (var d = 0; d < a.timers.length; d++) {\n            a.timers[d]() || a.timers.splice(d--, 1);\n          }\n\n          a.timers.length && n(g);\n        };\n\n        h !== c || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = h, this.end = c, this.unit = r, this.now = this.start, this.pos = 0, w.elem = this.elem, w.prop = this.prop, w() && 1 === a.timers.push(w) && n(g)) : (delete v.curAnim[this.prop], v.complete && 0 === Object.keys(v.curAnim).length && v.complete.call(this.elem));\n      },\n      step: function step(h) {\n        var c = +new Date(),\n            r,\n            u = this.options,\n            v = this.elem,\n            w = u.complete,\n            n = u.duration,\n            g = u.curAnim;\n        v.attr && !v.element ? h = !1 : h || c >= n + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), r = g[this.prop] = !0, a.objectEach(g, function (a) {\n          !0 !== a && (r = !1);\n        }), r && w && w.call(v), h = !1) : (this.pos = u.easing((c - this.startTime) / n), this.now = this.start + (this.end - this.start) * this.pos, this.update(), h = !0);\n        return h;\n      },\n      initPath: function initPath(h, c, r) {\n        function u(a) {\n          var b, k;\n\n          for (f = a.length; f--;) {\n            b = \"M\" === a[f] || \"L\" === a[f], k = /[a-zA-Z]/.test(a[f + 3]), b && k && a.splice(f + 1, 0, a[f + 1], a[f + 2], a[f + 1], a[f + 2]);\n          }\n        }\n\n        function v(a, l) {\n          for (; a.length < b;) {\n            a[0] = l[b - a.length];\n            var k = a.slice(0, p);\n            [].splice.apply(a, [0, 0].concat(k));\n            x && (k = a.slice(a.length - p), [].splice.apply(a, [a.length, 0].concat(k)), f--);\n          }\n\n          a[0] = \"M\";\n        }\n\n        function w(a, f) {\n          for (var k = (b - a.length) / p; 0 < k && k--;) {\n            l = a.slice().splice(a.length / t - p, p * t), l[0] = f[b - p - k * p], m && (l[p - 6] = l[p - 2], l[p - 5] = l[p - 1]), [].splice.apply(a, [a.length / t, 0].concat(l)), x && k--;\n          }\n        }\n\n        c = c || \"\";\n        var n,\n            g = h.startX,\n            d = h.endX,\n            m = -1 < c.indexOf(\"C\"),\n            p = m ? 7 : 3,\n            b,\n            l,\n            f;\n        c = c.split(\" \");\n        r = r.slice();\n        var x = h.isArea,\n            t = x ? 2 : 1,\n            H;\n        m && (u(c), u(r));\n\n        if (g && d) {\n          for (f = 0; f < g.length; f++) {\n            if (g[f] === d[0]) {\n              n = f;\n              break;\n            } else if (g[0] === d[d.length - g.length + f]) {\n              n = f;\n              H = !0;\n              break;\n            }\n          }\n\n          void 0 === n && (c = []);\n        }\n\n        c.length && a.isNumber(n) && (b = r.length + n * t * p, H ? (v(c, r), w(r, c)) : (v(r, c), w(c, r)));\n        return [c, r];\n      },\n      fillSetter: function fillSetter() {\n        a.Fx.prototype.strokeSetter.apply(this, arguments);\n      },\n      strokeSetter: function strokeSetter() {\n        this.elem.attr(this.prop, a.color(this.start).tweenTo(a.color(this.end), this.pos), null, !0);\n      }\n    };\n\n    a.merge = function () {\n      var h,\n          c = arguments,\n          r,\n          u = {},\n          v = function v(c, n) {\n        \"object\" !== _typeof(c) && (c = {});\n        a.objectEach(n, function (g, d) {\n          !a.isObject(g, !0) || a.isClass(g) || a.isDOMElement(g) ? c[d] = n[d] : c[d] = v(c[d] || {}, g);\n        });\n        return c;\n      };\n\n      !0 === c[0] && (u = c[1], c = Array.prototype.slice.call(c, 2));\n      r = c.length;\n\n      for (h = 0; h < r; h++) {\n        u = v(u, c[h]);\n      }\n\n      return u;\n    };\n\n    a.pInt = function (a, c) {\n      return parseInt(a, c || 10);\n    };\n\n    a.isString = function (a) {\n      return \"string\" === typeof a;\n    };\n\n    a.isArray = function (a) {\n      a = Object.prototype.toString.call(a);\n      return \"[object Array]\" === a || \"[object Array Iterator]\" === a;\n    };\n\n    a.isObject = function (h, c) {\n      return !!h && \"object\" === _typeof(h) && (!c || !a.isArray(h));\n    };\n\n    a.isDOMElement = function (h) {\n      return a.isObject(h) && \"number\" === typeof h.nodeType;\n    };\n\n    a.isClass = function (h) {\n      var c = h && h.constructor;\n      return !(!a.isObject(h, !0) || a.isDOMElement(h) || !c || !c.name || \"Object\" === c.name);\n    };\n\n    a.isNumber = function (a) {\n      return \"number\" === typeof a && !isNaN(a) && Infinity > a && -Infinity < a;\n    };\n\n    a.erase = function (a, c) {\n      for (var h = a.length; h--;) {\n        if (a[h] === c) {\n          a.splice(h, 1);\n          break;\n        }\n      }\n    };\n\n    a.defined = function (a) {\n      return void 0 !== a && null !== a;\n    };\n\n    a.attr = function (h, c, r) {\n      var u;\n      a.isString(c) ? a.defined(r) ? h.setAttribute(c, r) : h && h.getAttribute && ((u = h.getAttribute(c)) || \"class\" !== c || (u = h.getAttribute(c + \"Name\"))) : a.defined(c) && a.isObject(c) && a.objectEach(c, function (a, c) {\n        h.setAttribute(c, a);\n      });\n      return u;\n    };\n\n    a.splat = function (h) {\n      return a.isArray(h) ? h : [h];\n    };\n\n    a.syncTimeout = function (a, c, r) {\n      if (c) return setTimeout(a, c, r);\n      a.call(0, r);\n    };\n\n    a.clearTimeout = function (h) {\n      a.defined(h) && clearTimeout(h);\n    };\n\n    a.extend = function (a, c) {\n      var h;\n      a || (a = {});\n\n      for (h in c) {\n        a[h] = c[h];\n      }\n\n      return a;\n    };\n\n    a.pick = function () {\n      var a = arguments,\n          c,\n          r,\n          u = a.length;\n\n      for (c = 0; c < u; c++) {\n        if (r = a[c], void 0 !== r && null !== r) return r;\n      }\n    };\n\n    a.css = function (h, c) {\n      a.isMS && !a.svg && c && void 0 !== c.opacity && (c.filter = \"alpha(opacity\\x3d\" + 100 * c.opacity + \")\");\n      a.extend(h.style, c);\n    };\n\n    a.createElement = function (h, c, r, u, v) {\n      h = G.createElement(h);\n      var w = a.css;\n      c && a.extend(h, c);\n      v && w(h, {\n        padding: 0,\n        border: \"none\",\n        margin: 0\n      });\n      r && w(h, r);\n      u && u.appendChild(h);\n      return h;\n    };\n\n    a.extendClass = function (h, c) {\n      var r = function r() {};\n\n      r.prototype = new h();\n      a.extend(r.prototype, c);\n      return r;\n    };\n\n    a.pad = function (a, c, r) {\n      return Array((c || 2) + 1 - String(a).replace(\"-\", \"\").length).join(r || 0) + a;\n    };\n\n    a.relativeLength = function (a, c, r) {\n      return /%$/.test(a) ? c * parseFloat(a) / 100 + (r || 0) : parseFloat(a);\n    };\n\n    a.wrap = function (a, c, r) {\n      var h = a[c];\n\n      a[c] = function () {\n        var a = Array.prototype.slice.call(arguments),\n            c = arguments,\n            n = this;\n\n        n.proceed = function () {\n          h.apply(n, arguments.length ? arguments : c);\n        };\n\n        a.unshift(h);\n        a = r.apply(this, a);\n        n.proceed = null;\n        return a;\n      };\n    };\n\n    a.datePropsToTimestamps = function (h) {\n      a.objectEach(h, function (c, r) {\n        a.isObject(c) && \"function\" === typeof c.getTime ? h[r] = c.getTime() : (a.isObject(c) || a.isArray(c)) && a.datePropsToTimestamps(c);\n      });\n    };\n\n    a.formatSingle = function (h, c, r) {\n      var u = /\\.([0-9])/,\n          v = a.defaultOptions.lang;\n      /f$/.test(h) ? (r = (r = h.match(u)) ? r[1] : -1, null !== c && (c = a.numberFormat(c, r, v.decimalPoint, -1 < h.indexOf(\",\") ? v.thousandsSep : \"\"))) : c = (r || a.time).dateFormat(h, c);\n      return c;\n    };\n\n    a.format = function (h, c, r) {\n      for (var u = \"{\", v = !1, w, n, g, d, m = [], p; h;) {\n        u = h.indexOf(u);\n        if (-1 === u) break;\n        w = h.slice(0, u);\n\n        if (v) {\n          w = w.split(\":\");\n          n = w.shift().split(\".\");\n          d = n.length;\n          p = c;\n\n          for (g = 0; g < d; g++) {\n            p && (p = p[n[g]]);\n          }\n\n          w.length && (p = a.formatSingle(w.join(\":\"), p, r));\n          m.push(p);\n        } else m.push(w);\n\n        h = h.slice(u + 1);\n        u = (v = !v) ? \"}\" : \"{\";\n      }\n\n      m.push(h);\n      return m.join(\"\");\n    };\n\n    a.getMagnitude = function (a) {\n      return Math.pow(10, Math.floor(Math.log(a) / Math.LN10));\n    };\n\n    a.normalizeTickInterval = function (h, c, r, u, v) {\n      var w,\n          n = h;\n      r = a.pick(r, 1);\n      w = h / r;\n      c || (c = v ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === u && (1 === r ? c = c.filter(function (a) {\n        return 0 === a % 1;\n      }) : .1 >= r && (c = [1 / r])));\n\n      for (u = 0; u < c.length && !(n = c[u], v && n * r >= h || !v && w <= (c[u] + (c[u + 1] || c[u])) / 2); u++) {\n        ;\n      }\n\n      return n = a.correctFloat(n * r, -Math.round(Math.log(.001) / Math.LN10));\n    };\n\n    a.stableSort = function (a, c) {\n      var h = a.length,\n          u,\n          v;\n\n      for (v = 0; v < h; v++) {\n        a[v].safeI = v;\n      }\n\n      a.sort(function (a, n) {\n        u = c(a, n);\n        return 0 === u ? a.safeI - n.safeI : u;\n      });\n\n      for (v = 0; v < h; v++) {\n        delete a[v].safeI;\n      }\n    };\n\n    a.arrayMin = function (a) {\n      for (var c = a.length, h = a[0]; c--;) {\n        a[c] < h && (h = a[c]);\n      }\n\n      return h;\n    };\n\n    a.arrayMax = function (a) {\n      for (var c = a.length, h = a[0]; c--;) {\n        a[c] > h && (h = a[c]);\n      }\n\n      return h;\n    };\n\n    a.destroyObjectProperties = function (h, c) {\n      a.objectEach(h, function (a, u) {\n        a && a !== c && a.destroy && a.destroy();\n        delete h[u];\n      });\n    };\n\n    a.discardElement = function (h) {\n      var c = a.garbageBin;\n      c || (c = a.createElement(\"div\"));\n      h && c.appendChild(h);\n      c.innerHTML = \"\";\n    };\n\n    a.correctFloat = function (a, c) {\n      return parseFloat(a.toPrecision(c || 14));\n    };\n\n    a.setAnimation = function (h, c) {\n      c.renderer.globalAnimation = a.pick(h, c.options.chart.animation, !0);\n    };\n\n    a.animObject = function (h) {\n      return a.isObject(h) ? a.merge(h) : {\n        duration: h ? 500 : 0\n      };\n    };\n\n    a.timeUnits = {\n      millisecond: 1,\n      second: 1E3,\n      minute: 6E4,\n      hour: 36E5,\n      day: 864E5,\n      week: 6048E5,\n      month: 24192E5,\n      year: 314496E5\n    };\n\n    a.numberFormat = function (h, c, r, u) {\n      h = +h || 0;\n      c = +c;\n      var v = a.defaultOptions.lang,\n          w = (h.toString().split(\".\")[1] || \"\").split(\"e\")[0].length,\n          n,\n          g,\n          d = h.toString().split(\"e\");\n      -1 === c ? c = Math.min(w, 20) : a.isNumber(c) ? c && d[1] && 0 > d[1] && (n = c + +d[1], 0 <= n ? (d[0] = (+d[0]).toExponential(n).split(\"e\")[0], c = n) : (d[0] = d[0].split(\".\")[0] || 0, h = 20 > c ? (d[0] * Math.pow(10, d[1])).toFixed(c) : 0, d[1] = 0)) : c = 2;\n      g = (Math.abs(d[1] ? d[0] : h) + Math.pow(10, -Math.max(c, w) - 1)).toFixed(c);\n      w = String(a.pInt(g));\n      n = 3 < w.length ? w.length % 3 : 0;\n      r = a.pick(r, v.decimalPoint);\n      u = a.pick(u, v.thousandsSep);\n      h = (0 > h ? \"-\" : \"\") + (n ? w.substr(0, n) + u : \"\");\n      h += w.substr(n).replace(/(\\d{3})(?=\\d)/g, \"$1\" + u);\n      c && (h += r + g.slice(-c));\n      d[1] && 0 !== +h && (h += \"e\" + d[1]);\n      return h;\n    };\n\n    Math.easeInOutSine = function (a) {\n      return -.5 * (Math.cos(Math.PI * a) - 1);\n    };\n\n    a.getStyle = function (h, c, r) {\n      if (\"width\" === c) return Math.max(0, Math.min(h.offsetWidth, h.scrollWidth, h.getBoundingClientRect ? Math.floor(h.getBoundingClientRect().width) : Infinity) - a.getStyle(h, \"padding-left\") - a.getStyle(h, \"padding-right\"));\n      if (\"height\" === c) return Math.max(0, Math.min(h.offsetHeight, h.scrollHeight) - a.getStyle(h, \"padding-top\") - a.getStyle(h, \"padding-bottom\"));\n      E.getComputedStyle || a.error(27, !0);\n      if (h = E.getComputedStyle(h, void 0)) h = h.getPropertyValue(c), a.pick(r, \"opacity\" !== c) && (h = a.pInt(h));\n      return h;\n    };\n\n    a.inArray = function (a, c, r) {\n      return c.indexOf(a, r);\n    };\n\n    a.find = Array.prototype.find ? function (a, c) {\n      return a.find(c);\n    } : function (a, c) {\n      var h,\n          u = a.length;\n\n      for (h = 0; h < u; h++) {\n        if (c(a[h], h)) return a[h];\n      }\n    };\n    a.keys = Object.keys;\n\n    a.offset = function (a) {\n      var c = G.documentElement;\n      a = a.parentElement || a.parentNode ? a.getBoundingClientRect() : {\n        top: 0,\n        left: 0\n      };\n      return {\n        top: a.top + (E.pageYOffset || c.scrollTop) - (c.clientTop || 0),\n        left: a.left + (E.pageXOffset || c.scrollLeft) - (c.clientLeft || 0)\n      };\n    };\n\n    a.stop = function (h, c) {\n      for (var r = a.timers.length; r--;) {\n        a.timers[r].elem !== h || c && c !== a.timers[r].prop || (a.timers[r].stopped = !0);\n      }\n    };\n\n    a.objectEach = function (a, c, r) {\n      for (var h in a) {\n        a.hasOwnProperty(h) && c.call(r || a[h], a[h], h, a);\n      }\n    };\n\n    a.objectEach({\n      map: \"map\",\n      each: \"forEach\",\n      grep: \"filter\",\n      reduce: \"reduce\",\n      some: \"some\"\n    }, function (h, c) {\n      a[c] = function (a) {\n        return Array.prototype[h].apply(a, [].slice.call(arguments, 1));\n      };\n    });\n\n    a.addEvent = function (h, c, r, u) {\n      var v,\n          w = h.addEventListener || a.addEventListenerPolyfill;\n      v = \"function\" === typeof h && h.prototype ? h.prototype.protoEvents = h.prototype.protoEvents || {} : h.hcEvents = h.hcEvents || {};\n      a.Point && h instanceof a.Point && h.series && h.series.chart && (h.series.chart.runTrackerClick = !0);\n      w && w.call(h, c, r, !1);\n      v[c] || (v[c] = []);\n      v[c].push(r);\n      u && a.isNumber(u.order) && (r.order = u.order, v[c].sort(function (a, g) {\n        return a.order - g.order;\n      }));\n      return function () {\n        a.removeEvent(h, c, r);\n      };\n    };\n\n    a.removeEvent = function (h, c, r) {\n      function u(g, d) {\n        var m = h.removeEventListener || a.removeEventListenerPolyfill;\n        m && m.call(h, g, d, !1);\n      }\n\n      function v(g) {\n        var d, m;\n        h.nodeName && (c ? (d = {}, d[c] = !0) : d = g, a.objectEach(d, function (a, b) {\n          if (g[b]) for (m = g[b].length; m--;) {\n            u(b, g[b][m]);\n          }\n        }));\n      }\n\n      var w, n;\n      [\"protoEvents\", \"hcEvents\"].forEach(function (a) {\n        var d = h[a];\n        d && (c ? (w = d[c] || [], r ? (n = w.indexOf(r), -1 < n && (w.splice(n, 1), d[c] = w), u(c, r)) : (v(d), d[c] = [])) : (v(d), h[a] = {}));\n      });\n    };\n\n    a.fireEvent = function (h, c, r, u) {\n      var v, w, n, g, d;\n      r = r || {};\n      G.createEvent && (h.dispatchEvent || h.fireEvent) ? (v = G.createEvent(\"Events\"), v.initEvent(c, !0, !0), a.extend(v, r), h.dispatchEvent ? h.dispatchEvent(v) : h.fireEvent(c, v)) : [\"protoEvents\", \"hcEvents\"].forEach(function (m) {\n        if (h[m]) for (w = h[m][c] || [], n = w.length, r.target || a.extend(r, {\n          preventDefault: function preventDefault() {\n            r.defaultPrevented = !0;\n          },\n          target: h,\n          type: c\n        }), g = 0; g < n; g++) {\n          (d = w[g]) && !1 === d.call(h, r) && r.preventDefault();\n        }\n      });\n      u && !r.defaultPrevented && u.call(h, r);\n    };\n\n    a.animate = function (h, c, r) {\n      var u,\n          v = \"\",\n          w,\n          n,\n          g;\n      a.isObject(r) || (g = arguments, r = {\n        duration: g[2],\n        easing: g[3],\n        complete: g[4]\n      });\n      a.isNumber(r.duration) || (r.duration = 400);\n      r.easing = \"function\" === typeof r.easing ? r.easing : Math[r.easing] || Math.easeInOutSine;\n      r.curAnim = a.merge(c);\n      a.objectEach(c, function (d, g) {\n        a.stop(h, g);\n        n = new a.Fx(h, r, g);\n        w = null;\n        \"d\" === g ? (n.paths = n.initPath(h, h.d, c.d), n.toD = c.d, u = 0, w = 1) : h.attr ? u = h.attr(g) : (u = parseFloat(a.getStyle(h, g)) || 0, \"opacity\" !== g && (v = \"px\"));\n        w || (w = d);\n        w && w.match && w.match(\"px\") && (w = w.replace(/px/g, \"\"));\n        n.run(u, w, v);\n      });\n    };\n\n    a.seriesType = function (h, c, r, u, v) {\n      var w = a.getOptions(),\n          n = a.seriesTypes;\n      w.plotOptions[h] = a.merge(w.plotOptions[c], r);\n      n[h] = a.extendClass(n[c] || function () {}, u);\n      n[h].prototype.type = h;\n      v && (n[h].prototype.pointClass = a.extendClass(a.Point, v));\n      return n[h];\n    };\n\n    a.uniqueKey = function () {\n      var a = Math.random().toString(36).substring(2, 9),\n          c = 0;\n      return function () {\n        return \"highcharts-\" + a + \"-\" + c++;\n      };\n    }();\n\n    a.isFunction = function (a) {\n      return \"function\" === typeof a;\n    };\n\n    E.jQuery && (E.jQuery.fn.highcharts = function () {\n      var h = [].slice.call(arguments);\n      if (this[0]) return h[0] ? (new a[a.isString(h[0]) ? h.shift() : \"Chart\"](this[0], h[0], h[1]), this) : y[a.attr(this[0], \"data-highcharts-chart\")];\n    });\n  })(J);\n\n  (function (a) {\n    var y = a.isNumber,\n        G = a.merge,\n        E = a.pInt;\n\n    a.Color = function (h) {\n      if (!(this instanceof a.Color)) return new a.Color(h);\n      this.init(h);\n    };\n\n    a.Color.prototype = {\n      parsers: [{\n        regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n        parse: function parse(a) {\n          return [E(a[1]), E(a[2]), E(a[3]), parseFloat(a[4], 10)];\n        }\n      }, {\n        regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n        parse: function parse(a) {\n          return [E(a[1]), E(a[2]), E(a[3]), 1];\n        }\n      }],\n      names: {\n        white: \"#ffffff\",\n        black: \"#000000\"\n      },\n      init: function init(h) {\n        var c, r, u, v;\n        if ((this.input = h = this.names[h && h.toLowerCase ? h.toLowerCase() : \"\"] || h) && h.stops) this.stops = h.stops.map(function (c) {\n          return new a.Color(c[1]);\n        });else if (h && h.charAt && \"#\" === h.charAt() && (c = h.length, h = parseInt(h.substr(1), 16), 7 === c ? r = [(h & 16711680) >> 16, (h & 65280) >> 8, h & 255, 1] : 4 === c && (r = [(h & 3840) >> 4 | (h & 3840) >> 8, (h & 240) >> 4 | h & 240, (h & 15) << 4 | h & 15, 1])), !r) for (u = this.parsers.length; u-- && !r;) {\n          v = this.parsers[u], (c = v.regex.exec(h)) && (r = v.parse(c));\n        }\n        this.rgba = r || [];\n      },\n      get: function get(a) {\n        var c = this.input,\n            h = this.rgba,\n            u;\n        this.stops ? (u = G(c), u.stops = [].concat(u.stops), this.stops.forEach(function (c, h) {\n          u.stops[h] = [u.stops[h][0], c.get(a)];\n        })) : u = h && y(h[0]) ? \"rgb\" === a || !a && 1 === h[3] ? \"rgb(\" + h[0] + \",\" + h[1] + \",\" + h[2] + \")\" : \"a\" === a ? h[3] : \"rgba(\" + h.join(\",\") + \")\" : c;\n        return u;\n      },\n      brighten: function brighten(a) {\n        var c,\n            h = this.rgba;\n        if (this.stops) this.stops.forEach(function (c) {\n          c.brighten(a);\n        });else if (y(a) && 0 !== a) for (c = 0; 3 > c; c++) {\n          h[c] += E(255 * a), 0 > h[c] && (h[c] = 0), 255 < h[c] && (h[c] = 255);\n        }\n        return this;\n      },\n      setOpacity: function setOpacity(a) {\n        this.rgba[3] = a;\n        return this;\n      },\n      tweenTo: function tweenTo(a, c) {\n        var h = this.rgba,\n            u = a.rgba;\n        u.length && h && h.length ? (a = 1 !== u[3] || 1 !== h[3], c = (a ? \"rgba(\" : \"rgb(\") + Math.round(u[0] + (h[0] - u[0]) * (1 - c)) + \",\" + Math.round(u[1] + (h[1] - u[1]) * (1 - c)) + \",\" + Math.round(u[2] + (h[2] - u[2]) * (1 - c)) + (a ? \",\" + (u[3] + (h[3] - u[3]) * (1 - c)) : \"\") + \")\") : c = a.input || \"none\";\n        return c;\n      }\n    };\n\n    a.color = function (h) {\n      return new a.Color(h);\n    };\n  })(J);\n\n  (function (a) {\n    var y,\n        G,\n        E = a.addEvent,\n        h = a.animate,\n        c = a.attr,\n        r = a.charts,\n        u = a.color,\n        v = a.css,\n        w = a.createElement,\n        n = a.defined,\n        g = a.deg2rad,\n        d = a.destroyObjectProperties,\n        m = a.doc,\n        p = a.extend,\n        b = a.erase,\n        l = a.hasTouch,\n        f = a.isArray,\n        x = a.isFirefox,\n        t = a.isMS,\n        H = a.isObject,\n        F = a.isString,\n        z = a.isWebKit,\n        k = a.merge,\n        A = a.noop,\n        D = a.objectEach,\n        B = a.pick,\n        e = a.pInt,\n        q = a.removeEvent,\n        L = a.splat,\n        I = a.stop,\n        R = a.svg,\n        K = a.SVG_NS,\n        M = a.symbolSizes,\n        S = a.win;\n\n    y = a.SVGElement = function () {\n      return this;\n    };\n\n    p(y.prototype, {\n      opacity: 1,\n      SVG_NS: K,\n      textProps: \"direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline cursor\".split(\" \"),\n      init: function init(a, e) {\n        this.element = \"span\" === e ? w(e) : m.createElementNS(this.SVG_NS, e);\n        this.renderer = a;\n      },\n      animate: function animate(e, q, b) {\n        q = a.animObject(B(q, this.renderer.globalAnimation, !0));\n        0 !== q.duration ? (b && (q.complete = b), h(this, e, q)) : (this.attr(e, null, b), q.step && q.step.call(this));\n        return this;\n      },\n      complexColor: function complexColor(e, q, b) {\n        var C = this.renderer,\n            l,\n            d,\n            p,\n            g,\n            A,\n            K,\n            m,\n            N,\n            x,\n            c,\n            t,\n            I = [],\n            L;\n        a.fireEvent(this.renderer, \"complexColor\", {\n          args: arguments\n        }, function () {\n          e.radialGradient ? d = \"radialGradient\" : e.linearGradient && (d = \"linearGradient\");\n          d && (p = e[d], A = C.gradients, m = e.stops, c = b.radialReference, f(p) && (e[d] = p = {\n            x1: p[0],\n            y1: p[1],\n            x2: p[2],\n            y2: p[3],\n            gradientUnits: \"userSpaceOnUse\"\n          }), \"radialGradient\" === d && c && !n(p.gradientUnits) && (g = p, p = k(p, C.getRadialAttr(c, g), {\n            gradientUnits: \"userSpaceOnUse\"\n          })), D(p, function (a, e) {\n            \"id\" !== e && I.push(e, a);\n          }), D(m, function (a) {\n            I.push(a);\n          }), I = I.join(\",\"), A[I] ? t = A[I].attr(\"id\") : (p.id = t = a.uniqueKey(), A[I] = K = C.createElement(d).attr(p).add(C.defs), K.radAttr = g, K.stops = [], m.forEach(function (e) {\n            0 === e[1].indexOf(\"rgba\") ? (l = a.color(e[1]), N = l.get(\"rgb\"), x = l.get(\"a\")) : (N = e[1], x = 1);\n            e = C.createElement(\"stop\").attr({\n              offset: e[0],\n              \"stop-color\": N,\n              \"stop-opacity\": x\n            }).add(K);\n            K.stops.push(e);\n          })), L = \"url(\" + C.url + \"#\" + t + \")\", b.setAttribute(q, L), b.gradient = I, e.toString = function () {\n            return L;\n          });\n        });\n      },\n      applyTextOutline: function applyTextOutline(e) {\n        var C = this.element,\n            q,\n            f,\n            k,\n            l,\n            d;\n        -1 !== e.indexOf(\"contrast\") && (e = e.replace(/contrast/g, this.renderer.getContrast(C.style.fill)));\n        e = e.split(\" \");\n        f = e[e.length - 1];\n\n        if ((k = e[0]) && \"none\" !== k && a.svg) {\n          this.fakeTS = !0;\n          e = [].slice.call(C.getElementsByTagName(\"tspan\"));\n          this.ySetter = this.xSetter;\n          k = k.replace(/(^[\\d\\.]+)(.*?)$/g, function (a, e, C) {\n            return 2 * e + C;\n          });\n\n          for (d = e.length; d--;) {\n            q = e[d], \"highcharts-text-outline\" === q.getAttribute(\"class\") && b(e, C.removeChild(q));\n          }\n\n          l = C.firstChild;\n          e.forEach(function (a, e) {\n            0 === e && (a.setAttribute(\"x\", C.getAttribute(\"x\")), e = C.getAttribute(\"y\"), a.setAttribute(\"y\", e || 0), null === e && C.setAttribute(\"y\", 0));\n            a = a.cloneNode(1);\n            c(a, {\n              \"class\": \"highcharts-text-outline\",\n              fill: f,\n              stroke: f,\n              \"stroke-width\": k,\n              \"stroke-linejoin\": \"round\"\n            });\n            C.insertBefore(a, l);\n          });\n        }\n      },\n      symbolCustomAttribs: \"x y width height r start end innerR anchorX anchorY rounded\".split(\" \"),\n      attr: function attr(e, q, b, f) {\n        var C,\n            k = this.element,\n            l,\n            d = this,\n            p,\n            g,\n            A = this.symbolCustomAttribs;\n        \"string\" === typeof e && void 0 !== q && (C = e, e = {}, e[C] = q);\n        \"string\" === typeof e ? d = (this[e + \"Getter\"] || this._defaultGetter).call(this, e, k) : (D(e, function (C, q) {\n          p = !1;\n          f || I(this, q);\n          this.symbolName && -1 !== a.inArray(q, A) && (l || (this.symbolAttr(e), l = !0), p = !0);\n          !this.rotation || \"x\" !== q && \"y\" !== q || (this.doTransform = !0);\n          p || (g = this[q + \"Setter\"] || this._defaultSetter, g.call(this, C, q, k), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(q) && this.updateShadows(q, C, g));\n        }, this), this.afterSetters());\n        b && b.call(this);\n        return d;\n      },\n      afterSetters: function afterSetters() {\n        this.doTransform && (this.updateTransform(), this.doTransform = !1);\n      },\n      updateShadows: function updateShadows(a, e, q) {\n        for (var C = this.shadows, b = C.length; b--;) {\n          q.call(C[b], \"height\" === a ? Math.max(e - (C[b].cutHeight || 0), 0) : \"d\" === a ? this.d : e, a, C[b]);\n        }\n      },\n      addClass: function addClass(a, e) {\n        var C = this.attr(\"class\") || \"\";\n        -1 === C.indexOf(a) && (e || (a = (C + (C ? \" \" : \"\") + a).replace(\"  \", \" \")), this.attr(\"class\", a));\n        return this;\n      },\n      hasClass: function hasClass(a) {\n        return -1 !== (this.attr(\"class\") || \"\").split(\" \").indexOf(a);\n      },\n      removeClass: function removeClass(a) {\n        return this.attr(\"class\", (this.attr(\"class\") || \"\").replace(a, \"\"));\n      },\n      symbolAttr: function symbolAttr(a) {\n        var e = this;\n        \"x y r start end width height innerR anchorX anchorY\".split(\" \").forEach(function (C) {\n          e[C] = B(a[C], e[C]);\n        });\n        e.attr({\n          d: e.renderer.symbols[e.symbolName](e.x, e.y, e.width, e.height, e)\n        });\n      },\n      clip: function clip(a) {\n        return this.attr(\"clip-path\", a ? \"url(\" + this.renderer.url + \"#\" + a.id + \")\" : \"none\");\n      },\n      crisp: function crisp(a, e) {\n        var C;\n        e = e || a.strokeWidth || 0;\n        C = Math.round(e) % 2 / 2;\n        a.x = Math.floor(a.x || this.x || 0) + C;\n        a.y = Math.floor(a.y || this.y || 0) + C;\n        a.width = Math.floor((a.width || this.width || 0) - 2 * C);\n        a.height = Math.floor((a.height || this.height || 0) - 2 * C);\n        n(a.strokeWidth) && (a.strokeWidth = e);\n        return a;\n      },\n      css: function css(a) {\n        var C = this.styles,\n            q = {},\n            b = this.element,\n            k,\n            f = \"\",\n            l,\n            d = !C,\n            g = [\"textOutline\", \"textOverflow\", \"width\"];\n        a && a.color && (a.fill = a.color);\n        C && D(a, function (a, e) {\n          a !== C[e] && (q[e] = a, d = !0);\n        });\n        d && (C && (a = p(C, q)), a && (null === a.width || \"auto\" === a.width ? delete this.textWidth : \"text\" === b.nodeName.toLowerCase() && a.width && (k = this.textWidth = e(a.width))), this.styles = a, k && !R && this.renderer.forExport && delete a.width, b.namespaceURI === this.SVG_NS ? (l = function l(a, e) {\n          return \"-\" + e.toLowerCase();\n        }, D(a, function (a, e) {\n          -1 === g.indexOf(e) && (f += e.replace(/([A-Z])/g, l) + \":\" + a + \";\");\n        }), f && c(b, \"style\", f)) : v(b, a), this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), a && a.textOutline && this.applyTextOutline(a.textOutline)));\n        return this;\n      },\n      getStyle: function getStyle(a) {\n        return S.getComputedStyle(this.element || this, \"\").getPropertyValue(a);\n      },\n      strokeWidth: function strokeWidth() {\n        if (!this.renderer.styledMode) return this[\"stroke-width\"] || 0;\n        var a = this.getStyle(\"stroke-width\"),\n            q;\n        a.indexOf(\"px\") === a.length - 2 ? a = e(a) : (q = m.createElementNS(K, \"rect\"), c(q, {\n          width: a,\n          \"stroke-width\": 0\n        }), this.element.parentNode.appendChild(q), a = q.getBBox().width, q.parentNode.removeChild(q));\n        return a;\n      },\n      on: function on(a, e) {\n        var q = this,\n            C = q.element;\n        l && \"click\" === a ? (C.ontouchstart = function (a) {\n          q.touchEventFired = Date.now();\n          a.preventDefault();\n          e.call(C, a);\n        }, C.onclick = function (a) {\n          (-1 === S.navigator.userAgent.indexOf(\"Android\") || 1100 < Date.now() - (q.touchEventFired || 0)) && e.call(C, a);\n        }) : C[\"on\" + a] = e;\n        return this;\n      },\n      setRadialReference: function setRadialReference(a) {\n        var e = this.renderer.gradients[this.element.gradient];\n        this.element.radialReference = a;\n        e && e.radAttr && e.animate(this.renderer.getRadialAttr(a, e.radAttr));\n        return this;\n      },\n      translate: function translate(a, e) {\n        return this.attr({\n          translateX: a,\n          translateY: e\n        });\n      },\n      invert: function invert(a) {\n        this.inverted = a;\n        this.updateTransform();\n        return this;\n      },\n      updateTransform: function updateTransform() {\n        var a = this.translateX || 0,\n            e = this.translateY || 0,\n            q = this.scaleX,\n            b = this.scaleY,\n            f = this.inverted,\n            k = this.rotation,\n            l = this.matrix,\n            d = this.element;\n        f && (a += this.width, e += this.height);\n        a = [\"translate(\" + a + \",\" + e + \")\"];\n        n(l) && a.push(\"matrix(\" + l.join(\",\") + \")\");\n        f ? a.push(\"rotate(90) scale(-1,1)\") : k && a.push(\"rotate(\" + k + \" \" + B(this.rotationOriginX, d.getAttribute(\"x\"), 0) + \" \" + B(this.rotationOriginY, d.getAttribute(\"y\") || 0) + \")\");\n        (n(q) || n(b)) && a.push(\"scale(\" + B(q, 1) + \" \" + B(b, 1) + \")\");\n        a.length && d.setAttribute(\"transform\", a.join(\" \"));\n      },\n      toFront: function toFront() {\n        var a = this.element;\n        a.parentNode.appendChild(a);\n        return this;\n      },\n      align: function align(a, e, q) {\n        var C,\n            f,\n            k,\n            l,\n            d = {};\n        f = this.renderer;\n        k = f.alignedObjects;\n        var p, g;\n\n        if (a) {\n          if (this.alignOptions = a, this.alignByTranslate = e, !q || F(q)) this.alignTo = C = q || \"renderer\", b(k, this), k.push(this), q = null;\n        } else a = this.alignOptions, e = this.alignByTranslate, C = this.alignTo;\n\n        q = B(q, f[C], f);\n        C = a.align;\n        f = a.verticalAlign;\n        k = (q.x || 0) + (a.x || 0);\n        l = (q.y || 0) + (a.y || 0);\n        \"right\" === C ? p = 1 : \"center\" === C && (p = 2);\n        p && (k += (q.width - (a.width || 0)) / p);\n        d[e ? \"translateX\" : \"x\"] = Math.round(k);\n        \"bottom\" === f ? g = 1 : \"middle\" === f && (g = 2);\n        g && (l += (q.height - (a.height || 0)) / g);\n        d[e ? \"translateY\" : \"y\"] = Math.round(l);\n        this[this.placed ? \"animate\" : \"attr\"](d);\n        this.placed = !0;\n        this.alignAttr = d;\n        return this;\n      },\n      getBBox: function getBBox(a, e) {\n        var q,\n            C = this.renderer,\n            b,\n            f = this.element,\n            k = this.styles,\n            l,\n            d = this.textStr,\n            A,\n            K = C.cache,\n            m = C.cacheKeys,\n            x = f.namespaceURI === this.SVG_NS,\n            c;\n        e = B(e, this.rotation);\n        b = e * g;\n        l = C.styledMode ? f && y.prototype.getStyle.call(f, \"font-size\") : k && k.fontSize;\n        n(d) && (c = d.toString(), -1 === c.indexOf(\"\\x3c\") && (c = c.replace(/[0-9]/g, \"0\")), c += [\"\", e || 0, l, this.textWidth, k && k.textOverflow].join());\n        c && !a && (q = K[c]);\n\n        if (!q) {\n          if (x || C.forExport) {\n            try {\n              (A = this.fakeTS && function (a) {\n                [].forEach.call(f.querySelectorAll(\".highcharts-text-outline\"), function (e) {\n                  e.style.display = a;\n                });\n              }) && A(\"none\"), q = f.getBBox ? p({}, f.getBBox()) : {\n                width: f.offsetWidth,\n                height: f.offsetHeight\n              }, A && A(\"\");\n            } catch (W) {}\n\n            if (!q || 0 > q.width) q = {\n              width: 0,\n              height: 0\n            };\n          } else q = this.htmlGetBBox();\n\n          C.isSVG && (a = q.width, C = q.height, x && (q.height = C = {\n            \"11px,17\": 14,\n            \"13px,20\": 16\n          }[k && k.fontSize + \",\" + Math.round(C)] || C), e && (q.width = Math.abs(C * Math.sin(b)) + Math.abs(a * Math.cos(b)), q.height = Math.abs(C * Math.cos(b)) + Math.abs(a * Math.sin(b))));\n\n          if (c && 0 < q.height) {\n            for (; 250 < m.length;) {\n              delete K[m.shift()];\n            }\n\n            K[c] || m.push(c);\n            K[c] = q;\n          }\n        }\n\n        return q;\n      },\n      show: function show(a) {\n        return this.attr({\n          visibility: a ? \"inherit\" : \"visible\"\n        });\n      },\n      hide: function hide() {\n        return this.attr({\n          visibility: \"hidden\"\n        });\n      },\n      fadeOut: function fadeOut(a) {\n        var e = this;\n        e.animate({\n          opacity: 0\n        }, {\n          duration: a || 150,\n          complete: function complete() {\n            e.attr({\n              y: -9999\n            });\n          }\n        });\n      },\n      add: function add(a) {\n        var e = this.renderer,\n            q = this.element,\n            C;\n        a && (this.parentGroup = a);\n        this.parentInverted = a && a.inverted;\n        void 0 !== this.textStr && e.buildText(this);\n        this.added = !0;\n        if (!a || a.handleZ || this.zIndex) C = this.zIndexSetter();\n        C || (a ? a.element : e.box).appendChild(q);\n        if (this.onAdd) this.onAdd();\n        return this;\n      },\n      safeRemoveChild: function safeRemoveChild(a) {\n        var e = a.parentNode;\n        e && e.removeChild(a);\n      },\n      destroy: function destroy() {\n        var a = this,\n            e = a.element || {},\n            q = a.renderer,\n            f = q.isSVG && \"SPAN\" === e.nodeName && a.parentGroup,\n            k = e.ownerSVGElement,\n            l = a.clipPath;\n        e.onclick = e.onmouseout = e.onmouseover = e.onmousemove = e.point = null;\n        I(a);\n        l && k && ([].forEach.call(k.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (a) {\n          var e = a.getAttribute(\"clip-path\"),\n              q = l.element.id;\n          (-1 < e.indexOf(\"(#\" + q + \")\") || -1 < e.indexOf('(\"#' + q + '\")')) && a.removeAttribute(\"clip-path\");\n        }), a.clipPath = l.destroy());\n\n        if (a.stops) {\n          for (k = 0; k < a.stops.length; k++) {\n            a.stops[k] = a.stops[k].destroy();\n          }\n\n          a.stops = null;\n        }\n\n        a.safeRemoveChild(e);\n\n        for (q.styledMode || a.destroyShadows(); f && f.div && 0 === f.div.childNodes.length;) {\n          e = f.parentGroup, a.safeRemoveChild(f.div), delete f.div, f = e;\n        }\n\n        a.alignTo && b(q.alignedObjects, a);\n        D(a, function (e, q) {\n          delete a[q];\n        });\n        return null;\n      },\n      shadow: function shadow(a, e, q) {\n        var b = [],\n            f,\n            C,\n            k = this.element,\n            l,\n            d,\n            p,\n            g;\n        if (!a) this.destroyShadows();else if (!this.shadows) {\n          d = B(a.width, 3);\n          p = (a.opacity || .15) / d;\n          g = this.parentInverted ? \"(-1,-1)\" : \"(\" + B(a.offsetX, 1) + \", \" + B(a.offsetY, 1) + \")\";\n\n          for (f = 1; f <= d; f++) {\n            C = k.cloneNode(0), l = 2 * d + 1 - 2 * f, c(C, {\n              stroke: a.color || \"#000000\",\n              \"stroke-opacity\": p * f,\n              \"stroke-width\": l,\n              transform: \"translate\" + g,\n              fill: \"none\"\n            }), C.setAttribute(\"class\", (C.getAttribute(\"class\") || \"\") + \" highcharts-shadow\"), q && (c(C, \"height\", Math.max(c(C, \"height\") - l, 0)), C.cutHeight = l), e ? e.element.appendChild(C) : k.parentNode && k.parentNode.insertBefore(C, k), b.push(C);\n          }\n\n          this.shadows = b;\n        }\n        return this;\n      },\n      destroyShadows: function destroyShadows() {\n        (this.shadows || []).forEach(function (a) {\n          this.safeRemoveChild(a);\n        }, this);\n        this.shadows = void 0;\n      },\n      xGetter: function xGetter(a) {\n        \"circle\" === this.element.nodeName && (\"x\" === a ? a = \"cx\" : \"y\" === a && (a = \"cy\"));\n        return this._defaultGetter(a);\n      },\n      _defaultGetter: function _defaultGetter(a) {\n        a = B(this[a + \"Value\"], this[a], this.element ? this.element.getAttribute(a) : null, 0);\n        /^[\\-0-9\\.]+$/.test(a) && (a = parseFloat(a));\n        return a;\n      },\n      dSetter: function dSetter(a, e, q) {\n        a && a.join && (a = a.join(\" \"));\n        /(NaN| {2}|^$)/.test(a) && (a = \"M 0 0\");\n        this[e] !== a && (q.setAttribute(e, a), this[e] = a);\n      },\n      dashstyleSetter: function dashstyleSetter(a) {\n        var q,\n            f = this[\"stroke-width\"];\n        \"inherit\" === f && (f = 1);\n\n        if (a = a && a.toLowerCase()) {\n          a = a.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n\n          for (q = a.length; q--;) {\n            a[q] = e(a[q]) * f;\n          }\n\n          a = a.join(\",\").replace(/NaN/g, \"none\");\n          this.element.setAttribute(\"stroke-dasharray\", a);\n        }\n      },\n      alignSetter: function alignSetter(a) {\n        this.alignValue = a;\n        this.element.setAttribute(\"text-anchor\", {\n          left: \"start\",\n          center: \"middle\",\n          right: \"end\"\n        }[a]);\n      },\n      opacitySetter: function opacitySetter(a, e, q) {\n        this[e] = a;\n        q.setAttribute(e, a);\n      },\n      titleSetter: function titleSetter(a) {\n        var e = this.element.getElementsByTagName(\"title\")[0];\n        e || (e = m.createElementNS(this.SVG_NS, \"title\"), this.element.appendChild(e));\n        e.firstChild && e.removeChild(e.firstChild);\n        e.appendChild(m.createTextNode(String(B(a), \"\").replace(/<[^>]*>/g, \"\").replace(/&lt;/g, \"\\x3c\").replace(/&gt;/g, \"\\x3e\")));\n      },\n      textSetter: function textSetter(a) {\n        a !== this.textStr && (delete this.bBox, this.textStr = a, this.added && this.renderer.buildText(this));\n      },\n      fillSetter: function fillSetter(a, e, q) {\n        \"string\" === typeof a ? q.setAttribute(e, a) : a && this.complexColor(a, e, q);\n      },\n      visibilitySetter: function visibilitySetter(a, e, q) {\n        \"inherit\" === a ? q.removeAttribute(e) : this[e] !== a && q.setAttribute(e, a);\n        this[e] = a;\n      },\n      zIndexSetter: function zIndexSetter(a, q) {\n        var f = this.renderer,\n            b = this.parentGroup,\n            k = (b || f).element || f.box,\n            l,\n            d = this.element,\n            C,\n            p,\n            f = k === f.box;\n        l = this.added;\n        var g;\n        n(a) ? (d.setAttribute(\"data-z-index\", a), a = +a, this[q] === a && (l = !1)) : n(this[q]) && d.removeAttribute(\"data-z-index\");\n        this[q] = a;\n\n        if (l) {\n          (a = this.zIndex) && b && (b.handleZ = !0);\n          q = k.childNodes;\n\n          for (g = q.length - 1; 0 <= g && !C; g--) {\n            if (b = q[g], l = b.getAttribute(\"data-z-index\"), p = !n(l), b !== d) if (0 > a && p && !f && !g) k.insertBefore(d, q[g]), C = !0;else if (e(l) <= a || p && (!n(a) || 0 <= a)) k.insertBefore(d, q[g + 1] || null), C = !0;\n          }\n\n          C || (k.insertBefore(d, q[f ? 3 : 0] || null), C = !0);\n        }\n\n        return C;\n      },\n      _defaultSetter: function _defaultSetter(a, e, q) {\n        q.setAttribute(e, a);\n      }\n    });\n    y.prototype.yGetter = y.prototype.xGetter;\n\n    y.prototype.translateXSetter = y.prototype.translateYSetter = y.prototype.rotationSetter = y.prototype.verticalAlignSetter = y.prototype.rotationOriginXSetter = y.prototype.rotationOriginYSetter = y.prototype.scaleXSetter = y.prototype.scaleYSetter = y.prototype.matrixSetter = function (a, e) {\n      this[e] = a;\n      this.doTransform = !0;\n    };\n\n    y.prototype[\"stroke-widthSetter\"] = y.prototype.strokeSetter = function (a, e, q) {\n      this[e] = a;\n      this.stroke && this[\"stroke-width\"] ? (y.prototype.fillSetter.call(this, this.stroke, \"stroke\", q), q.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0) : \"stroke-width\" === e && 0 === a && this.hasStroke && (q.removeAttribute(\"stroke\"), this.hasStroke = !1);\n    };\n\n    G = a.SVGRenderer = function () {\n      this.init.apply(this, arguments);\n    };\n\n    p(G.prototype, {\n      Element: y,\n      SVG_NS: K,\n      init: function init(a, e, q, f, b, k, l) {\n        var d;\n        d = this.createElement(\"svg\").attr({\n          version: \"1.1\",\n          \"class\": \"highcharts-root\"\n        });\n        l || d.css(this.getStyle(f));\n        f = d.element;\n        a.appendChild(f);\n        c(a, \"dir\", \"ltr\");\n        -1 === a.innerHTML.indexOf(\"xmlns\") && c(f, \"xmlns\", this.SVG_NS);\n        this.isSVG = !0;\n        this.box = f;\n        this.boxWrapper = d;\n        this.alignedObjects = [];\n        this.url = (x || z) && m.getElementsByTagName(\"base\").length ? S.location.href.split(\"#\")[0].replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\") : \"\";\n        this.createElement(\"desc\").add().element.appendChild(m.createTextNode(\"Created with Highcharts 7.0.1\"));\n        this.defs = this.createElement(\"defs\").add();\n        this.allowHTML = k;\n        this.forExport = b;\n        this.styledMode = l;\n        this.gradients = {};\n        this.cache = {};\n        this.cacheKeys = [];\n        this.imgCount = 0;\n        this.setSize(e, q, !1);\n        var C;\n        x && a.getBoundingClientRect && (e = function e() {\n          v(a, {\n            left: 0,\n            top: 0\n          });\n          C = a.getBoundingClientRect();\n          v(a, {\n            left: Math.ceil(C.left) - C.left + \"px\",\n            top: Math.ceil(C.top) - C.top + \"px\"\n          });\n        }, e(), this.unSubPixelFix = E(S, \"resize\", e));\n      },\n      definition: function definition(a) {\n        function e(a, f) {\n          var b;\n          L(a).forEach(function (a) {\n            var k = q.createElement(a.tagName),\n                l = {};\n            D(a, function (a, e) {\n              \"tagName\" !== e && \"children\" !== e && \"textContent\" !== e && (l[e] = a);\n            });\n            k.attr(l);\n            k.add(f || q.defs);\n            a.textContent && k.element.appendChild(m.createTextNode(a.textContent));\n            e(a.children || [], k);\n            b = k;\n          });\n          return b;\n        }\n\n        var q = this;\n        return e(a);\n      },\n      getStyle: function getStyle(a) {\n        return this.style = p({\n          fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif',\n          fontSize: \"12px\"\n        }, a);\n      },\n      setStyle: function setStyle(a) {\n        this.boxWrapper.css(this.getStyle(a));\n      },\n      isHidden: function isHidden() {\n        return !this.boxWrapper.getBBox().width;\n      },\n      destroy: function destroy() {\n        var a = this.defs;\n        this.box = null;\n        this.boxWrapper = this.boxWrapper.destroy();\n        d(this.gradients || {});\n        this.gradients = null;\n        a && (this.defs = a.destroy());\n        this.unSubPixelFix && this.unSubPixelFix();\n        return this.alignedObjects = null;\n      },\n      createElement: function createElement(a) {\n        var e = new this.Element();\n        e.init(this, a);\n        return e;\n      },\n      draw: A,\n      getRadialAttr: function getRadialAttr(a, e) {\n        return {\n          cx: a[0] - a[2] / 2 + e.cx * a[2],\n          cy: a[1] - a[2] / 2 + e.cy * a[2],\n          r: e.r * a[2]\n        };\n      },\n      truncate: function truncate(a, e, q, f, b, k, l) {\n        var d = this,\n            p = a.rotation,\n            C,\n            g = f ? 1 : 0,\n            A = (q || f).length,\n            K = A,\n            c = [],\n            x = function x(a) {\n          e.firstChild && e.removeChild(e.firstChild);\n          a && e.appendChild(m.createTextNode(a));\n        },\n            n = function n(k, p) {\n          p = p || k;\n          if (void 0 === c[p]) if (e.getSubStringLength) try {\n            c[p] = b + e.getSubStringLength(0, f ? p + 1 : p);\n          } catch (X) {} else d.getSpanWidth && (x(l(q || f, k)), c[p] = b + d.getSpanWidth(a, e));\n          return c[p];\n        },\n            t,\n            I;\n\n        a.rotation = 0;\n        t = n(e.textContent.length);\n\n        if (I = b + t > k) {\n          for (; g <= A;) {\n            K = Math.ceil((g + A) / 2), f && (C = l(f, K)), t = n(K, C && C.length - 1), g === A ? g = A + 1 : t > k ? A = K - 1 : g = K;\n          }\n\n          0 === A ? x(\"\") : q && A === q.length - 1 || x(C || l(q || f, K));\n        }\n\n        f && f.splice(0, K);\n        a.actualWidth = t;\n        a.rotation = p;\n        return I;\n      },\n      escapes: {\n        \"\\x26\": \"\\x26amp;\",\n        \"\\x3c\": \"\\x26lt;\",\n        \"\\x3e\": \"\\x26gt;\",\n        \"'\": \"\\x26#39;\",\n        '\"': \"\\x26quot;\"\n      },\n      buildText: function buildText(a) {\n        var q = a.element,\n            f = this,\n            k = f.forExport,\n            b = B(a.textStr, \"\").toString(),\n            l = -1 !== b.indexOf(\"\\x3c\"),\n            d = q.childNodes,\n            p,\n            g = c(q, \"x\"),\n            C = a.styles,\n            A = a.textWidth,\n            x = C && C.lineHeight,\n            n = C && C.textOutline,\n            t = C && \"ellipsis\" === C.textOverflow,\n            I = C && \"nowrap\" === C.whiteSpace,\n            L = C && C.fontSize,\n            z,\n            H,\n            h = d.length,\n            C = A && !a.added && this.box,\n            F = function F(a) {\n          var b;\n          f.styledMode || (b = /(px|em)$/.test(a && a.style.fontSize) ? a.style.fontSize : L || f.style.fontSize || 12);\n          return x ? e(x) : f.fontMetrics(b, a.getAttribute(\"style\") ? a : q).h;\n        },\n            M = function M(a, e) {\n          D(f.escapes, function (q, f) {\n            e && -1 !== e.indexOf(q) || (a = a.toString().replace(new RegExp(q, \"g\"), f));\n          });\n          return a;\n        },\n            w = function w(a, e) {\n          var q;\n          q = a.indexOf(\"\\x3c\");\n          a = a.substring(q, a.indexOf(\"\\x3e\") - q);\n          q = a.indexOf(e + \"\\x3d\");\n          if (-1 !== q && (q = q + e.length + 1, e = a.charAt(q), '\"' === e || \"'\" === e)) return a = a.substring(q + 1), a.substring(0, a.indexOf(e));\n        };\n\n        z = [b, t, I, x, n, L, A].join();\n\n        if (z !== a.textCache) {\n          for (a.textCache = z; h--;) {\n            q.removeChild(d[h]);\n          }\n\n          l || n || t || A || -1 !== b.indexOf(\" \") ? (C && C.appendChild(q), l ? (b = f.styledMode ? b.replace(/<(b|strong)>/g, '\\x3cspan class\\x3d\"highcharts-strong\"\\x3e').replace(/<(i|em)>/g, '\\x3cspan class\\x3d\"highcharts-emphasized\"\\x3e') : b.replace(/<(b|strong)>/g, '\\x3cspan style\\x3d\"font-weight:bold\"\\x3e').replace(/<(i|em)>/g, '\\x3cspan style\\x3d\"font-style:italic\"\\x3e'), b = b.replace(/<a/g, \"\\x3cspan\").replace(/<\\/(b|strong|i|em|a)>/g, \"\\x3c/span\\x3e\").split(/<br.*?>/g)) : b = [b], b = b.filter(function (a) {\n            return \"\" !== a;\n          }), b.forEach(function (e, b) {\n            var l,\n                d = 0,\n                C = 0;\n            e = e.replace(/^\\s+|\\s+$/g, \"\").replace(/<span/g, \"|||\\x3cspan\").replace(/<\\/span>/g, \"\\x3c/span\\x3e|||\");\n            l = e.split(\"|||\");\n            l.forEach(function (e) {\n              if (\"\" !== e || 1 === l.length) {\n                var x = {},\n                    n = m.createElementNS(f.SVG_NS, \"tspan\"),\n                    D,\n                    B;\n                (D = w(e, \"class\")) && c(n, \"class\", D);\n                if (D = w(e, \"style\")) D = D.replace(/(;| |^)color([ :])/, \"$1fill$2\"), c(n, \"style\", D);\n                (B = w(e, \"href\")) && !k && (c(n, \"onclick\", 'location.href\\x3d\"' + B + '\"'), c(n, \"class\", \"highcharts-anchor\"), f.styledMode || v(n, {\n                  cursor: \"pointer\"\n                }));\n                e = M(e.replace(/<[a-zA-Z\\/](.|\\n)*?>/g, \"\") || \" \");\n\n                if (\" \" !== e) {\n                  n.appendChild(m.createTextNode(e));\n                  d ? x.dx = 0 : b && null !== g && (x.x = g);\n                  c(n, x);\n                  q.appendChild(n);\n                  !d && H && (!R && k && v(n, {\n                    display: \"block\"\n                  }), c(n, \"dy\", F(n)));\n\n                  if (A) {\n                    var z = e.replace(/([^\\^])-/g, \"$1- \").split(\" \"),\n                        x = !I && (1 < l.length || b || 1 < z.length);\n                    B = 0;\n                    var h = F(n);\n                    if (t) p = f.truncate(a, n, e, void 0, 0, Math.max(0, A - parseInt(L || 12, 10)), function (a, e) {\n                      return a.substring(0, e) + \"\\u2026\";\n                    });else if (x) for (; z.length;) {\n                      z.length && !I && 0 < B && (n = m.createElementNS(K, \"tspan\"), c(n, {\n                        dy: h,\n                        x: g\n                      }), D && c(n, \"style\", D), n.appendChild(m.createTextNode(z.join(\" \").replace(/- /g, \"-\"))), q.appendChild(n)), f.truncate(a, n, null, z, 0 === B ? C : 0, A, function (a, e) {\n                        return z.slice(0, e).join(\" \").replace(/- /g, \"-\");\n                      }), C = a.actualWidth, B++;\n                    }\n                  }\n\n                  d++;\n                }\n              }\n            });\n            H = H || q.childNodes.length;\n          }), t && p && a.attr(\"title\", M(a.textStr, [\"\\x26lt;\", \"\\x26gt;\"])), C && C.removeChild(q), n && a.applyTextOutline && a.applyTextOutline(n)) : q.appendChild(m.createTextNode(M(b)));\n        }\n      },\n      getContrast: function getContrast(a) {\n        a = u(a).rgba;\n        a[0] *= 1;\n        a[1] *= 1.2;\n        a[2] *= .5;\n        return 459 < a[0] + a[1] + a[2] ? \"#000000\" : \"#FFFFFF\";\n      },\n      button: function button(a, e, q, f, b, l, d, g, A) {\n        var C = this.label(a, e, q, A, null, null, null, null, \"button\"),\n            K = 0,\n            n = this.styledMode;\n        C.attr(k({\n          padding: 8,\n          r: 2\n        }, b));\n\n        if (!n) {\n          var m, x, c, I;\n          b = k({\n            fill: \"#f7f7f7\",\n            stroke: \"#cccccc\",\n            \"stroke-width\": 1,\n            style: {\n              color: \"#333333\",\n              cursor: \"pointer\",\n              fontWeight: \"normal\"\n            }\n          }, b);\n          m = b.style;\n          delete b.style;\n          l = k(b, {\n            fill: \"#e6e6e6\"\n          }, l);\n          x = l.style;\n          delete l.style;\n          d = k(b, {\n            fill: \"#e6ebf5\",\n            style: {\n              color: \"#000000\",\n              fontWeight: \"bold\"\n            }\n          }, d);\n          c = d.style;\n          delete d.style;\n          g = k(b, {\n            style: {\n              color: \"#cccccc\"\n            }\n          }, g);\n          I = g.style;\n          delete g.style;\n        }\n\n        E(C.element, t ? \"mouseover\" : \"mouseenter\", function () {\n          3 !== K && C.setState(1);\n        });\n        E(C.element, t ? \"mouseout\" : \"mouseleave\", function () {\n          3 !== K && C.setState(K);\n        });\n\n        C.setState = function (a) {\n          1 !== a && (C.state = K = a);\n          C.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][a || 0]);\n          n || C.attr([b, l, d, g][a || 0]).css([m, x, c, I][a || 0]);\n        };\n\n        n || C.attr(b).css(p({\n          cursor: \"default\"\n        }, m));\n        return C.on(\"click\", function (a) {\n          3 !== K && f.call(C, a);\n        });\n      },\n      crispLine: function crispLine(a, e) {\n        a[1] === a[4] && (a[1] = a[4] = Math.round(a[1]) - e % 2 / 2);\n        a[2] === a[5] && (a[2] = a[5] = Math.round(a[2]) + e % 2 / 2);\n        return a;\n      },\n      path: function path(a) {\n        var e = this.styledMode ? {} : {\n          fill: \"none\"\n        };\n        f(a) ? e.d = a : H(a) && p(e, a);\n        return this.createElement(\"path\").attr(e);\n      },\n      circle: function circle(a, e, q) {\n        a = H(a) ? a : void 0 === a ? {} : {\n          x: a,\n          y: e,\n          r: q\n        };\n        e = this.createElement(\"circle\");\n\n        e.xSetter = e.ySetter = function (a, e, q) {\n          q.setAttribute(\"c\" + e, a);\n        };\n\n        return e.attr(a);\n      },\n      arc: function arc(a, e, q, b, f, k) {\n        H(a) ? (b = a, e = b.y, q = b.r, a = b.x) : b = {\n          innerR: b,\n          start: f,\n          end: k\n        };\n        a = this.symbol(\"arc\", a, e, q, q, b);\n        a.r = q;\n        return a;\n      },\n      rect: function rect(a, e, q, b, f, k) {\n        f = H(a) ? a.r : f;\n        var l = this.createElement(\"rect\");\n        a = H(a) ? a : void 0 === a ? {} : {\n          x: a,\n          y: e,\n          width: Math.max(q, 0),\n          height: Math.max(b, 0)\n        };\n        this.styledMode || (void 0 !== k && (a.strokeWidth = k, a = l.crisp(a)), a.fill = \"none\");\n        f && (a.r = f);\n\n        l.rSetter = function (a, e, q) {\n          c(q, {\n            rx: a,\n            ry: a\n          });\n        };\n\n        return l.attr(a);\n      },\n      setSize: function setSize(a, e, q) {\n        var b = this.alignedObjects,\n            f = b.length;\n        this.width = a;\n        this.height = e;\n\n        for (this.boxWrapper.animate({\n          width: a,\n          height: e\n        }, {\n          step: function step() {\n            this.attr({\n              viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n            });\n          },\n          duration: B(q, !0) ? void 0 : 0\n        }); f--;) {\n          b[f].align();\n        }\n      },\n      g: function g(a) {\n        var e = this.createElement(\"g\");\n        return a ? e.attr({\n          \"class\": \"highcharts-\" + a\n        }) : e;\n      },\n      image: function image(a, e, q, b, f, k) {\n        var l = {\n          preserveAspectRatio: \"none\"\n        },\n            d,\n            g = function g(a, e) {\n          a.setAttributeNS ? a.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", e) : a.setAttribute(\"hc-svg-href\", e);\n        },\n            A = function A(e) {\n          g(d.element, a);\n          k.call(d, e);\n        };\n\n        1 < arguments.length && p(l, {\n          x: e,\n          y: q,\n          width: b,\n          height: f\n        });\n        d = this.createElement(\"image\").attr(l);\n        k ? (g(d.element, \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw\\x3d\\x3d\"), l = new S.Image(), E(l, \"load\", A), l.src = a, l.complete && A({})) : g(d.element, a);\n        return d;\n      },\n      symbol: function symbol(a, e, q, b, f, k) {\n        var l = this,\n            d,\n            g = /^url\\((.*?)\\)$/,\n            A = g.test(a),\n            K = !A && (this.symbols[a] ? a : \"circle\"),\n            C = K && this.symbols[K],\n            x = n(e) && C && C.call(this.symbols, Math.round(e), Math.round(q), b, f, k),\n            c,\n            t;\n        C ? (d = this.path(x), l.styledMode || d.attr(\"fill\", \"none\"), p(d, {\n          symbolName: K,\n          x: e,\n          y: q,\n          width: b,\n          height: f\n        }), k && p(d, k)) : A && (c = a.match(g)[1], d = this.image(c), d.imgwidth = B(M[c] && M[c].width, k && k.width), d.imgheight = B(M[c] && M[c].height, k && k.height), t = function t() {\n          d.attr({\n            width: d.width,\n            height: d.height\n          });\n        }, [\"width\", \"height\"].forEach(function (a) {\n          d[a + \"Setter\"] = function (a, e) {\n            var q = {},\n                b = this[\"img\" + e],\n                f = \"width\" === e ? \"translateX\" : \"translateY\";\n            this[e] = a;\n            n(b) && (this.element && this.element.setAttribute(e, b), this.alignByTranslate || (q[f] = ((this[e] || 0) - b) / 2, this.attr(q)));\n          };\n        }), n(e) && d.attr({\n          x: e,\n          y: q\n        }), d.isImg = !0, n(d.imgwidth) && n(d.imgheight) ? t() : (d.attr({\n          width: 0,\n          height: 0\n        }), w(\"img\", {\n          onload: function onload() {\n            var a = r[l.chartIndex];\n            0 === this.width && (v(this, {\n              position: \"absolute\",\n              top: \"-999em\"\n            }), m.body.appendChild(this));\n            M[c] = {\n              width: this.width,\n              height: this.height\n            };\n            d.imgwidth = this.width;\n            d.imgheight = this.height;\n            d.element && t();\n            this.parentNode && this.parentNode.removeChild(this);\n            l.imgCount--;\n            if (!l.imgCount && a && a.onload) a.onload();\n          },\n          src: c\n        }), this.imgCount++));\n        return d;\n      },\n      symbols: {\n        circle: function circle(a, e, q, b) {\n          return this.arc(a + q / 2, e + b / 2, q / 2, b / 2, {\n            start: 0,\n            end: 2 * Math.PI,\n            open: !1\n          });\n        },\n        square: function square(a, e, q, b) {\n          return [\"M\", a, e, \"L\", a + q, e, a + q, e + b, a, e + b, \"Z\"];\n        },\n        triangle: function triangle(a, e, q, b) {\n          return [\"M\", a + q / 2, e, \"L\", a + q, e + b, a, e + b, \"Z\"];\n        },\n        \"triangle-down\": function triangleDown(a, e, q, b) {\n          return [\"M\", a, e, \"L\", a + q, e, a + q / 2, e + b, \"Z\"];\n        },\n        diamond: function diamond(a, e, q, b) {\n          return [\"M\", a + q / 2, e, \"L\", a + q, e + b / 2, a + q / 2, e + b, a, e + b / 2, \"Z\"];\n        },\n        arc: function arc(a, e, q, b, f) {\n          var k = f.start,\n              d = f.r || q,\n              l = f.r || b || q,\n              p = f.end - .001;\n          q = f.innerR;\n          b = B(f.open, .001 > Math.abs(f.end - f.start - 2 * Math.PI));\n          var g = Math.cos(k),\n              A = Math.sin(k),\n              K = Math.cos(p),\n              p = Math.sin(p);\n          f = .001 > f.end - k - Math.PI ? 0 : 1;\n          d = [\"M\", a + d * g, e + l * A, \"A\", d, l, 0, f, 1, a + d * K, e + l * p];\n          n(q) && d.push(b ? \"M\" : \"L\", a + q * K, e + q * p, \"A\", q, q, 0, f, 0, a + q * g, e + q * A);\n          d.push(b ? \"\" : \"Z\");\n          return d;\n        },\n        callout: function callout(a, e, q, b, f) {\n          var k = Math.min(f && f.r || 0, q, b),\n              d = k + 6,\n              l = f && f.anchorX;\n          f = f && f.anchorY;\n          var p;\n          p = [\"M\", a + k, e, \"L\", a + q - k, e, \"C\", a + q, e, a + q, e, a + q, e + k, \"L\", a + q, e + b - k, \"C\", a + q, e + b, a + q, e + b, a + q - k, e + b, \"L\", a + k, e + b, \"C\", a, e + b, a, e + b, a, e + b - k, \"L\", a, e + k, \"C\", a, e, a, e, a + k, e];\n          l && l > q ? f > e + d && f < e + b - d ? p.splice(13, 3, \"L\", a + q, f - 6, a + q + 6, f, a + q, f + 6, a + q, e + b - k) : p.splice(13, 3, \"L\", a + q, b / 2, l, f, a + q, b / 2, a + q, e + b - k) : l && 0 > l ? f > e + d && f < e + b - d ? p.splice(33, 3, \"L\", a, f + 6, a - 6, f, a, f - 6, a, e + k) : p.splice(33, 3, \"L\", a, b / 2, l, f, a, b / 2, a, e + k) : f && f > b && l > a + d && l < a + q - d ? p.splice(23, 3, \"L\", l + 6, e + b, l, e + b + 6, l - 6, e + b, a + k, e + b) : f && 0 > f && l > a + d && l < a + q - d && p.splice(3, 3, \"L\", l - 6, e, l, e - 6, l + 6, e, q - k, e);\n          return p;\n        }\n      },\n      clipRect: function clipRect(e, q, b, f) {\n        var k = a.uniqueKey(),\n            l = this.createElement(\"clipPath\").attr({\n          id: k\n        }).add(this.defs);\n        e = this.rect(e, q, b, f, 0).add(l);\n        e.id = k;\n        e.clipPath = l;\n        e.count = 0;\n        return e;\n      },\n      text: function text(a, e, q, b) {\n        var f = {};\n        if (b && (this.allowHTML || !this.forExport)) return this.html(a, e, q);\n        f.x = Math.round(e || 0);\n        q && (f.y = Math.round(q));\n        n(a) && (f.text = a);\n        a = this.createElement(\"text\").attr(f);\n        b || (a.xSetter = function (a, e, q) {\n          var b = q.getElementsByTagName(\"tspan\"),\n              f,\n              k = q.getAttribute(e),\n              l;\n\n          for (l = 0; l < b.length; l++) {\n            f = b[l], f.getAttribute(e) === k && f.setAttribute(e, a);\n          }\n\n          q.setAttribute(e, a);\n        });\n        return a;\n      },\n      fontMetrics: function fontMetrics(a, q) {\n        a = this.styledMode ? q && y.prototype.getStyle.call(q, \"font-size\") : a || q && q.style && q.style.fontSize || this.style && this.style.fontSize;\n        a = /px/.test(a) ? e(a) : /em/.test(a) ? parseFloat(a) * (q ? this.fontMetrics(null, q.parentNode).f : 16) : 12;\n        q = 24 > a ? a + 3 : Math.round(1.2 * a);\n        return {\n          h: q,\n          b: Math.round(.8 * q),\n          f: a\n        };\n      },\n      rotCorr: function rotCorr(a, e, q) {\n        var b = a;\n        e && q && (b = Math.max(b * Math.cos(e * g), 4));\n        return {\n          x: -a / 3 * Math.sin(e * g),\n          y: b\n        };\n      },\n      label: function label(e, b, f, l, d, g, A, K, c) {\n        var m = this,\n            x = m.styledMode,\n            t = m.g(\"button\" !== c && \"label\"),\n            I = t.text = m.text(\"\", 0, 0, A).attr({\n          zIndex: 1\n        }),\n            D,\n            L,\n            C = 0,\n            B = 3,\n            z = 0,\n            H,\n            h,\n            F,\n            M,\n            R,\n            w = {},\n            r,\n            u,\n            S = /^url\\((.*?)\\)$/.test(l),\n            v = x || S,\n            N = function N() {\n          return x ? D.strokeWidth() % 2 / 2 : (r ? parseInt(r, 10) : 0) % 2 / 2;\n        },\n            P,\n            T,\n            E;\n\n        c && t.addClass(\"highcharts-\" + c);\n\n        P = function P() {\n          var a = I.element.style,\n              e = {};\n          L = (void 0 === H || void 0 === h || R) && n(I.textStr) && I.getBBox();\n          t.width = (H || L.width || 0) + 2 * B + z;\n          t.height = (h || L.height || 0) + 2 * B;\n          u = B + Math.min(m.fontMetrics(a && a.fontSize, I).b, L ? L.height : Infinity);\n          v && (D || (t.box = D = m.symbols[l] || S ? m.symbol(l) : m.rect(), D.addClass((\"button\" === c ? \"\" : \"highcharts-label-box\") + (c ? \" highcharts-\" + c + \"-box\" : \"\")), D.add(t), a = N(), e.x = a, e.y = (K ? -u : 0) + a), e.width = Math.round(t.width), e.height = Math.round(t.height), D.attr(p(e, w)), w = {});\n        };\n\n        T = function T() {\n          var a = z + B,\n              e;\n          e = K ? 0 : u;\n          n(H) && L && (\"center\" === R || \"right\" === R) && (a += {\n            center: .5,\n            right: 1\n          }[R] * (H - L.width));\n          if (a !== I.x || e !== I.y) I.attr(\"x\", a), I.hasBoxWidthChanged && (L = I.getBBox(!0), P()), void 0 !== e && I.attr(\"y\", e);\n          I.x = a;\n          I.y = e;\n        };\n\n        E = function E(a, e) {\n          D ? D.attr(a, e) : w[a] = e;\n        };\n\n        t.onAdd = function () {\n          I.add(t);\n          t.attr({\n            text: e || 0 === e ? e : \"\",\n            x: b,\n            y: f\n          });\n          D && n(d) && t.attr({\n            anchorX: d,\n            anchorY: g\n          });\n        };\n\n        t.widthSetter = function (e) {\n          H = a.isNumber(e) ? e : null;\n        };\n\n        t.heightSetter = function (a) {\n          h = a;\n        };\n\n        t[\"text-alignSetter\"] = function (a) {\n          R = a;\n        };\n\n        t.paddingSetter = function (a) {\n          n(a) && a !== B && (B = t.padding = a, T());\n        };\n\n        t.paddingLeftSetter = function (a) {\n          n(a) && a !== z && (z = a, T());\n        };\n\n        t.alignSetter = function (a) {\n          a = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[a];\n          a !== C && (C = a, L && t.attr({\n            x: F\n          }));\n        };\n\n        t.textSetter = function (a) {\n          void 0 !== a && I.textSetter(a);\n          P();\n          T();\n        };\n\n        t[\"stroke-widthSetter\"] = function (a, e) {\n          a && (v = !0);\n          r = this[\"stroke-width\"] = a;\n          E(e, a);\n        };\n\n        x ? t.rSetter = function (a, e) {\n          E(e, a);\n        } : t.strokeSetter = t.fillSetter = t.rSetter = function (a, e) {\n          \"r\" !== e && (\"fill\" === e && a && (v = !0), t[e] = a);\n          E(e, a);\n        };\n\n        t.anchorXSetter = function (a, e) {\n          d = t.anchorX = a;\n          E(e, Math.round(a) - N() - F);\n        };\n\n        t.anchorYSetter = function (a, e) {\n          g = t.anchorY = a;\n          E(e, a - M);\n        };\n\n        t.xSetter = function (a) {\n          t.x = a;\n          C && (a -= C * ((H || L.width) + 2 * B), t[\"forceAnimate:x\"] = !0);\n          F = Math.round(a);\n          t.attr(\"translateX\", F);\n        };\n\n        t.ySetter = function (a) {\n          M = t.y = Math.round(a);\n          t.attr(\"translateY\", M);\n        };\n\n        var Q = t.css;\n        A = {\n          css: function css(a) {\n            if (a) {\n              var e = {};\n              a = k(a);\n              t.textProps.forEach(function (q) {\n                void 0 !== a[q] && (e[q] = a[q], delete a[q]);\n              });\n              I.css(e);\n              \"width\" in e && P();\n              \"fontSize\" in e && (P(), T());\n            }\n\n            return Q.call(t, a);\n          },\n          getBBox: function getBBox() {\n            return {\n              width: L.width + 2 * B,\n              height: L.height + 2 * B,\n              x: L.x - B,\n              y: L.y - B\n            };\n          },\n          destroy: function destroy() {\n            q(t.element, \"mouseenter\");\n            q(t.element, \"mouseleave\");\n            I && (I = I.destroy());\n            D && (D = D.destroy());\n            y.prototype.destroy.call(t);\n            t = m = P = T = E = null;\n          }\n        };\n        x || (A.shadow = function (a) {\n          a && (P(), D && D.shadow(a));\n          return t;\n        });\n        return p(t, A);\n      }\n    });\n    a.Renderer = G;\n  })(J);\n\n  (function (a) {\n    var y = a.attr,\n        G = a.createElement,\n        E = a.css,\n        h = a.defined,\n        c = a.extend,\n        r = a.isFirefox,\n        u = a.isMS,\n        v = a.isWebKit,\n        w = a.pick,\n        n = a.pInt,\n        g = a.SVGRenderer,\n        d = a.win,\n        m = a.wrap;\n    c(a.SVGElement.prototype, {\n      htmlCss: function htmlCss(a) {\n        var b = \"SPAN\" === this.element.tagName && a && \"width\" in a,\n            l = w(b && a.width, void 0),\n            f;\n        b && (delete a.width, this.textWidth = l, f = !0);\n        a && \"ellipsis\" === a.textOverflow && (a.whiteSpace = \"nowrap\", a.overflow = \"hidden\");\n        this.styles = c(this.styles, a);\n        E(this.element, a);\n        f && this.htmlUpdateTransform();\n        return this;\n      },\n      htmlGetBBox: function htmlGetBBox() {\n        var a = this.element;\n        return {\n          x: a.offsetLeft,\n          y: a.offsetTop,\n          width: a.offsetWidth,\n          height: a.offsetHeight\n        };\n      },\n      htmlUpdateTransform: function htmlUpdateTransform() {\n        if (this.added) {\n          var a = this.renderer,\n              b = this.element,\n              l = this.translateX || 0,\n              f = this.translateY || 0,\n              d = this.x || 0,\n              g = this.y || 0,\n              m = this.textAlign || \"left\",\n              c = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[m],\n              z = this.styles,\n              k = z && z.whiteSpace;\n          E(b, {\n            marginLeft: l,\n            marginTop: f\n          });\n          !a.styledMode && this.shadows && this.shadows.forEach(function (a) {\n            E(a, {\n              marginLeft: l + 1,\n              marginTop: f + 1\n            });\n          });\n          this.inverted && b.childNodes.forEach(function (e) {\n            a.invertChild(e, b);\n          });\n\n          if (\"SPAN\" === b.tagName) {\n            var z = this.rotation,\n                A = this.textWidth && n(this.textWidth),\n                D = [z, m, b.innerHTML, this.textWidth, this.textAlign].join(),\n                B;\n            (B = A !== this.oldTextWidth) && !(B = A > this.oldTextWidth) && ((B = this.textPxLength) || (E(b, {\n              width: \"\",\n              whiteSpace: k || \"nowrap\"\n            }), B = b.offsetWidth), B = B > A);\n            B && (/[ \\-]/.test(b.textContent || b.innerText) || \"ellipsis\" === b.style.textOverflow) ? (E(b, {\n              width: A + \"px\",\n              display: \"block\",\n              whiteSpace: k || \"normal\"\n            }), this.oldTextWidth = A, this.hasBoxWidthChanged = !0) : this.hasBoxWidthChanged = !1;\n            D !== this.cTT && (k = a.fontMetrics(b.style.fontSize, b).b, !h(z) || z === (this.oldRotation || 0) && m === this.oldAlign || this.setSpanRotation(z, c, k), this.getSpanCorrection(!h(z) && this.textPxLength || b.offsetWidth, k, c, z, m));\n            E(b, {\n              left: d + (this.xCorr || 0) + \"px\",\n              top: g + (this.yCorr || 0) + \"px\"\n            });\n            this.cTT = D;\n            this.oldRotation = z;\n            this.oldAlign = m;\n          }\n        } else this.alignOnAdd = !0;\n      },\n      setSpanRotation: function setSpanRotation(a, b, l) {\n        var f = {},\n            d = this.renderer.getTransformKey();\n        f[d] = f.transform = \"rotate(\" + a + \"deg)\";\n        f[d + (r ? \"Origin\" : \"-origin\")] = f.transformOrigin = 100 * b + \"% \" + l + \"px\";\n        E(this.element, f);\n      },\n      getSpanCorrection: function getSpanCorrection(a, b, l) {\n        this.xCorr = -a * l;\n        this.yCorr = -b;\n      }\n    });\n    c(g.prototype, {\n      getTransformKey: function getTransformKey() {\n        return u && !/Edge/.test(d.navigator.userAgent) ? \"-ms-transform\" : v ? \"-webkit-transform\" : r ? \"MozTransform\" : d.opera ? \"-o-transform\" : \"\";\n      },\n      html: function html(d, b, l) {\n        var f = this.createElement(\"span\"),\n            g = f.element,\n            p = f.renderer,\n            n = p.isSVG,\n            h = function h(a, b) {\n          [\"opacity\", \"visibility\"].forEach(function (f) {\n            m(a, f + \"Setter\", function (a, e, q, f) {\n              a.call(this, e, q, f);\n              b[q] = e;\n            });\n          });\n          a.addedSetters = !0;\n        },\n            z = a.charts[p.chartIndex],\n            z = z && z.styledMode;\n\n        f.textSetter = function (a) {\n          a !== g.innerHTML && delete this.bBox;\n          this.textStr = a;\n          g.innerHTML = w(a, \"\");\n          f.doTransform = !0;\n        };\n\n        n && h(f, f.element.style);\n\n        f.xSetter = f.ySetter = f.alignSetter = f.rotationSetter = function (a, b) {\n          \"align\" === b && (b = \"textAlign\");\n          f[b] = a;\n          f.doTransform = !0;\n        };\n\n        f.afterSetters = function () {\n          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);\n        };\n\n        f.attr({\n          text: d,\n          x: Math.round(b),\n          y: Math.round(l)\n        }).css({\n          position: \"absolute\"\n        });\n        z || f.css({\n          fontFamily: this.style.fontFamily,\n          fontSize: this.style.fontSize\n        });\n        g.style.whiteSpace = \"nowrap\";\n        f.css = f.htmlCss;\n        n && (f.add = function (a) {\n          var b,\n              l = p.box.parentNode,\n              k = [];\n\n          if (this.parentGroup = a) {\n            if (b = a.div, !b) {\n              for (; a;) {\n                k.push(a), a = a.parentGroup;\n              }\n\n              k.reverse().forEach(function (a) {\n                function e(e, q) {\n                  a[q] = e;\n                  \"translateX\" === q ? d.left = e + \"px\" : d.top = e + \"px\";\n                  a.doTransform = !0;\n                }\n\n                var d,\n                    g = y(a.element, \"class\");\n                g && (g = {\n                  className: g\n                });\n                b = a.div = a.div || G(\"div\", g, {\n                  position: \"absolute\",\n                  left: (a.translateX || 0) + \"px\",\n                  top: (a.translateY || 0) + \"px\",\n                  display: a.display,\n                  opacity: a.opacity,\n                  pointerEvents: a.styles && a.styles.pointerEvents\n                }, b || l);\n                d = b.style;\n                c(a, {\n                  classSetter: function (a) {\n                    return function (e) {\n                      this.element.setAttribute(\"class\", e);\n                      a.className = e;\n                    };\n                  }(b),\n                  on: function on() {\n                    k[0].div && f.on.apply({\n                      element: k[0].div\n                    }, arguments);\n                    return a;\n                  },\n                  translateXSetter: e,\n                  translateYSetter: e\n                });\n                a.addedSetters || h(a, d);\n              });\n            }\n          } else b = l;\n\n          b.appendChild(g);\n          f.added = !0;\n          f.alignOnAdd && f.htmlUpdateTransform();\n          return f;\n        });\n        return f;\n      }\n    });\n  })(J);\n\n  (function (a) {\n    var y = a.defined,\n        G = a.extend,\n        E = a.merge,\n        h = a.pick,\n        c = a.timeUnits,\n        r = a.win;\n\n    a.Time = function (a) {\n      this.update(a, !1);\n    };\n\n    a.Time.prototype = {\n      defaultOptions: {},\n      update: function update(a) {\n        var c = h(a && a.useUTC, !0),\n            w = this;\n        this.options = a = E(!0, this.options || {}, a);\n        this.Date = a.Date || r.Date;\n        this.timezoneOffset = (this.useUTC = c) && a.timezoneOffset;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        (this.variableTimezone = !(c && !a.getTimezoneOffset && !a.timezone)) || this.timezoneOffset ? (this.get = function (a, g) {\n          var d = g.getTime(),\n              m = d - w.getTimezoneOffset(g);\n          g.setTime(m);\n          a = g[\"getUTC\" + a]();\n          g.setTime(d);\n          return a;\n        }, this.set = function (a, g, d) {\n          var m;\n          if (\"Milliseconds\" === a || \"Seconds\" === a || \"Minutes\" === a && 0 === g.getTimezoneOffset() % 60) g[\"set\" + a](d);else m = w.getTimezoneOffset(g), m = g.getTime() - m, g.setTime(m), g[\"setUTC\" + a](d), a = w.getTimezoneOffset(g), m = g.getTime() + a, g.setTime(m);\n        }) : c ? (this.get = function (a, g) {\n          return g[\"getUTC\" + a]();\n        }, this.set = function (a, g, d) {\n          return g[\"setUTC\" + a](d);\n        }) : (this.get = function (a, g) {\n          return g[\"get\" + a]();\n        }, this.set = function (a, g, d) {\n          return g[\"set\" + a](d);\n        });\n      },\n      makeTime: function makeTime(c, r, w, n, g, d) {\n        var m, p, b;\n        this.useUTC ? (m = this.Date.UTC.apply(0, arguments), p = this.getTimezoneOffset(m), m += p, b = this.getTimezoneOffset(m), p !== b ? m += b - p : p - 36E5 !== this.getTimezoneOffset(m - 36E5) || a.isSafari || (m -= 36E5)) : m = new this.Date(c, r, h(w, 1), h(n, 0), h(g, 0), h(d, 0)).getTime();\n        return m;\n      },\n      timezoneOffsetFunction: function timezoneOffsetFunction() {\n        var c = this,\n            h = this.options,\n            w = r.moment;\n        if (!this.useUTC) return function (a) {\n          return 6E4 * new Date(a).getTimezoneOffset();\n        };\n\n        if (h.timezone) {\n          if (w) return function (a) {\n            return 6E4 * -w.tz(a, h.timezone).utcOffset();\n          };\n          a.error(25);\n        }\n\n        return this.useUTC && h.getTimezoneOffset ? function (a) {\n          return 6E4 * h.getTimezoneOffset(a);\n        } : function () {\n          return 6E4 * (c.timezoneOffset || 0);\n        };\n      },\n      dateFormat: function dateFormat(c, h, w) {\n        if (!a.defined(h) || isNaN(h)) return a.defaultOptions.lang.invalidDate || \"\";\n        c = a.pick(c, \"%Y-%m-%d %H:%M:%S\");\n        var n = this,\n            g = new this.Date(h),\n            d = this.get(\"Hours\", g),\n            m = this.get(\"Day\", g),\n            p = this.get(\"Date\", g),\n            b = this.get(\"Month\", g),\n            l = this.get(\"FullYear\", g),\n            f = a.defaultOptions.lang,\n            x = f.weekdays,\n            t = f.shortWeekdays,\n            H = a.pad,\n            g = a.extend({\n          a: t ? t[m] : x[m].substr(0, 3),\n          A: x[m],\n          d: H(p),\n          e: H(p, 2, \" \"),\n          w: m,\n          b: f.shortMonths[b],\n          B: f.months[b],\n          m: H(b + 1),\n          o: b + 1,\n          y: l.toString().substr(2, 2),\n          Y: l,\n          H: H(d),\n          k: d,\n          I: H(d % 12 || 12),\n          l: d % 12 || 12,\n          M: H(n.get(\"Minutes\", g)),\n          p: 12 > d ? \"AM\" : \"PM\",\n          P: 12 > d ? \"am\" : \"pm\",\n          S: H(g.getSeconds()),\n          L: H(Math.floor(h % 1E3), 3)\n        }, a.dateFormats);\n        a.objectEach(g, function (a, b) {\n          for (; -1 !== c.indexOf(\"%\" + b);) {\n            c = c.replace(\"%\" + b, \"function\" === typeof a ? a.call(n, h) : a);\n          }\n        });\n        return w ? c.substr(0, 1).toUpperCase() + c.substr(1) : c;\n      },\n      resolveDTLFormat: function resolveDTLFormat(c) {\n        return a.isObject(c, !0) ? c : (c = a.splat(c), {\n          main: c[0],\n          from: c[1],\n          to: c[2]\n        });\n      },\n      getTimeTicks: function getTimeTicks(a, r, w, n) {\n        var g = this,\n            d = [],\n            m,\n            p = {},\n            b;\n        m = new g.Date(r);\n        var l = a.unitRange,\n            f = a.count || 1,\n            x;\n        n = h(n, 1);\n\n        if (y(r)) {\n          g.set(\"Milliseconds\", m, l >= c.second ? 0 : f * Math.floor(g.get(\"Milliseconds\", m) / f));\n          l >= c.second && g.set(\"Seconds\", m, l >= c.minute ? 0 : f * Math.floor(g.get(\"Seconds\", m) / f));\n          l >= c.minute && g.set(\"Minutes\", m, l >= c.hour ? 0 : f * Math.floor(g.get(\"Minutes\", m) / f));\n          l >= c.hour && g.set(\"Hours\", m, l >= c.day ? 0 : f * Math.floor(g.get(\"Hours\", m) / f));\n          l >= c.day && g.set(\"Date\", m, l >= c.month ? 1 : Math.max(1, f * Math.floor(g.get(\"Date\", m) / f)));\n          l >= c.month && (g.set(\"Month\", m, l >= c.year ? 0 : f * Math.floor(g.get(\"Month\", m) / f)), b = g.get(\"FullYear\", m));\n          l >= c.year && g.set(\"FullYear\", m, b - b % f);\n          l === c.week && (b = g.get(\"Day\", m), g.set(\"Date\", m, g.get(\"Date\", m) - b + n + (b < n ? -7 : 0)));\n          b = g.get(\"FullYear\", m);\n          n = g.get(\"Month\", m);\n          var t = g.get(\"Date\", m),\n              H = g.get(\"Hours\", m);\n          r = m.getTime();\n          g.variableTimezone && (x = w - r > 4 * c.month || g.getTimezoneOffset(r) !== g.getTimezoneOffset(w));\n          r = m.getTime();\n\n          for (m = 1; r < w;) {\n            d.push(r), r = l === c.year ? g.makeTime(b + m * f, 0) : l === c.month ? g.makeTime(b, n + m * f) : !x || l !== c.day && l !== c.week ? x && l === c.hour && 1 < f ? g.makeTime(b, n, t, H + m * f) : r + l * f : g.makeTime(b, n, t + m * f * (l === c.day ? 1 : 7)), m++;\n          }\n\n          d.push(r);\n          l <= c.hour && 1E4 > d.length && d.forEach(function (a) {\n            0 === a % 18E5 && \"000000000\" === g.dateFormat(\"%H%M%S%L\", a) && (p[a] = \"day\");\n          });\n        }\n\n        d.info = G(a, {\n          higherRanks: p,\n          totalRange: l * f\n        });\n        return d;\n      }\n    };\n  })(J);\n\n  (function (a) {\n    var y = a.color,\n        G = a.merge;\n    a.defaultOptions = {\n      colors: \"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1\".split(\" \"),\n      symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n      lang: {\n        loading: \"Loading...\",\n        months: \"January February March April May June July August September October November December\".split(\" \"),\n        shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n        weekdays: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n        decimalPoint: \".\",\n        numericSymbols: \"kMGTPE\".split(\"\"),\n        resetZoom: \"Reset zoom\",\n        resetZoomTitle: \"Reset zoom level 1:1\",\n        thousandsSep: \" \"\n      },\n      global: {},\n      time: a.Time.prototype.defaultOptions,\n      chart: {\n        styledMode: !1,\n        borderRadius: 0,\n        colorCount: 10,\n        defaultSeriesType: \"line\",\n        ignoreHiddenSeries: !0,\n        spacing: [10, 10, 15, 10],\n        resetZoomButton: {\n          theme: {\n            zIndex: 6\n          },\n          position: {\n            align: \"right\",\n            x: -10,\n            y: 10\n          }\n        },\n        width: null,\n        height: null,\n        borderColor: \"#335cad\",\n        backgroundColor: \"#ffffff\",\n        plotBorderColor: \"#cccccc\"\n      },\n      title: {\n        text: \"Chart title\",\n        align: \"center\",\n        margin: 15,\n        widthAdjust: -44\n      },\n      subtitle: {\n        text: \"\",\n        align: \"center\",\n        widthAdjust: -44\n      },\n      plotOptions: {},\n      labels: {\n        style: {\n          position: \"absolute\",\n          color: \"#333333\"\n        }\n      },\n      legend: {\n        enabled: !0,\n        align: \"center\",\n        alignColumns: !0,\n        layout: \"horizontal\",\n        labelFormatter: function labelFormatter() {\n          return this.name;\n        },\n        borderColor: \"#999999\",\n        borderRadius: 0,\n        navigation: {\n          activeColor: \"#003399\",\n          inactiveColor: \"#cccccc\"\n        },\n        itemStyle: {\n          color: \"#333333\",\n          cursor: \"pointer\",\n          fontSize: \"12px\",\n          fontWeight: \"bold\",\n          textOverflow: \"ellipsis\"\n        },\n        itemHoverStyle: {\n          color: \"#000000\"\n        },\n        itemHiddenStyle: {\n          color: \"#cccccc\"\n        },\n        shadow: !1,\n        itemCheckboxStyle: {\n          position: \"absolute\",\n          width: \"13px\",\n          height: \"13px\"\n        },\n        squareSymbol: !0,\n        symbolPadding: 5,\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0,\n        title: {\n          style: {\n            fontWeight: \"bold\"\n          }\n        }\n      },\n      loading: {\n        labelStyle: {\n          fontWeight: \"bold\",\n          position: \"relative\",\n          top: \"45%\"\n        },\n        style: {\n          position: \"absolute\",\n          backgroundColor: \"#ffffff\",\n          opacity: .5,\n          textAlign: \"center\"\n        }\n      },\n      tooltip: {\n        enabled: !0,\n        animation: a.svg,\n        borderRadius: 3,\n        dateTimeLabelFormats: {\n          millisecond: \"%A, %b %e, %H:%M:%S.%L\",\n          second: \"%A, %b %e, %H:%M:%S\",\n          minute: \"%A, %b %e, %H:%M\",\n          hour: \"%A, %b %e, %H:%M\",\n          day: \"%A, %b %e, %Y\",\n          week: \"Week from %A, %b %e, %Y\",\n          month: \"%B %Y\",\n          year: \"%Y\"\n        },\n        footerFormat: \"\",\n        padding: 8,\n        snap: a.isTouchDevice ? 25 : 10,\n        headerFormat: '\\x3cspan style\\x3d\"font-size: 10px\"\\x3e{point.key}\\x3c/span\\x3e\\x3cbr/\\x3e',\n        pointFormat: \"<span style=\\\"color:{point.color}\\\">\\u25CF</span> {series.name}: <b>{point.y}</b><br/>\",\n        backgroundColor: y(\"#f7f7f7\").setOpacity(.85).get(),\n        borderWidth: 1,\n        shadow: !0,\n        style: {\n          color: \"#333333\",\n          cursor: \"default\",\n          fontSize: \"12px\",\n          pointerEvents: \"none\",\n          whiteSpace: \"nowrap\"\n        }\n      },\n      credits: {\n        enabled: !0,\n        href: \"https://www.highcharts.com?credits\",\n        position: {\n          align: \"right\",\n          x: -10,\n          verticalAlign: \"bottom\",\n          y: -5\n        },\n        style: {\n          cursor: \"pointer\",\n          color: \"#999999\",\n          fontSize: \"9px\"\n        },\n        text: \"Highcharts.com\"\n      }\n    };\n\n    a.setOptions = function (y) {\n      a.defaultOptions = G(!0, a.defaultOptions, y);\n      a.time.update(G(a.defaultOptions.global, a.defaultOptions.time), !1);\n      return a.defaultOptions;\n    };\n\n    a.getOptions = function () {\n      return a.defaultOptions;\n    };\n\n    a.defaultPlotOptions = a.defaultOptions.plotOptions;\n    a.time = new a.Time(G(a.defaultOptions.global, a.defaultOptions.time));\n\n    a.dateFormat = function (y, h, c) {\n      return a.time.dateFormat(y, h, c);\n    };\n  })(J);\n\n  (function (a) {\n    var y = a.correctFloat,\n        G = a.defined,\n        E = a.destroyObjectProperties,\n        h = a.fireEvent,\n        c = a.isNumber,\n        r = a.merge,\n        u = a.pick,\n        v = a.deg2rad;\n\n    a.Tick = function (a, c, g, d, m) {\n      this.axis = a;\n      this.pos = c;\n      this.type = g || \"\";\n      this.isNewLabel = this.isNew = !0;\n      this.parameters = m || {};\n      this.tickmarkOffset = this.parameters.tickmarkOffset;\n      this.options = this.parameters.options;\n      g || d || this.addLabel();\n    };\n\n    a.Tick.prototype = {\n      addLabel: function addLabel() {\n        var c = this,\n            n = c.axis,\n            g = n.options,\n            d = n.chart,\n            m = n.categories,\n            p = n.names,\n            b = c.pos,\n            l = u(c.options && c.options.labels, g.labels),\n            f = n.tickPositions,\n            x = b === f[0],\n            t = b === f[f.length - 1],\n            m = this.parameters.category || (m ? u(m[b], p[b], b) : b),\n            h = c.label,\n            f = f.info,\n            F,\n            z,\n            k,\n            A;\n        n.isDatetimeAxis && f && (z = d.time.resolveDTLFormat(g.dateTimeLabelFormats[!g.grid && f.higherRanks[b] || f.unitName]), F = z.main);\n        c.isFirst = x;\n        c.isLast = t;\n        c.formatCtx = {\n          axis: n,\n          chart: d,\n          isFirst: x,\n          isLast: t,\n          dateTimeLabelFormat: F,\n          tickPositionInfo: f,\n          value: n.isLog ? y(n.lin2log(m)) : m,\n          pos: b\n        };\n        g = n.labelFormatter.call(c.formatCtx, this.formatCtx);\n        if (A = z && z.list) c.shortenLabel = function () {\n          for (k = 0; k < A.length; k++) {\n            if (h.attr({\n              text: n.labelFormatter.call(a.extend(c.formatCtx, {\n                dateTimeLabelFormat: A[k]\n              }))\n            }), h.getBBox().width < n.getSlotWidth(c) - 2 * u(l.padding, 5)) return;\n          }\n\n          h.attr({\n            text: \"\"\n          });\n        };\n        if (G(h)) h && h.textStr !== g && (!h.textWidth || l.style && l.style.width || h.styles.width || h.css({\n          width: null\n        }), h.attr({\n          text: g\n        }));else {\n          if (c.label = h = G(g) && l.enabled ? d.renderer.text(g, 0, 0, l.useHTML).add(n.labelGroup) : null) d.styledMode || h.css(r(l.style)), h.textPxLength = h.getBBox().width;\n          c.rotation = 0;\n        }\n      },\n      getLabelSize: function getLabelSize() {\n        return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n      },\n      handleOverflow: function handleOverflow(a) {\n        var c = this.axis,\n            g = c.options.labels,\n            d = a.x,\n            m = c.chart.chartWidth,\n            p = c.chart.spacing,\n            b = u(c.labelLeft, Math.min(c.pos, p[3])),\n            p = u(c.labelRight, Math.max(c.isRadial ? 0 : c.pos + c.len, m - p[1])),\n            l = this.label,\n            f = this.rotation,\n            x = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[c.labelAlign || l.attr(\"align\")],\n            t = l.getBBox().width,\n            h = c.getSlotWidth(this),\n            F = h,\n            z = 1,\n            k,\n            A = {};\n        if (f || \"justify\" !== u(g.overflow, \"justify\")) 0 > f && d - x * t < b ? k = Math.round(d / Math.cos(f * v) - b) : 0 < f && d + x * t > p && (k = Math.round((m - d) / Math.cos(f * v)));else if (m = d + (1 - x) * t, d - x * t < b ? F = a.x + F * (1 - x) - b : m > p && (F = p - a.x + F * x, z = -1), F = Math.min(h, F), F < h && \"center\" === c.labelAlign && (a.x += z * (h - F - x * (h - Math.min(t, F)))), t > F || c.autoRotation && (l.styles || {}).width) k = F;\n        k && (this.shortenLabel ? this.shortenLabel() : (A.width = Math.floor(k), (g.style || {}).textOverflow || (A.textOverflow = \"ellipsis\"), l.css(A)));\n      },\n      getPosition: function getPosition(c, n, g, d) {\n        var m = this.axis,\n            p = m.chart,\n            b = d && p.oldChartHeight || p.chartHeight;\n        c = {\n          x: c ? a.correctFloat(m.translate(n + g, null, null, d) + m.transB) : m.left + m.offset + (m.opposite ? (d && p.oldChartWidth || p.chartWidth) - m.right - m.left : 0),\n          y: c ? b - m.bottom + m.offset - (m.opposite ? m.height : 0) : a.correctFloat(b - m.translate(n + g, null, null, d) - m.transB)\n        };\n        h(this, \"afterGetPosition\", {\n          pos: c\n        });\n        return c;\n      },\n      getLabelPosition: function getLabelPosition(a, c, g, d, m, p, b, l) {\n        var f = this.axis,\n            x = f.transA,\n            t = f.reversed,\n            n = f.staggerLines,\n            F = f.tickRotCorr || {\n          x: 0,\n          y: 0\n        },\n            z = m.y,\n            k = d || f.reserveSpaceDefault ? 0 : -f.labelOffset * (\"center\" === f.labelAlign ? .5 : 1),\n            A = {};\n        G(z) || (z = 0 === f.side ? g.rotation ? -8 : -g.getBBox().height : 2 === f.side ? F.y + 8 : Math.cos(g.rotation * v) * (F.y - g.getBBox(!1, 0).height / 2));\n        a = a + m.x + k + F.x - (p && d ? p * x * (t ? -1 : 1) : 0);\n        c = c + z - (p && !d ? p * x * (t ? 1 : -1) : 0);\n        n && (g = b / (l || 1) % n, f.opposite && (g = n - g - 1), c += f.labelOffset / n * g);\n        A.x = a;\n        A.y = Math.round(c);\n        h(this, \"afterGetLabelPosition\", {\n          pos: A\n        });\n        return A;\n      },\n      getMarkPath: function getMarkPath(a, c, g, d, m, p) {\n        return p.crispLine([\"M\", a, c, \"L\", a + (m ? 0 : -g), c + (m ? g : 0)], d);\n      },\n      renderGridLine: function renderGridLine(a, c, g) {\n        var d = this.axis,\n            m = d.options,\n            p = this.gridLine,\n            b = {},\n            l = this.pos,\n            f = this.type,\n            x = u(this.tickmarkOffset, d.tickmarkOffset),\n            t = d.chart.renderer,\n            n = f ? f + \"Grid\" : \"grid\",\n            h = m[n + \"LineWidth\"],\n            z = m[n + \"LineColor\"],\n            m = m[n + \"LineDashStyle\"];\n        p || (d.chart.styledMode || (b.stroke = z, b[\"stroke-width\"] = h, m && (b.dashstyle = m)), f || (b.zIndex = 1), a && (c = 0), this.gridLine = p = t.path().attr(b).addClass(\"highcharts-\" + (f ? f + \"-\" : \"\") + \"grid-line\").add(d.gridGroup));\n        if (p && (g = d.getPlotLinePath(l + x, p.strokeWidth() * g, a, \"pass\"))) p[a || this.isNew ? \"attr\" : \"animate\"]({\n          d: g,\n          opacity: c\n        });\n      },\n      renderMark: function renderMark(a, c, g) {\n        var d = this.axis,\n            m = d.options,\n            p = d.chart.renderer,\n            b = this.type,\n            l = b ? b + \"Tick\" : \"tick\",\n            f = d.tickSize(l),\n            x = this.mark,\n            t = !x,\n            n = a.x;\n        a = a.y;\n        var h = u(m[l + \"Width\"], !b && d.isXAxis ? 1 : 0),\n            m = m[l + \"Color\"];\n        f && (d.opposite && (f[0] = -f[0]), t && (this.mark = x = p.path().addClass(\"highcharts-\" + (b ? b + \"-\" : \"\") + \"tick\").add(d.axisGroup), d.chart.styledMode || x.attr({\n          stroke: m,\n          \"stroke-width\": h\n        })), x[t ? \"attr\" : \"animate\"]({\n          d: this.getMarkPath(n, a, f[0], x.strokeWidth() * g, d.horiz, p),\n          opacity: c\n        }));\n      },\n      renderLabel: function renderLabel(a, n, g, d) {\n        var m = this.axis,\n            p = m.horiz,\n            b = m.options,\n            l = this.label,\n            f = b.labels,\n            x = f.step,\n            m = u(this.tickmarkOffset, m.tickmarkOffset),\n            t = !0,\n            h = a.x;\n        a = a.y;\n        l && c(h) && (l.xy = a = this.getLabelPosition(h, a, l, p, f, m, d, x), this.isFirst && !this.isLast && !u(b.showFirstLabel, 1) || this.isLast && !this.isFirst && !u(b.showLastLabel, 1) ? t = !1 : !p || f.step || f.rotation || n || 0 === g || this.handleOverflow(a), x && d % x && (t = !1), t && c(a.y) ? (a.opacity = g, l[this.isNewLabel ? \"attr\" : \"animate\"](a), this.isNewLabel = !1) : (l.attr(\"y\", -9999), this.isNewLabel = !0));\n      },\n      render: function render(c, n, g) {\n        var d = this.axis,\n            m = d.horiz,\n            p = this.pos,\n            b = u(this.tickmarkOffset, d.tickmarkOffset),\n            p = this.getPosition(m, p, b, n),\n            b = p.x,\n            l = p.y,\n            d = m && b === d.pos + d.len || !m && l === d.pos ? -1 : 1;\n        g = u(g, 1);\n        this.isActive = !0;\n        this.renderGridLine(n, g, d);\n        this.renderMark(p, g, d);\n        this.renderLabel(p, n, g, c);\n        this.isNew = !1;\n        a.fireEvent(this, \"afterRender\");\n      },\n      destroy: function destroy() {\n        E(this, this.axis);\n      }\n    };\n  })(J);\n\n  var V = function (a) {\n    var y = a.addEvent,\n        G = a.animObject,\n        E = a.arrayMax,\n        h = a.arrayMin,\n        c = a.color,\n        r = a.correctFloat,\n        u = a.defaultOptions,\n        v = a.defined,\n        w = a.deg2rad,\n        n = a.destroyObjectProperties,\n        g = a.extend,\n        d = a.fireEvent,\n        m = a.format,\n        p = a.getMagnitude,\n        b = a.isArray,\n        l = a.isNumber,\n        f = a.isString,\n        x = a.merge,\n        t = a.normalizeTickInterval,\n        H = a.objectEach,\n        F = a.pick,\n        z = a.removeEvent,\n        k = a.splat,\n        A = a.syncTimeout,\n        D = a.Tick,\n        B = function B() {\n      this.init.apply(this, arguments);\n    };\n\n    a.extend(B.prototype, {\n      defaultOptions: {\n        dateTimeLabelFormats: {\n          millisecond: {\n            main: \"%H:%M:%S.%L\",\n            range: !1\n          },\n          second: {\n            main: \"%H:%M:%S\",\n            range: !1\n          },\n          minute: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          hour: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          day: {\n            main: \"%e. %b\"\n          },\n          week: {\n            main: \"%e. %b\"\n          },\n          month: {\n            main: \"%b '%y\"\n          },\n          year: {\n            main: \"%Y\"\n          }\n        },\n        endOnTick: !1,\n        labels: {\n          enabled: !0,\n          indentation: 10,\n          x: 0,\n          style: {\n            color: \"#666666\",\n            cursor: \"default\",\n            fontSize: \"11px\"\n          }\n        },\n        maxPadding: .01,\n        minorTickLength: 2,\n        minorTickPosition: \"outside\",\n        minPadding: .01,\n        startOfWeek: 1,\n        startOnTick: !1,\n        tickLength: 10,\n        tickPixelInterval: 100,\n        tickmarkPlacement: \"between\",\n        tickPosition: \"outside\",\n        title: {\n          align: \"middle\",\n          style: {\n            color: \"#666666\"\n          }\n        },\n        type: \"linear\",\n        minorGridLineColor: \"#f2f2f2\",\n        minorGridLineWidth: 1,\n        minorTickColor: \"#999999\",\n        lineColor: \"#ccd6eb\",\n        lineWidth: 1,\n        gridLineColor: \"#e6e6e6\",\n        tickColor: \"#ccd6eb\"\n      },\n      defaultYAxisOptions: {\n        endOnTick: !0,\n        maxPadding: .05,\n        minPadding: .05,\n        tickPixelInterval: 72,\n        showLastLabel: !0,\n        labels: {\n          x: -8\n        },\n        startOnTick: !0,\n        title: {\n          rotation: 270,\n          text: \"Values\"\n        },\n        stackLabels: {\n          allowOverlap: !1,\n          enabled: !1,\n          formatter: function formatter() {\n            return a.numberFormat(this.total, -1);\n          },\n          style: {\n            color: \"#000000\",\n            fontSize: \"11px\",\n            fontWeight: \"bold\",\n            textOutline: \"1px contrast\"\n          }\n        },\n        gridLineWidth: 1,\n        lineWidth: 0\n      },\n      defaultLeftAxisOptions: {\n        labels: {\n          x: -15\n        },\n        title: {\n          rotation: 270\n        }\n      },\n      defaultRightAxisOptions: {\n        labels: {\n          x: 15\n        },\n        title: {\n          rotation: 90\n        }\n      },\n      defaultBottomAxisOptions: {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        title: {\n          rotation: 0\n        }\n      },\n      defaultTopAxisOptions: {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        title: {\n          rotation: 0\n        }\n      },\n      init: function init(a, q) {\n        var e = q.isX,\n            b = this;\n        b.chart = a;\n        b.horiz = a.inverted && !b.isZAxis ? !e : e;\n        b.isXAxis = e;\n        b.coll = b.coll || (e ? \"xAxis\" : \"yAxis\");\n        d(this, \"init\", {\n          userOptions: q\n        });\n        b.opposite = q.opposite;\n        b.side = q.side || (b.horiz ? b.opposite ? 0 : 2 : b.opposite ? 1 : 3);\n        b.setOptions(q);\n        var f = this.options,\n            l = f.type;\n        b.labelFormatter = f.labels.formatter || b.defaultLabelFormatter;\n        b.userOptions = q;\n        b.minPixelPadding = 0;\n        b.reversed = f.reversed;\n        b.visible = !1 !== f.visible;\n        b.zoomEnabled = !1 !== f.zoomEnabled;\n        b.hasNames = \"category\" === l || !0 === f.categories;\n        b.categories = f.categories || b.hasNames;\n        b.names || (b.names = [], b.names.keys = {});\n        b.plotLinesAndBandsGroups = {};\n        b.isLog = \"logarithmic\" === l;\n        b.isDatetimeAxis = \"datetime\" === l;\n        b.positiveValuesOnly = b.isLog && !b.allowNegativeLog;\n        b.isLinked = v(f.linkedTo);\n        b.ticks = {};\n        b.labelEdge = [];\n        b.minorTicks = {};\n        b.plotLinesAndBands = [];\n        b.alternateBands = {};\n        b.len = 0;\n        b.minRange = b.userMinRange = f.minRange || f.maxZoom;\n        b.range = f.range;\n        b.offset = f.offset || 0;\n        b.stacks = {};\n        b.oldStacks = {};\n        b.stacksTouched = 0;\n        b.max = null;\n        b.min = null;\n        b.crosshair = F(f.crosshair, k(a.options.tooltip.crosshairs)[e ? 0 : 1], !1);\n        q = b.options.events;\n        -1 === a.axes.indexOf(b) && (e ? a.axes.splice(a.xAxis.length, 0, b) : a.axes.push(b), a[b.coll].push(b));\n        b.series = b.series || [];\n        a.inverted && !b.isZAxis && e && void 0 === b.reversed && (b.reversed = !0);\n        H(q, function (a, e) {\n          y(b, e, a);\n        });\n        b.lin2log = f.linearToLogConverter || b.lin2log;\n        b.isLog && (b.val2lin = b.log2lin, b.lin2val = b.lin2log);\n        d(this, \"afterInit\");\n      },\n      setOptions: function setOptions(a) {\n        this.options = x(this.defaultOptions, \"yAxis\" === this.coll && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], x(u[this.coll], a));\n        d(this, \"afterSetOptions\", {\n          userOptions: a\n        });\n      },\n      defaultLabelFormatter: function defaultLabelFormatter() {\n        var e = this.axis,\n            q = this.value,\n            b = e.chart.time,\n            f = e.categories,\n            l = this.dateTimeLabelFormat,\n            k = u.lang,\n            d = k.numericSymbols,\n            k = k.numericSymbolMagnitude || 1E3,\n            g = d && d.length,\n            c,\n            p = e.options.labels.format,\n            e = e.isLog ? Math.abs(q) : e.tickInterval;\n        if (p) c = m(p, this, b);else if (f) c = q;else if (l) c = b.dateFormat(l, q);else if (g && 1E3 <= e) for (; g-- && void 0 === c;) {\n          b = Math.pow(k, g + 1), e >= b && 0 === 10 * q % b && null !== d[g] && 0 !== q && (c = a.numberFormat(q / b, -1) + d[g]);\n        }\n        void 0 === c && (c = 1E4 <= Math.abs(q) ? a.numberFormat(q, -1) : a.numberFormat(q, -1, void 0, \"\"));\n        return c;\n      },\n      getSeriesExtremes: function getSeriesExtremes() {\n        var a = this,\n            q = a.chart;\n        d(this, \"getSeriesExtremes\", null, function () {\n          a.hasVisibleSeries = !1;\n          a.dataMin = a.dataMax = a.threshold = null;\n          a.softThreshold = !a.isXAxis;\n          a.buildStacks && a.buildStacks();\n          a.series.forEach(function (e) {\n            if (e.visible || !q.options.chart.ignoreHiddenSeries) {\n              var b = e.options,\n                  f = b.threshold,\n                  k;\n              a.hasVisibleSeries = !0;\n              a.positiveValuesOnly && 0 >= f && (f = null);\n              if (a.isXAxis) b = e.xData, b.length && (e = h(b), k = E(b), l(e) || e instanceof Date || (b = b.filter(l), e = h(b), k = E(b)), b.length && (a.dataMin = Math.min(F(a.dataMin, b[0], e), e), a.dataMax = Math.max(F(a.dataMax, b[0], k), k)));else if (e.getExtremes(), k = e.dataMax, e = e.dataMin, v(e) && v(k) && (a.dataMin = Math.min(F(a.dataMin, e), e), a.dataMax = Math.max(F(a.dataMax, k), k)), v(f) && (a.threshold = f), !b.softThreshold || a.positiveValuesOnly) a.softThreshold = !1;\n            }\n          });\n        });\n        d(this, \"afterGetSeriesExtremes\");\n      },\n      translate: function translate(a, q, b, f, k, d) {\n        var e = this.linkedParent || this,\n            c = 1,\n            g = 0,\n            p = f ? e.oldTransA : e.transA;\n        f = f ? e.oldMin : e.min;\n        var A = e.minPixelPadding;\n        k = (e.isOrdinal || e.isBroken || e.isLog && k) && e.lin2val;\n        p || (p = e.transA);\n        b && (c *= -1, g = e.len);\n        e.reversed && (c *= -1, g -= c * (e.sector || e.len));\n        q ? (a = (a * c + g - A) / p + f, k && (a = e.lin2val(a))) : (k && (a = e.val2lin(a)), a = l(f) ? c * (a - f) * p + g + c * A + (l(d) ? p * d : 0) : void 0);\n        return a;\n      },\n      toPixels: function toPixels(a, q) {\n        return this.translate(a, !1, !this.horiz, null, !0) + (q ? 0 : this.pos);\n      },\n      toValue: function toValue(a, q) {\n        return this.translate(a - (q ? 0 : this.pos), !0, !this.horiz, null, !0);\n      },\n      getPlotLinePath: function getPlotLinePath(a, q, b, f, k) {\n        var e = this.chart,\n            d = this.left,\n            c = this.top,\n            g,\n            p,\n            A = b && e.oldChartHeight || e.chartHeight,\n            t = b && e.oldChartWidth || e.chartWidth,\n            m;\n        g = this.transB;\n\n        var x = function x(a, e, q) {\n          if (\"pass\" !== f && a < e || a > q) f ? a = Math.min(Math.max(e, a), q) : m = !0;\n          return a;\n        };\n\n        k = F(k, this.translate(a, null, null, b));\n        k = Math.min(Math.max(-1E5, k), 1E5);\n        a = b = Math.round(k + g);\n        g = p = Math.round(A - k - g);\n        l(k) ? this.horiz ? (g = c, p = A - this.bottom, a = b = x(a, d, d + this.width)) : (a = d, b = t - this.right, g = p = x(g, c, c + this.height)) : (m = !0, f = !1);\n        return m && !f ? null : e.renderer.crispLine([\"M\", a, g, \"L\", b, p], q || 1);\n      },\n      getLinearTickPositions: function getLinearTickPositions(a, q, b) {\n        var e,\n            f = r(Math.floor(q / a) * a);\n        b = r(Math.ceil(b / a) * a);\n        var k = [],\n            d;\n        r(f + a) === f && (d = 20);\n        if (this.single) return [q];\n\n        for (q = f; q <= b;) {\n          k.push(q);\n          q = r(q + a, d);\n          if (q === e) break;\n          e = q;\n        }\n\n        return k;\n      },\n      getMinorTickInterval: function getMinorTickInterval() {\n        var a = this.options;\n        return !0 === a.minorTicks ? F(a.minorTickInterval, \"auto\") : !1 === a.minorTicks ? null : a.minorTickInterval;\n      },\n      getMinorTickPositions: function getMinorTickPositions() {\n        var a = this,\n            q = a.options,\n            b = a.tickPositions,\n            f = a.minorTickInterval,\n            k = [],\n            d = a.pointRangePadding || 0,\n            l = a.min - d,\n            d = a.max + d,\n            g = d - l;\n        if (g && g / f < a.len / 3) if (a.isLog) this.paddedTicks.forEach(function (e, q, b) {\n          q && k.push.apply(k, a.getLogTickPositions(f, b[q - 1], b[q], !0));\n        });else if (a.isDatetimeAxis && \"auto\" === this.getMinorTickInterval()) k = k.concat(a.getTimeTicks(a.normalizeTimeTickInterval(f), l, d, q.startOfWeek));else for (q = l + (b[0] - l) % f; q <= d && q !== k[0]; q += f) {\n          k.push(q);\n        }\n        0 !== k.length && a.trimTicks(k);\n        return k;\n      },\n      adjustForMinRange: function adjustForMinRange() {\n        var a = this.options,\n            q = this.min,\n            b = this.max,\n            f,\n            k,\n            d,\n            l,\n            g,\n            c,\n            p,\n            A;\n        this.isXAxis && void 0 === this.minRange && !this.isLog && (v(a.min) || v(a.max) ? this.minRange = null : (this.series.forEach(function (a) {\n          c = a.xData;\n\n          for (l = p = a.xIncrement ? 1 : c.length - 1; 0 < l; l--) {\n            if (g = c[l] - c[l - 1], void 0 === d || g < d) d = g;\n          }\n        }), this.minRange = Math.min(5 * d, this.dataMax - this.dataMin)));\n        b - q < this.minRange && (k = this.dataMax - this.dataMin >= this.minRange, A = this.minRange, f = (A - b + q) / 2, f = [q - f, F(a.min, q - f)], k && (f[2] = this.isLog ? this.log2lin(this.dataMin) : this.dataMin), q = E(f), b = [q + A, F(a.max, q + A)], k && (b[2] = this.isLog ? this.log2lin(this.dataMax) : this.dataMax), b = h(b), b - q < A && (f[0] = b - A, f[1] = F(a.min, b - A), q = E(f)));\n        this.min = q;\n        this.max = b;\n      },\n      getClosest: function getClosest() {\n        var a;\n        this.categories ? a = 1 : this.series.forEach(function (e) {\n          var q = e.closestPointRange,\n              b = e.visible || !e.chart.options.chart.ignoreHiddenSeries;\n          !e.noSharedTooltip && v(q) && b && (a = v(a) ? Math.min(a, q) : q);\n        });\n        return a;\n      },\n      nameToX: function nameToX(a) {\n        var e = b(this.categories),\n            f = e ? this.categories : this.names,\n            k = a.options.x,\n            d;\n        a.series.requireSorting = !1;\n        v(k) || (k = !1 === this.options.uniqueNames ? a.series.autoIncrement() : e ? f.indexOf(a.name) : F(f.keys[a.name], -1));\n        -1 === k ? e || (d = f.length) : d = k;\n        void 0 !== d && (this.names[d] = a.name, this.names.keys[a.name] = d);\n        return d;\n      },\n      updateNames: function updateNames() {\n        var a = this,\n            q = this.names;\n        0 < q.length && (Object.keys(q.keys).forEach(function (a) {\n          delete q.keys[a];\n        }), q.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (e) {\n          e.xIncrement = null;\n          if (!e.points || e.isDirtyData) a.max = Math.max(a.max, e.xData.length - 1), e.processData(), e.generatePoints();\n          e.data.forEach(function (q, b) {\n            var f;\n            q && q.options && void 0 !== q.name && (f = a.nameToX(q), void 0 !== f && f !== q.x && (q.x = f, e.xData[b] = f));\n          });\n        }));\n      },\n      setAxisTranslation: function setAxisTranslation(a) {\n        var e = this,\n            b = e.max - e.min,\n            k = e.axisPointRange || 0,\n            l,\n            g = 0,\n            c = 0,\n            p = e.linkedParent,\n            A = !!e.categories,\n            t = e.transA,\n            m = e.isXAxis;\n        if (m || A || k) l = e.getClosest(), p ? (g = p.minPointOffset, c = p.pointRangePadding) : e.series.forEach(function (a) {\n          var b = A ? 1 : m ? F(a.options.pointRange, l, 0) : e.axisPointRange || 0;\n          a = a.options.pointPlacement;\n          k = Math.max(k, b);\n          e.single || (g = Math.max(g, f(a) ? 0 : b / 2), c = Math.max(c, \"on\" === a ? 0 : b));\n        }), p = e.ordinalSlope && l ? e.ordinalSlope / l : 1, e.minPointOffset = g *= p, e.pointRangePadding = c *= p, e.pointRange = Math.min(k, b), m && (e.closestPointRange = l);\n        a && (e.oldTransA = t);\n        e.translationSlope = e.transA = t = e.staticScale || e.len / (b + c || 1);\n        e.transB = e.horiz ? e.left : e.bottom;\n        e.minPixelPadding = t * g;\n        d(this, \"afterSetAxisTranslation\");\n      },\n      minFromRange: function minFromRange() {\n        return this.max - this.range;\n      },\n      setTickInterval: function setTickInterval(e) {\n        var b = this,\n            f = b.chart,\n            k = b.options,\n            g = b.isLog,\n            c = b.isDatetimeAxis,\n            A = b.isXAxis,\n            m = b.isLinked,\n            x = k.maxPadding,\n            n = k.minPadding,\n            D,\n            h = k.tickInterval,\n            B = k.tickPixelInterval,\n            z = b.categories,\n            H = l(b.threshold) ? b.threshold : null,\n            w = b.softThreshold,\n            u,\n            y,\n            E;\n        c || z || m || this.getTickAmount();\n        y = F(b.userMin, k.min);\n        E = F(b.userMax, k.max);\n        m ? (b.linkedParent = f[b.coll][k.linkedTo], D = b.linkedParent.getExtremes(), b.min = F(D.min, D.dataMin), b.max = F(D.max, D.dataMax), k.type !== b.linkedParent.options.type && a.error(11, 1, f)) : (!w && v(H) && (b.dataMin >= H ? (D = H, n = 0) : b.dataMax <= H && (u = H, x = 0)), b.min = F(y, D, b.dataMin), b.max = F(E, u, b.dataMax));\n        g && (b.positiveValuesOnly && !e && 0 >= Math.min(b.min, F(b.dataMin, b.min)) && a.error(10, 1, f), b.min = r(b.log2lin(b.min), 15), b.max = r(b.log2lin(b.max), 15));\n        b.range && v(b.max) && (b.userMin = b.min = y = Math.max(b.dataMin, b.minFromRange()), b.userMax = E = b.max, b.range = null);\n        d(b, \"foundExtremes\");\n        b.beforePadding && b.beforePadding();\n        b.adjustForMinRange();\n        !(z || b.axisPointRange || b.usePercentage || m) && v(b.min) && v(b.max) && (f = b.max - b.min) && (!v(y) && n && (b.min -= f * n), !v(E) && x && (b.max += f * x));\n        l(k.softMin) && !l(b.userMin) && (b.min = Math.min(b.min, k.softMin));\n        l(k.softMax) && !l(b.userMax) && (b.max = Math.max(b.max, k.softMax));\n        l(k.floor) && (b.min = Math.min(Math.max(b.min, k.floor), Number.MAX_VALUE));\n        l(k.ceiling) && (b.max = Math.max(Math.min(b.max, k.ceiling), F(b.userMax, -Number.MAX_VALUE)));\n        w && v(b.dataMin) && (H = H || 0, !v(y) && b.min < H && b.dataMin >= H ? b.min = H : !v(E) && b.max > H && b.dataMax <= H && (b.max = H));\n        b.tickInterval = b.min === b.max || void 0 === b.min || void 0 === b.max ? 1 : m && !h && B === b.linkedParent.options.tickPixelInterval ? h = b.linkedParent.tickInterval : F(h, this.tickAmount ? (b.max - b.min) / Math.max(this.tickAmount - 1, 1) : void 0, z ? 1 : (b.max - b.min) * B / Math.max(b.len, B));\n        A && !e && b.series.forEach(function (a) {\n          a.processData(b.min !== b.oldMin || b.max !== b.oldMax);\n        });\n        b.setAxisTranslation(!0);\n        b.beforeSetTickPositions && b.beforeSetTickPositions();\n        b.postProcessTickInterval && (b.tickInterval = b.postProcessTickInterval(b.tickInterval));\n        b.pointRange && !h && (b.tickInterval = Math.max(b.pointRange, b.tickInterval));\n        e = F(k.minTickInterval, b.isDatetimeAxis && b.closestPointRange);\n        !h && b.tickInterval < e && (b.tickInterval = e);\n        c || g || h || (b.tickInterval = t(b.tickInterval, null, p(b.tickInterval), F(k.allowDecimals, !(.5 < b.tickInterval && 5 > b.tickInterval && 1E3 < b.max && 9999 > b.max)), !!this.tickAmount));\n        this.tickAmount || (b.tickInterval = b.unsquish());\n        this.setTickPositions();\n      },\n      setTickPositions: function setTickPositions() {\n        var e = this.options,\n            b,\n            f = e.tickPositions;\n        b = this.getMinorTickInterval();\n        var k = e.tickPositioner,\n            l = e.startOnTick,\n            g = e.endOnTick;\n        this.tickmarkOffset = this.categories && \"between\" === e.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;\n        this.minorTickInterval = \"auto\" === b && this.tickInterval ? this.tickInterval / 5 : b;\n        this.single = this.min === this.max && v(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== e.allowDecimals);\n        this.tickPositions = b = f && f.slice();\n        !b && (!this.ordinalPositions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200) ? (b = [this.min, this.max], a.error(19, !1, this.chart)) : b = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, e.units), this.min, this.max, e.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), b.length > this.len && (b = [b[0], b.pop()], b[0] === b[1] && (b.length = 1)), this.tickPositions = b, k && (k = k.apply(this, [this.min, this.max]))) && (this.tickPositions = b = k);\n        this.paddedTicks = b.slice(0);\n        this.trimTicks(b, l, g);\n        this.isLinked || (this.single && 2 > b.length && (this.min -= .5, this.max += .5), f || k || this.adjustTickAmount());\n        d(this, \"afterSetTickPositions\");\n      },\n      trimTicks: function trimTicks(a, b, f) {\n        var e = a[0],\n            k = a[a.length - 1],\n            q = this.minPointOffset || 0;\n\n        if (!this.isLinked) {\n          if (b && -Infinity !== e) this.min = e;else for (; this.min - q > a[0];) {\n            a.shift();\n          }\n          if (f) this.max = k;else for (; this.max + q < a[a.length - 1];) {\n            a.pop();\n          }\n          0 === a.length && v(e) && !this.options.tickPositions && a.push((k + e) / 2);\n        }\n      },\n      alignToOthers: function alignToOthers() {\n        var a = {},\n            b,\n            f = this.options;\n        !1 === this.chart.options.chart.alignTicks || !1 === f.alignTicks || !1 === f.startOnTick || !1 === f.endOnTick || this.isLog || this.chart[this.coll].forEach(function (e) {\n          var f = e.options,\n              f = [e.horiz ? f.left : f.top, f.width, f.height, f.pane].join();\n          e.series.length && (a[f] ? b = !0 : a[f] = 1);\n        });\n        return b;\n      },\n      getTickAmount: function getTickAmount() {\n        var a = this.options,\n            b = a.tickAmount,\n            f = a.tickPixelInterval;\n        !v(a.tickInterval) && this.len < f && !this.isRadial && !this.isLog && a.startOnTick && a.endOnTick && (b = 2);\n        !b && this.alignToOthers() && (b = Math.ceil(this.len / f) + 1);\n        4 > b && (this.finalTickAmt = b, b = 5);\n        this.tickAmount = b;\n      },\n      adjustTickAmount: function adjustTickAmount() {\n        var a = this.tickInterval,\n            b = this.tickPositions,\n            f = this.tickAmount,\n            k = this.finalTickAmt,\n            d = b && b.length,\n            l = F(this.threshold, this.softThreshold ? 0 : null);\n\n        if (this.hasData()) {\n          if (d < f) {\n            for (; b.length < f;) {\n              b.length % 2 || this.min === l ? b.push(r(b[b.length - 1] + a)) : b.unshift(r(b[0] - a));\n            }\n\n            this.transA *= (d - 1) / (f - 1);\n            this.min = b[0];\n            this.max = b[b.length - 1];\n          } else d > f && (this.tickInterval *= 2, this.setTickPositions());\n\n          if (v(k)) {\n            for (a = f = b.length; a--;) {\n              (3 === k && 1 === a % 2 || 2 >= k && 0 < a && a < f - 1) && b.splice(a, 1);\n            }\n\n            this.finalTickAmt = void 0;\n          }\n        }\n      },\n      setScale: function setScale() {\n        var a, b;\n        this.oldMin = this.min;\n        this.oldMax = this.max;\n        this.oldAxisLength = this.len;\n        this.setAxisSize();\n        b = this.len !== this.oldAxisLength;\n        this.series.forEach(function (e) {\n          if (e.isDirtyData || e.isDirty || e.xAxis.isDirty) a = !0;\n        });\n        b || a || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.resetStacks && this.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = b || this.min !== this.oldMin || this.max !== this.oldMax)) : this.cleanStacks && this.cleanStacks();\n        d(this, \"afterSetScale\");\n      },\n      setExtremes: function setExtremes(a, b, f, k, l) {\n        var e = this,\n            q = e.chart;\n        f = F(f, !0);\n        e.series.forEach(function (a) {\n          delete a.kdTree;\n        });\n        l = g(l, {\n          min: a,\n          max: b\n        });\n        d(e, \"setExtremes\", l, function () {\n          e.userMin = a;\n          e.userMax = b;\n          e.eventArgs = l;\n          f && q.redraw(k);\n        });\n      },\n      zoom: function zoom(a, b) {\n        var e = this.dataMin,\n            f = this.dataMax,\n            k = this.options,\n            d = Math.min(e, F(k.min, e)),\n            k = Math.max(f, F(k.max, f));\n        if (a !== this.min || b !== this.max) this.allowZoomOutside || (v(e) && (a < d && (a = d), a > k && (a = k)), v(f) && (b < d && (b = d), b > k && (b = k))), this.displayBtn = void 0 !== a || void 0 !== b, this.setExtremes(a, b, !1, void 0, {\n          trigger: \"zoom\"\n        });\n        return !0;\n      },\n      setAxisSize: function setAxisSize() {\n        var e = this.chart,\n            b = this.options,\n            f = b.offsets || [0, 0, 0, 0],\n            k = this.horiz,\n            d = this.width = Math.round(a.relativeLength(F(b.width, e.plotWidth - f[3] + f[1]), e.plotWidth)),\n            l = this.height = Math.round(a.relativeLength(F(b.height, e.plotHeight - f[0] + f[2]), e.plotHeight)),\n            g = this.top = Math.round(a.relativeLength(F(b.top, e.plotTop + f[0]), e.plotHeight, e.plotTop)),\n            b = this.left = Math.round(a.relativeLength(F(b.left, e.plotLeft + f[3]), e.plotWidth, e.plotLeft));\n        this.bottom = e.chartHeight - l - g;\n        this.right = e.chartWidth - d - b;\n        this.len = Math.max(k ? d : l, 0);\n        this.pos = k ? b : g;\n      },\n      getExtremes: function getExtremes() {\n        var a = this.isLog;\n        return {\n          min: a ? r(this.lin2log(this.min)) : this.min,\n          max: a ? r(this.lin2log(this.max)) : this.max,\n          dataMin: this.dataMin,\n          dataMax: this.dataMax,\n          userMin: this.userMin,\n          userMax: this.userMax\n        };\n      },\n      getThreshold: function getThreshold(a) {\n        var e = this.isLog,\n            b = e ? this.lin2log(this.min) : this.min,\n            e = e ? this.lin2log(this.max) : this.max;\n        null === a || -Infinity === a ? a = b : Infinity === a ? a = e : b > a ? a = b : e < a && (a = e);\n        return this.translate(a, 0, 1, 0, 1);\n      },\n      autoLabelAlign: function autoLabelAlign(a) {\n        a = (F(a, 0) - 90 * this.side + 720) % 360;\n        return 15 < a && 165 > a ? \"right\" : 195 < a && 345 > a ? \"left\" : \"center\";\n      },\n      tickSize: function tickSize(a) {\n        var e = this.options,\n            b = e[a + \"Length\"],\n            f = F(e[a + \"Width\"], \"tick\" === a && this.isXAxis ? 1 : 0);\n        if (f && b) return \"inside\" === e[a + \"Position\"] && (b = -b), [b, f];\n      },\n      labelMetrics: function labelMetrics() {\n        var a = this.tickPositions && this.tickPositions[0] || 0;\n        return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[a] && this.ticks[a].label);\n      },\n      unsquish: function unsquish() {\n        var a = this.options.labels,\n            b = this.horiz,\n            f = this.tickInterval,\n            k = f,\n            d = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / f),\n            l,\n            g = a.rotation,\n            c = this.labelMetrics(),\n            p,\n            A = Number.MAX_VALUE,\n            t,\n            m = function m(a) {\n          a /= d || 1;\n          a = 1 < a ? Math.ceil(a) : 1;\n          return r(a * f);\n        };\n\n        b ? (t = !a.staggerLines && !a.step && (v(g) ? [g] : d < F(a.autoRotationLimit, 80) && a.autoRotation)) && t.forEach(function (a) {\n          var b;\n          if (a === g || a && -90 <= a && 90 >= a) p = m(Math.abs(c.h / Math.sin(w * a))), b = p + Math.abs(a / 360), b < A && (A = b, l = a, k = p);\n        }) : a.step || (k = m(c.h));\n        this.autoRotation = t;\n        this.labelRotation = F(l, g);\n        return k;\n      },\n      getSlotWidth: function getSlotWidth(a) {\n        var b = this.chart,\n            e = this.horiz,\n            f = this.options.labels,\n            k = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n            d = b.margin[3];\n        return a && a.slotWidth || e && 2 > (f.step || 0) && !f.rotation && (this.staggerLines || 1) * this.len / k || !e && (f.style && parseInt(f.style.width, 10) || d && d - b.spacing[3] || .33 * b.chartWidth);\n      },\n      renderUnsquish: function renderUnsquish() {\n        var a = this.chart,\n            b = a.renderer,\n            k = this.tickPositions,\n            d = this.ticks,\n            l = this.options.labels,\n            g = l && l.style || {},\n            c = this.horiz,\n            p = this.getSlotWidth(),\n            A = Math.max(1, Math.round(p - 2 * (l.padding || 5))),\n            t = {},\n            m = this.labelMetrics(),\n            x = l.style && l.style.textOverflow,\n            n,\n            D,\n            h = 0,\n            B;\n        f(l.rotation) || (t.rotation = l.rotation || 0);\n        k.forEach(function (a) {\n          (a = d[a]) && a.label && a.label.textPxLength > h && (h = a.label.textPxLength);\n        });\n        this.maxLabelLength = h;\n        if (this.autoRotation) h > A && h > m.h ? t.rotation = this.labelRotation : this.labelRotation = 0;else if (p && (n = A, !x)) for (D = \"clip\", A = k.length; !c && A--;) {\n          if (B = k[A], B = d[B].label) B.styles && \"ellipsis\" === B.styles.textOverflow ? B.css({\n            textOverflow: \"clip\"\n          }) : B.textPxLength > p && B.css({\n            width: p + \"px\"\n          }), B.getBBox().height > this.len / k.length - (m.h - m.f) && (B.specificTextOverflow = \"ellipsis\");\n        }\n        t.rotation && (n = h > .5 * a.chartHeight ? .33 * a.chartHeight : h, x || (D = \"ellipsis\"));\n        if (this.labelAlign = l.align || this.autoLabelAlign(this.labelRotation)) t.align = this.labelAlign;\n        k.forEach(function (a) {\n          var b = (a = d[a]) && a.label,\n              e = g.width,\n              f = {};\n          b && (b.attr(t), a.shortenLabel ? a.shortenLabel() : n && !e && \"nowrap\" !== g.whiteSpace && (n < b.textPxLength || \"SPAN\" === b.element.tagName) ? (f.width = n, x || (f.textOverflow = b.specificTextOverflow || D), b.css(f)) : b.styles && b.styles.width && !f.width && !e && b.css({\n            width: null\n          }), delete b.specificTextOverflow, a.rotation = t.rotation);\n        }, this);\n        this.tickRotCorr = b.rotCorr(m.b, this.labelRotation || 0, 0 !== this.side);\n      },\n      hasData: function hasData() {\n        return this.hasVisibleSeries || v(this.min) && v(this.max) && this.tickPositions && 0 < this.tickPositions.length;\n      },\n      addTitle: function addTitle(a) {\n        var b = this.chart.renderer,\n            e = this.horiz,\n            f = this.opposite,\n            k = this.options.title,\n            d,\n            l = this.chart.styledMode;\n        this.axisTitle || ((d = k.textAlign) || (d = (e ? {\n          low: \"left\",\n          middle: \"center\",\n          high: \"right\"\n        } : {\n          low: f ? \"right\" : \"left\",\n          middle: \"center\",\n          high: f ? \"left\" : \"right\"\n        })[k.align]), this.axisTitle = b.text(k.text, 0, 0, k.useHTML).attr({\n          zIndex: 7,\n          rotation: k.rotation || 0,\n          align: d\n        }).addClass(\"highcharts-axis-title\"), l || this.axisTitle.css(x(k.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);\n        l || k.style.width || this.isRadial || this.axisTitle.css({\n          width: this.len\n        });\n        this.axisTitle[a ? \"show\" : \"hide\"](!0);\n      },\n      generateTick: function generateTick(a) {\n        var b = this.ticks;\n        b[a] ? b[a].addLabel() : b[a] = new D(this, a);\n      },\n      getOffset: function getOffset() {\n        var a = this,\n            b = a.chart,\n            f = b.renderer,\n            k = a.options,\n            l = a.tickPositions,\n            g = a.ticks,\n            c = a.horiz,\n            p = a.side,\n            A = b.inverted && !a.isZAxis ? [1, 0, 3, 2][p] : p,\n            t,\n            m,\n            x = 0,\n            n,\n            D = 0,\n            h = k.title,\n            B = k.labels,\n            z = 0,\n            r = b.axisOffset,\n            b = b.clipOffset,\n            w = [-1, 1, 1, -1][p],\n            u = k.className,\n            y = a.axisParent;\n        t = a.hasData();\n        a.showAxis = m = t || F(k.showEmpty, !0);\n        a.staggerLines = a.horiz && B.staggerLines;\n        a.axisGroup || (a.gridGroup = f.g(\"grid\").attr({\n          zIndex: k.gridZIndex || 1\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \"-grid \" + (u || \"\")).add(y), a.axisGroup = f.g(\"axis\").attr({\n          zIndex: k.zIndex || 2\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \" \" + (u || \"\")).add(y), a.labelGroup = f.g(\"axis-labels\").attr({\n          zIndex: B.zIndex || 7\n        }).addClass(\"highcharts-\" + a.coll.toLowerCase() + \"-labels \" + (u || \"\")).add(y));\n        t || a.isLinked ? (l.forEach(function (b, e) {\n          a.generateTick(b, e);\n        }), a.renderUnsquish(), a.reserveSpaceDefault = 0 === p || 2 === p || {\n          1: \"left\",\n          3: \"right\"\n        }[p] === a.labelAlign, F(B.reserveSpace, \"center\" === a.labelAlign ? !0 : null, a.reserveSpaceDefault) && l.forEach(function (a) {\n          z = Math.max(g[a].getLabelSize(), z);\n        }), a.staggerLines && (z *= a.staggerLines), a.labelOffset = z * (a.opposite ? -1 : 1)) : H(g, function (a, b) {\n          a.destroy();\n          delete g[b];\n        });\n        h && h.text && !1 !== h.enabled && (a.addTitle(m), m && !1 !== h.reserveSpace && (a.titleOffset = x = a.axisTitle.getBBox()[c ? \"height\" : \"width\"], n = h.offset, D = v(n) ? 0 : F(h.margin, c ? 5 : 10)));\n        a.renderLine();\n        a.offset = w * F(k.offset, r[p]);\n        a.tickRotCorr = a.tickRotCorr || {\n          x: 0,\n          y: 0\n        };\n        f = 0 === p ? -a.labelMetrics().h : 2 === p ? a.tickRotCorr.y : 0;\n        D = Math.abs(z) + D;\n        z && (D = D - f + w * (c ? F(B.y, a.tickRotCorr.y + 8 * w) : B.x));\n        a.axisTitleMargin = F(n, D);\n        a.getMaxLabelDimensions && (a.maxLabelDimensions = a.getMaxLabelDimensions(g, l));\n        c = this.tickSize(\"tick\");\n        r[p] = Math.max(r[p], a.axisTitleMargin + x + w * a.offset, D, t && l.length && c ? c[0] + w * a.offset : 0);\n        k = k.offset ? 0 : 2 * Math.floor(a.axisLine.strokeWidth() / 2);\n        b[A] = Math.max(b[A], k);\n        d(this, \"afterGetOffset\");\n      },\n      getLinePath: function getLinePath(a) {\n        var b = this.chart,\n            e = this.opposite,\n            f = this.offset,\n            k = this.horiz,\n            d = this.left + (e ? this.width : 0) + f,\n            f = b.chartHeight - this.bottom - (e ? this.height : 0) + f;\n        e && (a *= -1);\n        return b.renderer.crispLine([\"M\", k ? this.left : d, k ? f : this.top, \"L\", k ? b.chartWidth - this.right : d, k ? f : b.chartHeight - this.bottom], a);\n      },\n      renderLine: function renderLine() {\n        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({\n          stroke: this.options.lineColor,\n          \"stroke-width\": this.options.lineWidth,\n          zIndex: 7\n        }));\n      },\n      getTitlePosition: function getTitlePosition() {\n        var a = this.horiz,\n            b = this.left,\n            f = this.top,\n            k = this.len,\n            d = this.options.title,\n            l = a ? b : f,\n            g = this.opposite,\n            c = this.offset,\n            p = d.x || 0,\n            A = d.y || 0,\n            t = this.axisTitle,\n            m = this.chart.renderer.fontMetrics(d.style && d.style.fontSize, t),\n            t = Math.max(t.getBBox(null, 0).height - m.h - 1, 0),\n            k = {\n          low: l + (a ? 0 : k),\n          middle: l + k / 2,\n          high: l + (a ? k : 0)\n        }[d.align],\n            b = (a ? f + this.height : b) + (a ? 1 : -1) * (g ? -1 : 1) * this.axisTitleMargin + [-t, t, m.f, -t][this.side];\n        return {\n          x: a ? k + p : b + (g ? this.width : 0) + c + p,\n          y: a ? b + A - (g ? this.height : 0) + c : k + A\n        };\n      },\n      renderMinorTick: function renderMinorTick(a) {\n        var b = this.chart.hasRendered && l(this.oldMin),\n            e = this.minorTicks;\n        e[a] || (e[a] = new D(this, a, \"minor\"));\n        b && e[a].isNew && e[a].render(null, !0);\n        e[a].render(null, !1, 1);\n      },\n      renderTick: function renderTick(a, b) {\n        var e = this.isLinked,\n            f = this.ticks,\n            k = this.chart.hasRendered && l(this.oldMin);\n        if (!e || a >= this.min && a <= this.max) f[a] || (f[a] = new D(this, a)), k && f[a].isNew && f[a].render(b, !0, -1), f[a].render(b);\n      },\n      render: function render() {\n        var b = this,\n            f = b.chart,\n            k = b.options,\n            g = b.isLog,\n            c = b.isLinked,\n            p = b.tickPositions,\n            t = b.axisTitle,\n            m = b.ticks,\n            x = b.minorTicks,\n            n = b.alternateBands,\n            h = k.stackLabels,\n            B = k.alternateGridColor,\n            z = b.tickmarkOffset,\n            F = b.axisLine,\n            r = b.showAxis,\n            w = G(f.renderer.globalAnimation),\n            u,\n            v;\n        b.labelEdge.length = 0;\n        b.overlap = !1;\n        [m, x, n].forEach(function (a) {\n          H(a, function (a) {\n            a.isActive = !1;\n          });\n        });\n        if (b.hasData() || c) b.minorTickInterval && !b.categories && b.getMinorTickPositions().forEach(function (a) {\n          b.renderMinorTick(a);\n        }), p.length && (p.forEach(function (a, e) {\n          b.renderTick(a, e);\n        }), z && (0 === b.min || b.single) && (m[-1] || (m[-1] = new D(b, -1, null, !0)), m[-1].render(-1))), B && p.forEach(function (e, k) {\n          v = void 0 !== p[k + 1] ? p[k + 1] + z : b.max - z;\n          0 === k % 2 && e < b.max && v <= b.max + (f.polar ? -z : z) && (n[e] || (n[e] = new a.PlotLineOrBand(b)), u = e + z, n[e].options = {\n            from: g ? b.lin2log(u) : u,\n            to: g ? b.lin2log(v) : v,\n            color: B\n          }, n[e].render(), n[e].isActive = !0);\n        }), b._addedPlotLB || ((k.plotLines || []).concat(k.plotBands || []).forEach(function (a) {\n          b.addPlotBandOrLine(a);\n        }), b._addedPlotLB = !0);\n        [m, x, n].forEach(function (a) {\n          var b,\n              e = [],\n              k = w.duration;\n          H(a, function (a, b) {\n            a.isActive || (a.render(b, !1, 0), a.isActive = !1, e.push(b));\n          });\n          A(function () {\n            for (b = e.length; b--;) {\n              a[e[b]] && !a[e[b]].isActive && (a[e[b]].destroy(), delete a[e[b]]);\n            }\n          }, a !== n && f.hasRendered && k ? k : 0);\n        });\n        F && (F[F.isPlaced ? \"animate\" : \"attr\"]({\n          d: this.getLinePath(F.strokeWidth())\n        }), F.isPlaced = !0, F[r ? \"show\" : \"hide\"](!0));\n        t && r && (k = b.getTitlePosition(), l(k.y) ? (t[t.isNew ? \"attr\" : \"animate\"](k), t.isNew = !1) : (t.attr(\"y\", -9999), t.isNew = !0));\n        h && h.enabled && b.renderStackTotals();\n        b.isDirty = !1;\n        d(this, \"afterRender\");\n      },\n      redraw: function redraw() {\n        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (a) {\n          a.render();\n        }));\n        this.series.forEach(function (a) {\n          a.isDirty = !0;\n        });\n      },\n      keepProps: \"extKey hcEvents names series userMax userMin\".split(\" \"),\n      destroy: function destroy(a) {\n        var b = this,\n            e = b.stacks,\n            f = b.plotLinesAndBands,\n            k;\n        d(this, \"destroy\", {\n          keepEvents: a\n        });\n        a || z(b);\n        H(e, function (a, b) {\n          n(a);\n          e[b] = null;\n        });\n        [b.ticks, b.minorTicks, b.alternateBands].forEach(function (a) {\n          n(a);\n        });\n        if (f) for (a = f.length; a--;) {\n          f[a].destroy();\n        }\n        \"stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar\".split(\" \").forEach(function (a) {\n          b[a] && (b[a] = b[a].destroy());\n        });\n\n        for (k in b.plotLinesAndBandsGroups) {\n          b.plotLinesAndBandsGroups[k] = b.plotLinesAndBandsGroups[k].destroy();\n        }\n\n        H(b, function (a, e) {\n          -1 === b.keepProps.indexOf(e) && delete b[e];\n        });\n      },\n      drawCrosshair: function drawCrosshair(a, b) {\n        var e,\n            f = this.crosshair,\n            k = F(f.snap, !0),\n            l,\n            g = this.cross;\n        d(this, \"drawCrosshair\", {\n          e: a,\n          point: b\n        });\n        a || (a = this.cross && this.cross.e);\n\n        if (this.crosshair && !1 !== (v(b) || !k)) {\n          k ? v(b) && (l = F(b.crosshairPos, this.isXAxis ? b.plotX : this.len - b.plotY)) : l = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos);\n          v(l) && (e = this.getPlotLinePath(b && (this.isXAxis ? b.x : F(b.stackY, b.y)), null, null, null, l) || null);\n\n          if (!v(e)) {\n            this.hideCrosshair();\n            return;\n          }\n\n          k = this.categories && !this.isRadial;\n          g || (this.cross = g = this.chart.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (k ? \"category \" : \"thin \") + f.className).attr({\n            zIndex: F(f.zIndex, 2)\n          }).add(), this.chart.styledMode || (g.attr({\n            stroke: f.color || (k ? c(\"#ccd6eb\").setOpacity(.25).get() : \"#cccccc\"),\n            \"stroke-width\": F(f.width, 1)\n          }).css({\n            \"pointer-events\": \"none\"\n          }), f.dashStyle && g.attr({\n            dashstyle: f.dashStyle\n          })));\n          g.show().attr({\n            d: e\n          });\n          k && !f.width && g.attr({\n            \"stroke-width\": this.transA\n          });\n          this.cross.e = a;\n        } else this.hideCrosshair();\n\n        d(this, \"afterDrawCrosshair\", {\n          e: a,\n          point: b\n        });\n      },\n      hideCrosshair: function hideCrosshair() {\n        this.cross && this.cross.hide();\n      }\n    });\n    return a.Axis = B;\n  }(J);\n\n  (function (a) {\n    var y = a.Axis,\n        G = a.getMagnitude,\n        E = a.normalizeTickInterval,\n        h = a.timeUnits;\n\n    y.prototype.getTimeTicks = function () {\n      return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n    };\n\n    y.prototype.normalizeTimeTickInterval = function (a, r) {\n      var c = r || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]];\n      r = c[c.length - 1];\n      var v = h[r[0]],\n          w = r[1],\n          n;\n\n      for (n = 0; n < c.length && !(r = c[n], v = h[r[0]], w = r[1], c[n + 1] && a <= (v * w[w.length - 1] + h[c[n + 1][0]]) / 2); n++) {\n        ;\n      }\n\n      v === h.year && a < 5 * v && (w = [1, 2, 5]);\n      a = E(a / v, w, \"year\" === r[0] ? Math.max(G(a / v), 1) : 1);\n      return {\n        unitRange: v,\n        count: a,\n        unitName: r[0]\n      };\n    };\n  })(J);\n\n  (function (a) {\n    var y = a.Axis,\n        G = a.getMagnitude,\n        E = a.normalizeTickInterval,\n        h = a.pick;\n\n    y.prototype.getLogTickPositions = function (a, r, u, v) {\n      var c = this.options,\n          n = this.len,\n          g = [];\n      v || (this._minorAutoInterval = null);\n      if (.5 <= a) a = Math.round(a), g = this.getLinearTickPositions(a, r, u);else if (.08 <= a) for (var n = Math.floor(r), d, m, p, b, l, c = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; n < u + 1 && !l; n++) {\n        for (m = c.length, d = 0; d < m && !l; d++) {\n          p = this.log2lin(this.lin2log(n) * c[d]), p > r && (!v || b <= u) && void 0 !== b && g.push(b), b > u && (l = !0), b = p;\n        }\n      } else r = this.lin2log(r), u = this.lin2log(u), a = v ? this.getMinorTickInterval() : c.tickInterval, a = h(\"auto\" === a ? null : a, this._minorAutoInterval, c.tickPixelInterval / (v ? 5 : 1) * (u - r) / ((v ? n / this.tickPositions.length : n) || 1)), a = E(a, null, G(a)), g = this.getLinearTickPositions(a, r, u).map(this.log2lin), v || (this._minorAutoInterval = a / 5);\n      v || (this.tickInterval = a);\n      return g;\n    };\n\n    y.prototype.log2lin = function (a) {\n      return Math.log(a) / Math.LN10;\n    };\n\n    y.prototype.lin2log = function (a) {\n      return Math.pow(10, a);\n    };\n  })(J);\n\n  (function (a, y) {\n    var G = a.arrayMax,\n        E = a.arrayMin,\n        h = a.defined,\n        c = a.destroyObjectProperties,\n        r = a.erase,\n        u = a.merge,\n        v = a.pick;\n\n    a.PlotLineOrBand = function (a, c) {\n      this.axis = a;\n      c && (this.options = c, this.id = c.id);\n    };\n\n    a.PlotLineOrBand.prototype = {\n      render: function render() {\n        a.fireEvent(this, \"render\");\n        var c = this,\n            n = c.axis,\n            g = n.horiz,\n            d = c.options,\n            m = d.label,\n            p = c.label,\n            b = d.to,\n            l = d.from,\n            f = d.value,\n            x = h(l) && h(b),\n            t = h(f),\n            H = c.svgElem,\n            F = !H,\n            z = [],\n            k = d.color,\n            A = v(d.zIndex, 0),\n            D = d.events,\n            z = {\n          \"class\": \"highcharts-plot-\" + (x ? \"band \" : \"line \") + (d.className || \"\")\n        },\n            B = {},\n            e = n.chart.renderer,\n            q = x ? \"bands\" : \"lines\";\n        n.isLog && (l = n.log2lin(l), b = n.log2lin(b), f = n.log2lin(f));\n        n.chart.styledMode || (t ? (z.stroke = k, z[\"stroke-width\"] = d.width, d.dashStyle && (z.dashstyle = d.dashStyle)) : x && (k && (z.fill = k), d.borderWidth && (z.stroke = d.borderColor, z[\"stroke-width\"] = d.borderWidth)));\n        B.zIndex = A;\n        q += \"-\" + A;\n        (k = n.plotLinesAndBandsGroups[q]) || (n.plotLinesAndBandsGroups[q] = k = e.g(\"plot-\" + q).attr(B).add());\n        F && (c.svgElem = H = e.path().attr(z).add(k));\n        if (t) z = n.getPlotLinePath(f, H.strokeWidth());else if (x) z = n.getPlotBandPath(l, b, d);else return;\n        F && z && z.length ? (H.attr({\n          d: z\n        }), D && a.objectEach(D, function (a, b) {\n          H.on(b, function (a) {\n            D[b].apply(c, [a]);\n          });\n        })) : H && (z ? (H.show(), H.animate({\n          d: z\n        })) : (H.hide(), p && (c.label = p = p.destroy())));\n        m && h(m.text) && z && z.length && 0 < n.width && 0 < n.height && !z.isFlat ? (m = u({\n          align: g && x && \"center\",\n          x: g ? !x && 4 : 10,\n          verticalAlign: !g && x && \"middle\",\n          y: g ? x ? 16 : 10 : x ? 6 : -4,\n          rotation: g && !x && 90\n        }, m), this.renderLabel(m, z, x, A)) : p && p.hide();\n        return c;\n      },\n      renderLabel: function renderLabel(a, c, g, d) {\n        var m = this.label,\n            p = this.axis.chart.renderer;\n        m || (m = {\n          align: a.textAlign || a.align,\n          rotation: a.rotation,\n          \"class\": \"highcharts-plot-\" + (g ? \"band\" : \"line\") + \"-label \" + (a.className || \"\")\n        }, m.zIndex = d, this.label = m = p.text(a.text, 0, 0, a.useHTML).attr(m).add(), this.axis.chart.styledMode || m.css(a.style));\n        d = c.xBounds || [c[1], c[4], g ? c[6] : c[1]];\n        c = c.yBounds || [c[2], c[5], g ? c[7] : c[2]];\n        g = E(d);\n        p = E(c);\n        m.align(a, !1, {\n          x: g,\n          y: p,\n          width: G(d) - g,\n          height: G(c) - p\n        });\n        m.show();\n      },\n      destroy: function destroy() {\n        r(this.axis.plotLinesAndBands, this);\n        delete this.axis;\n        c(this);\n      }\n    };\n    a.extend(y.prototype, {\n      getPlotBandPath: function getPlotBandPath(a, c) {\n        var g = this.getPlotLinePath(c, null, null, !0),\n            d = this.getPlotLinePath(a, null, null, !0),\n            m = [],\n            p = this.horiz,\n            b = 1,\n            l;\n        a = a < this.min && c < this.min || a > this.max && c > this.max;\n        if (d && g) for (a && (l = d.toString() === g.toString(), b = 0), a = 0; a < d.length; a += 6) {\n          p && g[a + 1] === d[a + 1] ? (g[a + 1] += b, g[a + 4] += b) : p || g[a + 2] !== d[a + 2] || (g[a + 2] += b, g[a + 5] += b), m.push(\"M\", d[a + 1], d[a + 2], \"L\", d[a + 4], d[a + 5], g[a + 4], g[a + 5], g[a + 1], g[a + 2], \"z\"), m.isFlat = l;\n        }\n        return m;\n      },\n      addPlotBand: function addPlotBand(a) {\n        return this.addPlotBandOrLine(a, \"plotBands\");\n      },\n      addPlotLine: function addPlotLine(a) {\n        return this.addPlotBandOrLine(a, \"plotLines\");\n      },\n      addPlotBandOrLine: function addPlotBandOrLine(c, n) {\n        var g = new a.PlotLineOrBand(this, c).render(),\n            d = this.userOptions;\n        g && (n && (d[n] = d[n] || [], d[n].push(c)), this.plotLinesAndBands.push(g));\n        return g;\n      },\n      removePlotBandOrLine: function removePlotBandOrLine(a) {\n        for (var c = this.plotLinesAndBands, g = this.options, d = this.userOptions, m = c.length; m--;) {\n          c[m].id === a && c[m].destroy();\n        }\n\n        [g.plotLines || [], d.plotLines || [], g.plotBands || [], d.plotBands || []].forEach(function (d) {\n          for (m = d.length; m--;) {\n            d[m].id === a && r(d, d[m]);\n          }\n        });\n      },\n      removePlotBand: function removePlotBand(a) {\n        this.removePlotBandOrLine(a);\n      },\n      removePlotLine: function removePlotLine(a) {\n        this.removePlotBandOrLine(a);\n      }\n    });\n  })(J, V);\n\n  (function (a) {\n    var y = a.doc,\n        G = a.extend,\n        E = a.format,\n        h = a.isNumber,\n        c = a.merge,\n        r = a.pick,\n        u = a.splat,\n        v = a.syncTimeout,\n        w = a.timeUnits;\n\n    a.Tooltip = function () {\n      this.init.apply(this, arguments);\n    };\n\n    a.Tooltip.prototype = {\n      init: function init(a, c) {\n        this.chart = a;\n        this.options = c;\n        this.crosshairs = [];\n        this.now = {\n          x: 0,\n          y: 0\n        };\n        this.isHidden = !0;\n        this.split = c.split && !a.inverted;\n        this.shared = c.shared || this.split;\n        this.outside = c.outside && !this.split;\n      },\n      cleanSplit: function cleanSplit(a) {\n        this.chart.series.forEach(function (c) {\n          var d = c && c.tt;\n          d && (!d.isActive || a ? c.tt = d.destroy() : d.isActive = !1);\n        });\n      },\n      applyFilter: function applyFilter() {\n        var a = this.chart;\n        a.renderer.definition({\n          tagName: \"filter\",\n          id: \"drop-shadow-\" + a.index,\n          opacity: .5,\n          children: [{\n            tagName: \"feGaussianBlur\",\n            \"in\": \"SourceAlpha\",\n            stdDeviation: 1\n          }, {\n            tagName: \"feOffset\",\n            dx: 1,\n            dy: 1\n          }, {\n            tagName: \"feComponentTransfer\",\n            children: [{\n              tagName: \"feFuncA\",\n              type: \"linear\",\n              slope: .3\n            }]\n          }, {\n            tagName: \"feMerge\",\n            children: [{\n              tagName: \"feMergeNode\"\n            }, {\n              tagName: \"feMergeNode\",\n              \"in\": \"SourceGraphic\"\n            }]\n          }]\n        });\n        a.renderer.definition({\n          tagName: \"style\",\n          textContent: \".highcharts-tooltip-\" + a.index + \"{filter:url(#drop-shadow-\" + a.index + \")}\"\n        });\n      },\n      getLabel: function getLabel() {\n        var c = this.chart.renderer,\n            g = this.chart.styledMode,\n            d = this.options,\n            m;\n        this.label || (this.outside && (this.container = m = a.doc.createElement(\"div\"), m.className = \"highcharts-tooltip-container\", a.css(m, {\n          position: \"absolute\",\n          top: \"1px\",\n          pointerEvents: d.style && d.style.pointerEvents\n        }), a.doc.body.appendChild(m), this.renderer = c = new a.Renderer(m, 0, 0)), this.split ? this.label = c.g(\"tooltip\") : (this.label = c.label(\"\", 0, 0, d.shape || \"callout\", null, null, d.useHTML, null, \"tooltip\").attr({\n          padding: d.padding,\n          r: d.borderRadius\n        }), g || this.label.attr({\n          fill: d.backgroundColor,\n          \"stroke-width\": d.borderWidth\n        }).css(d.style).shadow(d.shadow)), g && (this.applyFilter(), this.label.addClass(\"highcharts-tooltip-\" + this.chart.index)), this.outside && (this.label.attr({\n          x: this.distance,\n          y: this.distance\n        }), this.label.xSetter = function (a) {\n          m.style.left = a + \"px\";\n        }, this.label.ySetter = function (a) {\n          m.style.top = a + \"px\";\n        }), this.label.attr({\n          zIndex: 8\n        }).add());\n        return this.label;\n      },\n      update: function update(a) {\n        this.destroy();\n        c(!0, this.chart.options.tooltip.userOptions, a);\n        this.init(this.chart, c(!0, this.options, a));\n      },\n      destroy: function destroy() {\n        this.label && (this.label = this.label.destroy());\n        this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());\n        this.renderer && (this.renderer = this.renderer.destroy(), a.discardElement(this.container));\n        a.clearTimeout(this.hideTimer);\n        a.clearTimeout(this.tooltipTimeout);\n      },\n      move: function move(c, g, d, m) {\n        var p = this,\n            b = p.now,\n            l = !1 !== p.options.animation && !p.isHidden && (1 < Math.abs(c - b.x) || 1 < Math.abs(g - b.y)),\n            f = p.followPointer || 1 < p.len;\n        G(b, {\n          x: l ? (2 * b.x + c) / 3 : c,\n          y: l ? (b.y + g) / 2 : g,\n          anchorX: f ? void 0 : l ? (2 * b.anchorX + d) / 3 : d,\n          anchorY: f ? void 0 : l ? (b.anchorY + m) / 2 : m\n        });\n        p.getLabel().attr(b);\n        l && (a.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {\n          p && p.move(c, g, d, m);\n        }, 32));\n      },\n      hide: function hide(c) {\n        var g = this;\n        a.clearTimeout(this.hideTimer);\n        c = r(c, this.options.hideDelay, 500);\n        this.isHidden || (this.hideTimer = v(function () {\n          g.getLabel()[c ? \"fadeOut\" : \"hide\"]();\n          g.isHidden = !0;\n        }, c));\n      },\n      getAnchor: function getAnchor(a, c) {\n        var d = this.chart,\n            g = d.pointer,\n            p = d.inverted,\n            b = d.plotTop,\n            l = d.plotLeft,\n            f = 0,\n            x = 0,\n            t,\n            h;\n        a = u(a);\n        this.followPointer && c ? (void 0 === c.chartX && (c = g.normalize(c)), a = [c.chartX - d.plotLeft, c.chartY - b]) : a[0].tooltipPos ? a = a[0].tooltipPos : (a.forEach(function (a) {\n          t = a.series.yAxis;\n          h = a.series.xAxis;\n          f += a.plotX + (!p && h ? h.left - l : 0);\n          x += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!p && t ? t.top - b : 0);\n        }), f /= a.length, x /= a.length, a = [p ? d.plotWidth - x : f, this.shared && !p && 1 < a.length && c ? c.chartY - b : p ? d.plotHeight - f : x]);\n        return a.map(Math.round);\n      },\n      getPosition: function getPosition(a, c, d) {\n        var g = this.chart,\n            p = this.distance,\n            b = {},\n            l = g.inverted && d.h || 0,\n            f,\n            x = this.outside,\n            t = x ? y.documentElement.clientWidth - 2 * p : g.chartWidth,\n            h = x ? Math.max(y.body.scrollHeight, y.documentElement.scrollHeight, y.body.offsetHeight, y.documentElement.offsetHeight, y.documentElement.clientHeight) : g.chartHeight,\n            n = g.pointer.chartPosition,\n            z = [\"y\", h, c, (x ? n.top - p : 0) + d.plotY + g.plotTop, x ? 0 : g.plotTop, x ? h : g.plotTop + g.plotHeight],\n            k = [\"x\", t, a, (x ? n.left - p : 0) + d.plotX + g.plotLeft, x ? 0 : g.plotLeft, x ? t : g.plotLeft + g.plotWidth],\n            A = !this.followPointer && r(d.ttBelow, !g.inverted === !!d.negative),\n            D = function D(a, e, f, k, d, c) {\n          var g = f < k - p,\n              q = k + p + f < e,\n              t = k - p - f;\n          k += p;\n          if (A && q) b[a] = k;else if (!A && g) b[a] = t;else if (g) b[a] = Math.min(c - f, 0 > t - l ? t : t - l);else if (q) b[a] = Math.max(d, k + l + f > e ? k : k + l);else return !1;\n        },\n            B = function B(a, e, f, k) {\n          var d;\n          k < p || k > e - p ? d = !1 : b[a] = k < f / 2 ? 1 : k > e - f / 2 ? e - f - 2 : k - f / 2;\n          return d;\n        },\n            e = function e(a) {\n          var b = z;\n          z = k;\n          k = b;\n          f = a;\n        },\n            q = function q() {\n          !1 !== D.apply(0, z) ? !1 !== B.apply(0, k) || f || (e(!0), q()) : f ? b.x = b.y = 0 : (e(!0), q());\n        };\n\n        (g.inverted || 1 < this.len) && e();\n        q();\n        return b;\n      },\n      defaultFormatter: function defaultFormatter(a) {\n        var c = this.points || u(this),\n            d;\n        d = [a.tooltipFooterHeaderFormatter(c[0])];\n        d = d.concat(a.bodyFormatter(c));\n        d.push(a.tooltipFooterHeaderFormatter(c[0], !0));\n        return d;\n      },\n      refresh: function refresh(c, g) {\n        var d,\n            m = this.options,\n            p,\n            b = c,\n            l,\n            f = {},\n            x = [];\n        d = m.formatter || this.defaultFormatter;\n        var f = this.shared,\n            t,\n            h = this.chart.styledMode;\n        m.enabled && (a.clearTimeout(this.hideTimer), this.followPointer = u(b)[0].series.tooltipOptions.followPointer, l = this.getAnchor(b, g), g = l[0], p = l[1], !f || b.series && b.series.noSharedTooltip ? f = b.getLabelConfig() : (b.forEach(function (a) {\n          a.setState(\"hover\");\n          x.push(a.getLabelConfig());\n        }), f = {\n          x: b[0].category,\n          y: b[0].y\n        }, f.points = x, b = b[0]), this.len = x.length, f = d.call(f, this), t = b.series, this.distance = r(t.tooltipOptions.distance, 16), !1 === f ? this.hide() : (d = this.getLabel(), this.isHidden && d.attr({\n          opacity: 1\n        }).show(), this.split ? this.renderSplit(f, u(c)) : (m.style.width && !h || d.css({\n          width: this.chart.spacingBox.width\n        }), d.attr({\n          text: f && f.join ? f.join(\"\") : f\n        }), d.removeClass(/highcharts-color-[\\d]+/g).addClass(\"highcharts-color-\" + r(b.colorIndex, t.colorIndex)), h || d.attr({\n          stroke: m.borderColor || b.color || t.color || \"#666666\"\n        }), this.updatePosition({\n          plotX: g,\n          plotY: p,\n          negative: b.negative,\n          ttBelow: b.ttBelow,\n          h: l[2] || 0\n        })), this.isHidden = !1));\n      },\n      renderSplit: function renderSplit(c, g) {\n        var d = this,\n            m = [],\n            p = this.chart,\n            b = p.renderer,\n            l = !0,\n            f = this.options,\n            x = 0,\n            t,\n            h = this.getLabel(),\n            n = p.plotTop;\n        a.isString(c) && (c = [!1, c]);\n        c.slice(0, g.length + 1).forEach(function (a, k) {\n          if (!1 !== a && \"\" !== a) {\n            k = g[k - 1] || {\n              isHeader: !0,\n              plotX: g[0].plotX,\n              plotY: p.plotHeight\n            };\n            var c = k.series || d,\n                D = c.tt,\n                B = k.series || {},\n                e = \"highcharts-color-\" + r(k.colorIndex, B.colorIndex, \"none\");\n            D || (D = {\n              padding: f.padding,\n              r: f.borderRadius\n            }, p.styledMode || (D.fill = f.backgroundColor, D.stroke = f.borderColor || k.color || B.color || \"#333333\", D[\"stroke-width\"] = f.borderWidth), c.tt = D = b.label(null, null, null, (k.isHeader ? f.headerShape : f.shape) || \"callout\", null, null, f.useHTML).addClass(\"highcharts-tooltip-box \" + e).attr(D).add(h));\n            D.isActive = !0;\n            D.attr({\n              text: a\n            });\n            p.styledMode || D.css(f.style).shadow(f.shadow);\n            a = D.getBBox();\n            B = a.width + D.strokeWidth();\n            k.isHeader ? (x = a.height, p.xAxis[0].opposite && (t = !0, n -= x), B = Math.max(0, Math.min(k.plotX + p.plotLeft - B / 2, p.chartWidth + (p.scrollablePixels ? p.scrollablePixels - p.marginRight : 0) - B))) : B = k.plotX + p.plotLeft - r(f.distance, 16) - B;\n            0 > B && (l = !1);\n            a = (k.series && k.series.yAxis && k.series.yAxis.pos) + (k.plotY || 0);\n            a -= n;\n            k.isHeader && (a = t ? -x : p.plotHeight + x);\n            m.push({\n              target: a,\n              rank: k.isHeader ? 1 : 0,\n              size: c.tt.getBBox().height + 1,\n              point: k,\n              x: B,\n              tt: D\n            });\n          }\n        });\n        this.cleanSplit();\n        f.positioner && m.forEach(function (a) {\n          var b = f.positioner.call(d, a.tt.getBBox().width, a.size, a.point);\n          a.x = b.x;\n          a.align = 0;\n          a.target = b.y;\n          a.rank = r(b.rank, a.rank);\n        });\n        a.distribute(m, p.plotHeight + x);\n        m.forEach(function (a) {\n          var b = a.point,\n              d = b.series;\n          a.tt.attr({\n            visibility: void 0 === a.pos ? \"hidden\" : \"inherit\",\n            x: l || b.isHeader || f.positioner ? a.x : b.plotX + p.plotLeft + r(f.distance, 16),\n            y: a.pos + n,\n            anchorX: b.isHeader ? b.plotX + p.plotLeft : b.plotX + d.xAxis.pos,\n            anchorY: b.isHeader ? p.plotTop + p.plotHeight / 2 : b.plotY + d.yAxis.pos\n          });\n        });\n      },\n      updatePosition: function updatePosition(a) {\n        var c = this.chart,\n            d = this.getLabel(),\n            m = (this.options.positioner || this.getPosition).call(this, d.width, d.height, a),\n            p = a.plotX + c.plotLeft;\n        a = a.plotY + c.plotTop;\n        var b;\n        this.outside && (b = (this.options.borderWidth || 0) + 2 * this.distance, this.renderer.setSize(d.width + b, d.height + b, !1), p += c.pointer.chartPosition.left - m.x, a += c.pointer.chartPosition.top - m.y);\n        this.move(Math.round(m.x), Math.round(m.y || 0), p, a);\n      },\n      getDateFormat: function getDateFormat(a, c, d, m) {\n        var g = this.chart.time,\n            b = g.dateFormat(\"%m-%d %H:%M:%S.%L\", c),\n            l,\n            f,\n            x = {\n          millisecond: 15,\n          second: 12,\n          minute: 9,\n          hour: 6,\n          day: 3\n        },\n            t = \"millisecond\";\n\n        for (f in w) {\n          if (a === w.week && +g.dateFormat(\"%w\", c) === d && \"00:00:00.000\" === b.substr(6)) {\n            f = \"week\";\n            break;\n          }\n\n          if (w[f] > a) {\n            f = t;\n            break;\n          }\n\n          if (x[f] && b.substr(x[f]) !== \"01-01 00:00:00.000\".substr(x[f])) break;\n          \"week\" !== f && (t = f);\n        }\n\n        f && (l = g.resolveDTLFormat(m[f]).main);\n        return l;\n      },\n      getXDateFormat: function getXDateFormat(a, c, d) {\n        c = c.dateTimeLabelFormats;\n        var g = d && d.closestPointRange;\n        return (g ? this.getDateFormat(g, a.x, d.options.startOfWeek, c) : c.day) || c.year;\n      },\n      tooltipFooterHeaderFormatter: function tooltipFooterHeaderFormatter(a, c) {\n        c = c ? \"footer\" : \"header\";\n        var d = a.series,\n            g = d.tooltipOptions,\n            p = g.xDateFormat,\n            b = d.xAxis,\n            l = b && \"datetime\" === b.options.type && h(a.key),\n            f = g[c + \"Format\"];\n        l && !p && (p = this.getXDateFormat(a, g, b));\n        l && p && (a.point && a.point.tooltipDateKeys || [\"key\"]).forEach(function (a) {\n          f = f.replace(\"{point.\" + a + \"}\", \"{point.\" + a + \":\" + p + \"}\");\n        });\n        d.chart.styledMode && (f = this.styledModeFormat(f));\n        return E(f, {\n          point: a,\n          series: d\n        }, this.chart.time);\n      },\n      bodyFormatter: function bodyFormatter(a) {\n        return a.map(function (a) {\n          var d = a.series.tooltipOptions;\n          return (d[(a.point.formatPrefix || \"point\") + \"Formatter\"] || a.point.tooltipFormatter).call(a.point, d[(a.point.formatPrefix || \"point\") + \"Format\"] || \"\");\n        });\n      },\n      styledModeFormat: function styledModeFormat(a) {\n        return a.replace('style\\x3d\"font-size: 10px\"', 'class\\x3d\"highcharts-header\"').replace(/style=\"color:{(point|series)\\.color}\"/g, 'class\\x3d\"highcharts-color-{$1.colorIndex}\"');\n      }\n    };\n  })(J);\n\n  (function (a) {\n    var y = a.addEvent,\n        G = a.attr,\n        E = a.charts,\n        h = a.color,\n        c = a.css,\n        r = a.defined,\n        u = a.extend,\n        v = a.find,\n        w = a.fireEvent,\n        n = a.isNumber,\n        g = a.isObject,\n        d = a.offset,\n        m = a.pick,\n        p = a.splat,\n        b = a.Tooltip;\n\n    a.Pointer = function (a, b) {\n      this.init(a, b);\n    };\n\n    a.Pointer.prototype = {\n      init: function init(a, f) {\n        this.options = f;\n        this.chart = a;\n        this.runChartClick = f.chart.events && !!f.chart.events.click;\n        this.pinchDown = [];\n        this.lastValidTouch = {};\n        b && (a.tooltip = new b(a, f.tooltip), this.followTouchMove = m(f.tooltip.followTouchMove, !0));\n        this.setDOMEvents();\n      },\n      zoomOption: function zoomOption(a) {\n        var b = this.chart,\n            d = b.options.chart,\n            l = d.zoomType || \"\",\n            b = b.inverted;\n        /touch/.test(a.type) && (l = m(d.pinchType, l));\n        this.zoomX = a = /x/.test(l);\n        this.zoomY = l = /y/.test(l);\n        this.zoomHor = a && !b || l && b;\n        this.zoomVert = l && !b || a && b;\n        this.hasZoom = a || l;\n      },\n      normalize: function normalize(a, b) {\n        var f;\n        f = a.touches ? a.touches.length ? a.touches.item(0) : a.changedTouches[0] : a;\n        b || (this.chartPosition = b = d(this.chart.container));\n        return u(a, {\n          chartX: Math.round(f.pageX - b.left),\n          chartY: Math.round(f.pageY - b.top)\n        });\n      },\n      getCoordinates: function getCoordinates(a) {\n        var b = {\n          xAxis: [],\n          yAxis: []\n        };\n        this.chart.axes.forEach(function (f) {\n          b[f.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n            axis: f,\n            value: f.toValue(a[f.horiz ? \"chartX\" : \"chartY\"])\n          });\n        });\n        return b;\n      },\n      findNearestKDPoint: function findNearestKDPoint(a, b, d) {\n        var f;\n        a.forEach(function (a) {\n          var l = !(a.noSharedTooltip && b) && 0 > a.options.findNearestPointBy.indexOf(\"y\");\n          a = a.searchPoint(d, l);\n          if ((l = g(a, !0)) && !(l = !g(f, !0))) var l = f.distX - a.distX,\n              c = f.dist - a.dist,\n              k = (a.series.group && a.series.group.zIndex) - (f.series.group && f.series.group.zIndex),\n              l = 0 < (0 !== l && b ? l : 0 !== c ? c : 0 !== k ? k : f.series.index > a.series.index ? -1 : 1);\n          l && (f = a);\n        });\n        return f;\n      },\n      getPointFromEvent: function getPointFromEvent(a) {\n        a = a.target;\n\n        for (var b; a && !b;) {\n          b = a.point, a = a.parentNode;\n        }\n\n        return b;\n      },\n      getChartCoordinatesFromPoint: function getChartCoordinatesFromPoint(a, b) {\n        var f = a.series,\n            d = f.xAxis,\n            f = f.yAxis,\n            l = m(a.clientX, a.plotX),\n            c = a.shapeArgs;\n        if (d && f) return b ? {\n          chartX: d.len + d.pos - l,\n          chartY: f.len + f.pos - a.plotY\n        } : {\n          chartX: l + d.pos,\n          chartY: a.plotY + f.pos\n        };\n        if (c && c.x && c.y) return {\n          chartX: c.x,\n          chartY: c.y\n        };\n      },\n      getHoverData: function getHoverData(a, b, d, c, p, h, n) {\n        var f,\n            l = [],\n            t = n && n.isBoosting;\n        c = !(!c || !a);\n        n = b && !b.stickyTracking ? [b] : d.filter(function (a) {\n          return a.visible && !(!p && a.directTouch) && m(a.options.enableMouseTracking, !0) && a.stickyTracking;\n        });\n        b = (f = c ? a : this.findNearestKDPoint(n, p, h)) && f.series;\n        f && (p && !b.noSharedTooltip ? (n = d.filter(function (a) {\n          return a.visible && !(!p && a.directTouch) && m(a.options.enableMouseTracking, !0) && !a.noSharedTooltip;\n        }), n.forEach(function (a) {\n          var b = v(a.points, function (a) {\n            return a.x === f.x && !a.isNull;\n          });\n          g(b) && (t && (b = a.getPoint(b)), l.push(b));\n        })) : l.push(f));\n        return {\n          hoverPoint: f,\n          hoverSeries: b,\n          hoverPoints: l\n        };\n      },\n      runPointActions: function runPointActions(b, f) {\n        var d = this.chart,\n            c = d.tooltip && d.tooltip.options.enabled ? d.tooltip : void 0,\n            l = c ? c.shared : !1,\n            g = f || d.hoverPoint,\n            p = g && g.series || d.hoverSeries,\n            p = this.getHoverData(g, p, d.series, \"touchmove\" !== b.type && (!!f || p && p.directTouch && this.isDirectTouch), l, b, {\n          isBoosting: d.isBoosting\n        }),\n            k,\n            g = p.hoverPoint;\n        k = p.hoverPoints;\n        f = (p = p.hoverSeries) && p.tooltipOptions.followPointer;\n        l = l && p && !p.noSharedTooltip;\n\n        if (g && (g !== d.hoverPoint || c && c.isHidden)) {\n          (d.hoverPoints || []).forEach(function (a) {\n            -1 === k.indexOf(a) && a.setState();\n          });\n          (k || []).forEach(function (a) {\n            a.setState(\"hover\");\n          });\n          if (d.hoverSeries !== p) p.onMouseOver();\n          d.hoverPoint && d.hoverPoint.firePointEvent(\"mouseOut\");\n          if (!g.series) return;\n          g.firePointEvent(\"mouseOver\");\n          d.hoverPoints = k;\n          d.hoverPoint = g;\n          c && c.refresh(l ? k : g, b);\n        } else f && c && !c.isHidden && (g = c.getAnchor([{}], b), c.updatePosition({\n          plotX: g[0],\n          plotY: g[1]\n        }));\n\n        this.unDocMouseMove || (this.unDocMouseMove = y(d.container.ownerDocument, \"mousemove\", function (b) {\n          var f = E[a.hoverChartIndex];\n          if (f) f.pointer.onDocumentMouseMove(b);\n        }));\n        d.axes.forEach(function (f) {\n          var d = m(f.crosshair.snap, !0),\n              c = d ? a.find(k, function (a) {\n            return a.series[f.coll] === f;\n          }) : void 0;\n          c || !d ? f.drawCrosshair(b, c) : f.hideCrosshair();\n        });\n      },\n      reset: function reset(a, b) {\n        var f = this.chart,\n            d = f.hoverSeries,\n            c = f.hoverPoint,\n            l = f.hoverPoints,\n            g = f.tooltip,\n            k = g && g.shared ? l : c;\n        a && k && p(k).forEach(function (b) {\n          b.series.isCartesian && void 0 === b.plotX && (a = !1);\n        });\n        if (a) g && k && k.length && (g.refresh(k), g.shared && l ? l.forEach(function (a) {\n          a.setState(a.state, !0);\n          a.series.isCartesian && (a.series.xAxis.crosshair && a.series.xAxis.drawCrosshair(null, a), a.series.yAxis.crosshair && a.series.yAxis.drawCrosshair(null, a));\n        }) : c && (c.setState(c.state, !0), f.axes.forEach(function (a) {\n          a.crosshair && a.drawCrosshair(null, c);\n        })));else {\n          if (c) c.onMouseOut();\n          l && l.forEach(function (a) {\n            a.setState();\n          });\n          if (d) d.onMouseOut();\n          g && g.hide(b);\n          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());\n          f.axes.forEach(function (a) {\n            a.hideCrosshair();\n          });\n          this.hoverX = f.hoverPoints = f.hoverPoint = null;\n        }\n      },\n      scaleGroups: function scaleGroups(a, b) {\n        var f = this.chart,\n            d;\n        f.series.forEach(function (c) {\n          d = a || c.getPlotBox();\n          c.xAxis && c.xAxis.zoomEnabled && c.group && (c.group.attr(d), c.markerGroup && (c.markerGroup.attr(d), c.markerGroup.clip(b ? f.clipRect : null)), c.dataLabelsGroup && c.dataLabelsGroup.attr(d));\n        });\n        f.clipRect.attr(b || f.clipBox);\n      },\n      dragStart: function dragStart(a) {\n        var b = this.chart;\n        b.mouseIsDown = a.type;\n        b.cancelClick = !1;\n        b.mouseDownX = this.mouseDownX = a.chartX;\n        b.mouseDownY = this.mouseDownY = a.chartY;\n      },\n      drag: function drag(a) {\n        var b = this.chart,\n            d = b.options.chart,\n            c = a.chartX,\n            l = a.chartY,\n            g = this.zoomHor,\n            p = this.zoomVert,\n            k = b.plotLeft,\n            m = b.plotTop,\n            D = b.plotWidth,\n            B = b.plotHeight,\n            e,\n            q = this.selectionMarker,\n            n = this.mouseDownX,\n            r = this.mouseDownY,\n            u = d.panKey && a[d.panKey + \"Key\"];\n        q && q.touch || (c < k ? c = k : c > k + D && (c = k + D), l < m ? l = m : l > m + B && (l = m + B), this.hasDragged = Math.sqrt(Math.pow(n - c, 2) + Math.pow(r - l, 2)), 10 < this.hasDragged && (e = b.isInsidePlot(n - k, r - m), b.hasCartesianSeries && (this.zoomX || this.zoomY) && e && !u && !q && (this.selectionMarker = q = b.renderer.rect(k, m, g ? 1 : D, p ? 1 : B, 0).attr({\n          \"class\": \"highcharts-selection-marker\",\n          zIndex: 7\n        }).add(), b.styledMode || q.attr({\n          fill: d.selectionMarkerFill || h(\"#335cad\").setOpacity(.25).get()\n        })), q && g && (c -= n, q.attr({\n          width: Math.abs(c),\n          x: (0 < c ? 0 : c) + n\n        })), q && p && (c = l - r, q.attr({\n          height: Math.abs(c),\n          y: (0 < c ? 0 : c) + r\n        })), e && !q && d.panning && b.pan(a, d.panning)));\n      },\n      drop: function drop(a) {\n        var b = this,\n            d = this.chart,\n            l = this.hasPinched;\n\n        if (this.selectionMarker) {\n          var g = {\n            originalEvent: a,\n            xAxis: [],\n            yAxis: []\n          },\n              p = this.selectionMarker,\n              m = p.attr ? p.attr(\"x\") : p.x,\n              k = p.attr ? p.attr(\"y\") : p.y,\n              A = p.attr ? p.attr(\"width\") : p.width,\n              D = p.attr ? p.attr(\"height\") : p.height,\n              h;\n          if (this.hasDragged || l) d.axes.forEach(function (e) {\n            if (e.zoomEnabled && r(e.min) && (l || b[{\n              xAxis: \"zoomX\",\n              yAxis: \"zoomY\"\n            }[e.coll]])) {\n              var f = e.horiz,\n                  d = \"touchend\" === a.type ? e.minPixelPadding : 0,\n                  c = e.toValue((f ? m : k) + d),\n                  f = e.toValue((f ? m + A : k + D) - d);\n              g[e.coll].push({\n                axis: e,\n                min: Math.min(c, f),\n                max: Math.max(c, f)\n              });\n              h = !0;\n            }\n          }), h && w(d, \"selection\", g, function (a) {\n            d.zoom(u(a, l ? {\n              animation: !1\n            } : null));\n          });\n          n(d.index) && (this.selectionMarker = this.selectionMarker.destroy());\n          l && this.scaleGroups();\n        }\n\n        d && n(d.index) && (c(d.container, {\n          cursor: d._cursor\n        }), d.cancelClick = 10 < this.hasDragged, d.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n      },\n      onContainerMouseDown: function onContainerMouseDown(a) {\n        a = this.normalize(a);\n        2 !== a.button && (this.zoomOption(a), a.preventDefault && a.preventDefault(), this.dragStart(a));\n      },\n      onDocumentMouseUp: function onDocumentMouseUp(b) {\n        E[a.hoverChartIndex] && E[a.hoverChartIndex].pointer.drop(b);\n      },\n      onDocumentMouseMove: function onDocumentMouseMove(a) {\n        var b = this.chart,\n            d = this.chartPosition;\n        a = this.normalize(a, d);\n        !d || this.inClass(a.target, \"highcharts-tracker\") || b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) || this.reset();\n      },\n      onContainerMouseLeave: function onContainerMouseLeave(b) {\n        var f = E[a.hoverChartIndex];\n        f && (b.relatedTarget || b.toElement) && (f.pointer.reset(), f.pointer.chartPosition = null);\n      },\n      onContainerMouseMove: function onContainerMouseMove(b) {\n        var f = this.chart;\n        r(a.hoverChartIndex) && E[a.hoverChartIndex] && E[a.hoverChartIndex].mouseIsDown || (a.hoverChartIndex = f.index);\n        b = this.normalize(b);\n        b.returnValue = !1;\n        \"mousedown\" === f.mouseIsDown && this.drag(b);\n        !this.inClass(b.target, \"highcharts-tracker\") && !f.isInsidePlot(b.chartX - f.plotLeft, b.chartY - f.plotTop) || f.openMenu || this.runPointActions(b);\n      },\n      inClass: function inClass(a, b) {\n        for (var f; a;) {\n          if (f = G(a, \"class\")) {\n            if (-1 !== f.indexOf(b)) return !0;\n            if (-1 !== f.indexOf(\"highcharts-container\")) return !1;\n          }\n\n          a = a.parentNode;\n        }\n      },\n      onTrackerMouseOut: function onTrackerMouseOut(a) {\n        var b = this.chart.hoverSeries;\n        a = a.relatedTarget || a.toElement;\n        this.isDirectTouch = !1;\n        if (!(!b || !a || b.stickyTracking || this.inClass(a, \"highcharts-tooltip\") || this.inClass(a, \"highcharts-series-\" + b.index) && this.inClass(a, \"highcharts-tracker\"))) b.onMouseOut();\n      },\n      onContainerClick: function onContainerClick(a) {\n        var b = this.chart,\n            d = b.hoverPoint,\n            c = b.plotLeft,\n            l = b.plotTop;\n        a = this.normalize(a);\n        b.cancelClick || (d && this.inClass(a.target, \"highcharts-tracker\") ? (w(d.series, \"click\", u(a, {\n          point: d\n        })), b.hoverPoint && d.firePointEvent(\"click\", a)) : (u(a, this.getCoordinates(a)), b.isInsidePlot(a.chartX - c, a.chartY - l) && w(b, \"click\", a)));\n      },\n      setDOMEvents: function setDOMEvents() {\n        var b = this,\n            f = b.chart.container,\n            d = f.ownerDocument;\n\n        f.onmousedown = function (a) {\n          b.onContainerMouseDown(a);\n        };\n\n        f.onmousemove = function (a) {\n          b.onContainerMouseMove(a);\n        };\n\n        f.onclick = function (a) {\n          b.onContainerClick(a);\n        };\n\n        this.unbindContainerMouseLeave = y(f, \"mouseleave\", b.onContainerMouseLeave);\n        a.unbindDocumentMouseUp || (a.unbindDocumentMouseUp = y(d, \"mouseup\", b.onDocumentMouseUp));\n        a.hasTouch && (f.ontouchstart = function (a) {\n          b.onContainerTouchStart(a);\n        }, f.ontouchmove = function (a) {\n          b.onContainerTouchMove(a);\n        }, a.unbindDocumentTouchEnd || (a.unbindDocumentTouchEnd = y(d, \"touchend\", b.onDocumentTouchEnd)));\n      },\n      destroy: function destroy() {\n        var b = this;\n        b.unDocMouseMove && b.unDocMouseMove();\n        this.unbindContainerMouseLeave();\n        a.chartCount || (a.unbindDocumentMouseUp && (a.unbindDocumentMouseUp = a.unbindDocumentMouseUp()), a.unbindDocumentTouchEnd && (a.unbindDocumentTouchEnd = a.unbindDocumentTouchEnd()));\n        clearInterval(b.tooltipTimeout);\n        a.objectEach(b, function (a, d) {\n          b[d] = null;\n        });\n      }\n    };\n  })(J);\n\n  (function (a) {\n    var y = a.charts,\n        G = a.extend,\n        E = a.noop,\n        h = a.pick;\n    G(a.Pointer.prototype, {\n      pinchTranslate: function pinchTranslate(a, h, u, v, w, n) {\n        this.zoomHor && this.pinchTranslateDirection(!0, a, h, u, v, w, n);\n        this.zoomVert && this.pinchTranslateDirection(!1, a, h, u, v, w, n);\n      },\n      pinchTranslateDirection: function pinchTranslateDirection(a, h, u, v, w, n, g, d) {\n        var c = this.chart,\n            p = a ? \"x\" : \"y\",\n            b = a ? \"X\" : \"Y\",\n            l = \"chart\" + b,\n            f = a ? \"width\" : \"height\",\n            x = c[\"plot\" + (a ? \"Left\" : \"Top\")],\n            t,\n            r,\n            F = d || 1,\n            z = c.inverted,\n            k = c.bounds[a ? \"h\" : \"v\"],\n            A = 1 === h.length,\n            D = h[0][l],\n            B = u[0][l],\n            e = !A && h[1][l],\n            q = !A && u[1][l],\n            L;\n\n        u = function u() {\n          !A && 20 < Math.abs(D - e) && (F = d || Math.abs(B - q) / Math.abs(D - e));\n          r = (x - B) / F + D;\n          t = c[\"plot\" + (a ? \"Width\" : \"Height\")] / F;\n        };\n\n        u();\n        h = r;\n        h < k.min ? (h = k.min, L = !0) : h + t > k.max && (h = k.max - t, L = !0);\n        L ? (B -= .8 * (B - g[p][0]), A || (q -= .8 * (q - g[p][1])), u()) : g[p] = [B, q];\n        z || (n[p] = r - x, n[f] = t);\n        n = z ? 1 / F : F;\n        w[f] = t;\n        w[p] = h;\n        v[z ? a ? \"scaleY\" : \"scaleX\" : \"scale\" + b] = F;\n        v[\"translate\" + b] = n * x + (B - n * D);\n      },\n      pinch: function pinch(a) {\n        var c = this,\n            u = c.chart,\n            v = c.pinchDown,\n            w = a.touches,\n            n = w.length,\n            g = c.lastValidTouch,\n            d = c.hasZoom,\n            m = c.selectionMarker,\n            p = {},\n            b = 1 === n && (c.inClass(a.target, \"highcharts-tracker\") && u.runTrackerClick || c.runChartClick),\n            l = {};\n        1 < n && (c.initiated = !0);\n        d && c.initiated && !b && a.preventDefault();\n        [].map.call(w, function (a) {\n          return c.normalize(a);\n        });\n        \"touchstart\" === a.type ? ([].forEach.call(w, function (a, b) {\n          v[b] = {\n            chartX: a.chartX,\n            chartY: a.chartY\n          };\n        }), g.x = [v[0].chartX, v[1] && v[1].chartX], g.y = [v[0].chartY, v[1] && v[1].chartY], u.axes.forEach(function (a) {\n          if (a.zoomEnabled) {\n            var b = u.bounds[a.horiz ? \"h\" : \"v\"],\n                f = a.minPixelPadding,\n                d = a.toPixels(h(a.options.min, a.dataMin)),\n                c = a.toPixels(h(a.options.max, a.dataMax)),\n                l = Math.max(d, c);\n            b.min = Math.min(a.pos, Math.min(d, c) - f);\n            b.max = Math.max(a.pos + a.len, l + f);\n          }\n        }), c.res = !0) : c.followTouchMove && 1 === n ? this.runPointActions(c.normalize(a)) : v.length && (m || (c.selectionMarker = m = G({\n          destroy: E,\n          touch: !0\n        }, u.plotBox)), c.pinchTranslate(v, w, p, m, l, g), c.hasPinched = d, c.scaleGroups(p, l), c.res && (c.res = !1, this.reset(!1, 0)));\n      },\n      touch: function touch(c, r) {\n        var u = this.chart,\n            v,\n            w;\n        if (u.index !== a.hoverChartIndex) this.onContainerMouseLeave({\n          relatedTarget: !0\n        });\n        a.hoverChartIndex = u.index;\n        1 === c.touches.length ? (c = this.normalize(c), (w = u.isInsidePlot(c.chartX - u.plotLeft, c.chartY - u.plotTop)) && !u.openMenu ? (r && this.runPointActions(c), \"touchmove\" === c.type && (r = this.pinchDown, v = r[0] ? 4 <= Math.sqrt(Math.pow(r[0].chartX - c.chartX, 2) + Math.pow(r[0].chartY - c.chartY, 2)) : !1), h(v, !0) && this.pinch(c)) : r && this.reset()) : 2 === c.touches.length && this.pinch(c);\n      },\n      onContainerTouchStart: function onContainerTouchStart(a) {\n        this.zoomOption(a);\n        this.touch(a, !0);\n      },\n      onContainerTouchMove: function onContainerTouchMove(a) {\n        this.touch(a);\n      },\n      onDocumentTouchEnd: function onDocumentTouchEnd(c) {\n        y[a.hoverChartIndex] && y[a.hoverChartIndex].pointer.drop(c);\n      }\n    });\n  })(J);\n\n  (function (a) {\n    var y = a.addEvent,\n        G = a.charts,\n        E = a.css,\n        h = a.doc,\n        c = a.extend,\n        r = a.noop,\n        u = a.Pointer,\n        v = a.removeEvent,\n        w = a.win,\n        n = a.wrap;\n\n    if (!a.hasTouch && (w.PointerEvent || w.MSPointerEvent)) {\n      var g = {},\n          d = !!w.PointerEvent,\n          m = function m() {\n        var b = [];\n\n        b.item = function (a) {\n          return this[a];\n        };\n\n        a.objectEach(g, function (a) {\n          b.push({\n            pageX: a.pageX,\n            pageY: a.pageY,\n            target: a.target\n          });\n        });\n        return b;\n      },\n          p = function p(b, d, f, c) {\n        \"touch\" !== b.pointerType && b.pointerType !== b.MSPOINTER_TYPE_TOUCH || !G[a.hoverChartIndex] || (c(b), c = G[a.hoverChartIndex].pointer, c[d]({\n          type: f,\n          target: b.currentTarget,\n          preventDefault: r,\n          touches: m()\n        }));\n      };\n\n      c(u.prototype, {\n        onContainerPointerDown: function onContainerPointerDown(a) {\n          p(a, \"onContainerTouchStart\", \"touchstart\", function (a) {\n            g[a.pointerId] = {\n              pageX: a.pageX,\n              pageY: a.pageY,\n              target: a.currentTarget\n            };\n          });\n        },\n        onContainerPointerMove: function onContainerPointerMove(a) {\n          p(a, \"onContainerTouchMove\", \"touchmove\", function (a) {\n            g[a.pointerId] = {\n              pageX: a.pageX,\n              pageY: a.pageY\n            };\n            g[a.pointerId].target || (g[a.pointerId].target = a.currentTarget);\n          });\n        },\n        onDocumentPointerUp: function onDocumentPointerUp(a) {\n          p(a, \"onDocumentTouchEnd\", \"touchend\", function (a) {\n            delete g[a.pointerId];\n          });\n        },\n        batchMSEvents: function batchMSEvents(a) {\n          a(this.chart.container, d ? \"pointerdown\" : \"MSPointerDown\", this.onContainerPointerDown);\n          a(this.chart.container, d ? \"pointermove\" : \"MSPointerMove\", this.onContainerPointerMove);\n          a(h, d ? \"pointerup\" : \"MSPointerUp\", this.onDocumentPointerUp);\n        }\n      });\n      n(u.prototype, \"init\", function (a, d, f) {\n        a.call(this, d, f);\n        this.hasZoom && E(d.container, {\n          \"-ms-touch-action\": \"none\",\n          \"touch-action\": \"none\"\n        });\n      });\n      n(u.prototype, \"setDOMEvents\", function (a) {\n        a.apply(this);\n        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(y);\n      });\n      n(u.prototype, \"destroy\", function (a) {\n        this.batchMSEvents(v);\n        a.call(this);\n      });\n    }\n  })(J);\n\n  (function (a) {\n    var y = a.addEvent,\n        G = a.css,\n        E = a.discardElement,\n        h = a.defined,\n        c = a.fireEvent,\n        r = a.isFirefox,\n        u = a.marginNames,\n        v = a.merge,\n        w = a.pick,\n        n = a.setAnimation,\n        g = a.stableSort,\n        d = a.win,\n        m = a.wrap;\n\n    a.Legend = function (a, b) {\n      this.init(a, b);\n    };\n\n    a.Legend.prototype = {\n      init: function init(a, b) {\n        this.chart = a;\n        this.setOptions(b);\n        b.enabled && (this.render(), y(this.chart, \"endResize\", function () {\n          this.legend.positionCheckboxes();\n        }), this.proximate ? this.unchartrender = y(this.chart, \"render\", function () {\n          this.legend.proximatePositions();\n          this.legend.positionItems();\n        }) : this.unchartrender && this.unchartrender());\n      },\n      setOptions: function setOptions(a) {\n        var b = w(a.padding, 8);\n        this.options = a;\n        this.chart.styledMode || (this.itemStyle = a.itemStyle, this.itemHiddenStyle = v(this.itemStyle, a.itemHiddenStyle));\n        this.itemMarginTop = a.itemMarginTop || 0;\n        this.padding = b;\n        this.initialItemY = b - 5;\n        this.symbolWidth = w(a.symbolWidth, 16);\n        this.pages = [];\n        this.proximate = \"proximate\" === a.layout && !this.chart.inverted;\n      },\n      update: function update(a, b) {\n        var d = this.chart;\n        this.setOptions(v(!0, this.options, a));\n        this.destroy();\n        d.isDirtyLegend = d.isDirtyBox = !0;\n        w(b, !0) && d.redraw();\n        c(this, \"afterUpdate\");\n      },\n      colorizeItem: function colorizeItem(a, b) {\n        a.legendGroup[b ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\");\n\n        if (!this.chart.styledMode) {\n          var d = this.options,\n              f = a.legendItem,\n              g = a.legendLine,\n              p = a.legendSymbol,\n              m = this.itemHiddenStyle.color,\n              d = b ? d.itemStyle.color : m,\n              h = b ? a.color || m : m,\n              n = a.options && a.options.marker,\n              k = {\n            fill: h\n          };\n          f && f.css({\n            fill: d,\n            color: d\n          });\n          g && g.attr({\n            stroke: h\n          });\n          p && (n && p.isMarker && (k = a.pointAttribs(), b || (k.stroke = k.fill = m)), p.attr(k));\n        }\n\n        c(this, \"afterColorizeItem\", {\n          item: a,\n          visible: b\n        });\n      },\n      positionItems: function positionItems() {\n        this.allItems.forEach(this.positionItem, this);\n        this.chart.isResizing || this.positionCheckboxes();\n      },\n      positionItem: function positionItem(a) {\n        var b = this.options,\n            d = b.symbolPadding,\n            b = !b.rtl,\n            f = a._legendItemPos,\n            c = f[0],\n            f = f[1],\n            g = a.checkbox;\n        if ((a = a.legendGroup) && a.element) a[h(a.translateY) ? \"animate\" : \"attr\"]({\n          translateX: b ? c : this.legendWidth - c - 2 * d - 4,\n          translateY: f\n        });\n        g && (g.x = c, g.y = f);\n      },\n      destroyItem: function destroyItem(a) {\n        var b = a.checkbox;\n        [\"legendItem\", \"legendLine\", \"legendSymbol\", \"legendGroup\"].forEach(function (b) {\n          a[b] && (a[b] = a[b].destroy());\n        });\n        b && E(a.checkbox);\n      },\n      destroy: function destroy() {\n        function a(a) {\n          this[a] && (this[a] = this[a].destroy());\n        }\n\n        this.getAllItems().forEach(function (b) {\n          [\"legendItem\", \"legendGroup\"].forEach(a, b);\n        });\n        \"clipRect up down pager nav box title group\".split(\" \").forEach(a, this);\n        this.display = null;\n      },\n      positionCheckboxes: function positionCheckboxes() {\n        var a = this.group && this.group.alignAttr,\n            b,\n            d = this.clipHeight || this.legendHeight,\n            f = this.titleHeight;\n        a && (b = a.translateY, this.allItems.forEach(function (c) {\n          var g = c.checkbox,\n              l;\n          g && (l = b + f + g.y + (this.scrollOffset || 0) + 3, G(g, {\n            left: a.translateX + c.checkboxOffset + g.x - 20 + \"px\",\n            top: l + \"px\",\n            display: this.proximate || l > b - 6 && l < b + d - 6 ? \"\" : \"none\"\n          }));\n        }, this));\n      },\n      renderTitle: function renderTitle() {\n        var a = this.options,\n            b = this.padding,\n            d = a.title,\n            f = 0;\n        d.text && (this.title || (this.title = this.chart.renderer.label(d.text, b - 3, b - 4, null, null, null, a.useHTML, null, \"legend-title\").attr({\n          zIndex: 1\n        }), this.chart.styledMode || this.title.css(d.style), this.title.add(this.group)), a = this.title.getBBox(), f = a.height, this.offsetWidth = a.width, this.contentGroup.attr({\n          translateY: f\n        }));\n        this.titleHeight = f;\n      },\n      setText: function setText(d) {\n        var b = this.options;\n        d.legendItem.attr({\n          text: b.labelFormat ? a.format(b.labelFormat, d, this.chart.time) : b.labelFormatter.call(d)\n        });\n      },\n      renderItem: function renderItem(a) {\n        var b = this.chart,\n            d = b.renderer,\n            f = this.options,\n            c = this.symbolWidth,\n            g = f.symbolPadding,\n            p = this.itemStyle,\n            m = this.itemHiddenStyle,\n            h = \"horizontal\" === f.layout ? w(f.itemDistance, 20) : 0,\n            k = !f.rtl,\n            A = a.legendItem,\n            D = !a.series,\n            B = !D && a.series.drawLegendSymbol ? a.series : a,\n            e = B.options,\n            e = this.createCheckboxForItem && e && e.showCheckbox,\n            h = c + g + h + (e ? 20 : 0),\n            q = f.useHTML,\n            n = a.options.className;\n        A || (a.legendGroup = d.g(\"legend-item\").addClass(\"highcharts-\" + B.type + \"-series highcharts-color-\" + a.colorIndex + (n ? \" \" + n : \"\") + (D ? \" highcharts-series-\" + a.index : \"\")).attr({\n          zIndex: 1\n        }).add(this.scrollGroup), a.legendItem = A = d.text(\"\", k ? c + g : -g, this.baseline || 0, q), b.styledMode || A.css(v(a.visible ? p : m)), A.attr({\n          align: k ? \"left\" : \"right\",\n          zIndex: 2\n        }).add(a.legendGroup), this.baseline || (this.fontMetrics = d.fontMetrics(b.styledMode ? 12 : p.fontSize, A), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, A.attr(\"y\", this.baseline)), this.symbolHeight = f.symbolHeight || this.fontMetrics.f, B.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, A, q), e && this.createCheckboxForItem(a));\n        this.colorizeItem(a, a.visible);\n        !b.styledMode && p.width || A.css({\n          width: (f.itemWidth || f.width || b.spacingBox.width) - h\n        });\n        this.setText(a);\n        b = A.getBBox();\n        a.itemWidth = a.checkboxOffset = f.itemWidth || a.legendItemWidth || b.width + h;\n        this.maxItemWidth = Math.max(this.maxItemWidth, a.itemWidth);\n        this.totalItemWidth += a.itemWidth;\n        this.itemHeight = a.itemHeight = Math.round(a.legendItemHeight || b.height || this.symbolHeight);\n      },\n      layoutItem: function layoutItem(a) {\n        var b = this.options,\n            d = this.padding,\n            f = \"horizontal\" === b.layout,\n            c = a.itemHeight,\n            g = b.itemMarginBottom || 0,\n            p = this.itemMarginTop,\n            m = f ? w(b.itemDistance, 20) : 0,\n            h = b.width,\n            k = h || this.chart.spacingBox.width - 2 * d - b.x,\n            b = b.alignColumns && this.totalItemWidth > k ? this.maxItemWidth : a.itemWidth;\n        f && this.itemX - d + b > k && (this.itemX = d, this.itemY += p + this.lastLineHeight + g, this.lastLineHeight = 0);\n        this.lastItemY = p + this.itemY + g;\n        this.lastLineHeight = Math.max(c, this.lastLineHeight);\n        a._legendItemPos = [this.itemX, this.itemY];\n        f ? this.itemX += b : (this.itemY += p + c + g, this.lastLineHeight = c);\n        this.offsetWidth = h || Math.max((f ? this.itemX - d - (a.checkbox ? 0 : m) : b) + d, this.offsetWidth);\n      },\n      getAllItems: function getAllItems() {\n        var a = [];\n        this.chart.series.forEach(function (b) {\n          var d = b && b.options;\n          b && w(d.showInLegend, h(d.linkedTo) ? !1 : void 0, !0) && (a = a.concat(b.legendItems || (\"point\" === d.legendType ? b.data : b)));\n        });\n        c(this, \"afterGetAllItems\", {\n          allItems: a\n        });\n        return a;\n      },\n      getAlignment: function getAlignment() {\n        var a = this.options;\n        return this.proximate ? a.align.charAt(0) + \"tv\" : a.floating ? \"\" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0);\n      },\n      adjustMargins: function adjustMargins(a, b) {\n        var d = this.chart,\n            f = this.options,\n            c = this.getAlignment();\n        c && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (g, l) {\n          g.test(c) && !h(a[l]) && (d[u[l]] = Math.max(d[u[l]], d.legend[(l + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][l] * f[l % 2 ? \"x\" : \"y\"] + w(f.margin, 12) + b[l] + (0 === l && void 0 !== d.options.title.margin ? d.titleOffset + d.options.title.margin : 0)));\n        });\n      },\n      proximatePositions: function proximatePositions() {\n        var d = this.chart,\n            b = [],\n            c = \"left\" === this.options.align;\n        this.allItems.forEach(function (f) {\n          var g, l;\n          g = c;\n          f.xAxis && f.points && (f.xAxis.options.reversed && (g = !g), g = a.find(g ? f.points : f.points.slice(0).reverse(), function (b) {\n            return a.isNumber(b.plotY);\n          }), l = f.legendGroup.getBBox().height, b.push({\n            target: f.visible ? (g ? g.plotY : f.xAxis.height) - .3 * l : d.plotHeight,\n            size: l,\n            item: f\n          }));\n        }, this);\n        a.distribute(b, d.plotHeight);\n        b.forEach(function (a) {\n          a.item._legendItemPos[1] = d.plotTop - d.spacing[0] + a.pos;\n        });\n      },\n      render: function render() {\n        var a = this.chart,\n            b = a.renderer,\n            d = this.group,\n            f,\n            c,\n            m,\n            h = this.box,\n            n = this.options,\n            z = this.padding;\n        this.itemX = z;\n        this.itemY = this.initialItemY;\n        this.lastItemY = this.offsetWidth = 0;\n        d || (this.group = d = b.g(\"legend\").attr({\n          zIndex: 7\n        }).add(), this.contentGroup = b.g().attr({\n          zIndex: 1\n        }).add(d), this.scrollGroup = b.g().add(this.contentGroup));\n        this.renderTitle();\n        f = this.getAllItems();\n        g(f, function (a, b) {\n          return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);\n        });\n        n.reversed && f.reverse();\n        this.allItems = f;\n        this.display = c = !!f.length;\n        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;\n        f.forEach(this.renderItem, this);\n        f.forEach(this.layoutItem, this);\n        f = (n.width || this.offsetWidth) + z;\n        m = this.lastItemY + this.lastLineHeight + this.titleHeight;\n        m = this.handleOverflow(m);\n        m += z;\n        h || (this.box = h = b.rect().addClass(\"highcharts-legend-box\").attr({\n          r: n.borderRadius\n        }).add(d), h.isNew = !0);\n        a.styledMode || h.attr({\n          stroke: n.borderColor,\n          \"stroke-width\": n.borderWidth || 0,\n          fill: n.backgroundColor || \"none\"\n        }).shadow(n.shadow);\n        0 < f && 0 < m && (h[h.isNew ? \"attr\" : \"animate\"](h.crisp.call({}, {\n          x: 0,\n          y: 0,\n          width: f,\n          height: m\n        }, h.strokeWidth())), h.isNew = !1);\n        h[c ? \"show\" : \"hide\"]();\n        a.styledMode && \"none\" === d.getStyle(\"display\") && (f = m = 0);\n        this.legendWidth = f;\n        this.legendHeight = m;\n        c && (b = a.spacingBox, /(lth|ct|rth)/.test(this.getAlignment()) && (b = v(b, {\n          y: b.y + a.titleOffset + a.options.title.margin\n        })), d.align(v(n, {\n          width: f,\n          height: m,\n          verticalAlign: this.proximate ? \"top\" : n.verticalAlign\n        }), !0, b));\n        this.proximate || this.positionItems();\n      },\n      handleOverflow: function handleOverflow(a) {\n        var b = this,\n            d = this.chart,\n            f = d.renderer,\n            c = this.options,\n            g = c.y,\n            m = this.padding,\n            g = d.spacingBox.height + (\"top\" === c.verticalAlign ? -g : g) - m,\n            p = c.maxHeight,\n            h,\n            k = this.clipRect,\n            A = c.navigation,\n            D = w(A.animation, !0),\n            n = A.arrowSize || 12,\n            e = this.nav,\n            q = this.pages,\n            r,\n            u = this.allItems,\n            v = function v(a) {\n          \"number\" === typeof a ? k.attr({\n            height: a\n          }) : k && (b.clipRect = k.destroy(), b.contentGroup.clip());\n          b.contentGroup.div && (b.contentGroup.div.style.clip = a ? \"rect(\" + m + \"px,9999px,\" + (m + a) + \"px,0)\" : \"auto\");\n        };\n\n        \"horizontal\" !== c.layout || \"middle\" === c.verticalAlign || c.floating || (g /= 2);\n        p && (g = Math.min(g, p));\n        q.length = 0;\n        a > g && !1 !== A.enabled ? (this.clipHeight = h = Math.max(g - 20 - this.titleHeight - m, 0), this.currentPage = w(this.currentPage, 1), this.fullHeight = a, u.forEach(function (a, b) {\n          var e = a._legendItemPos[1],\n              d = Math.round(a.legendItem.getBBox().height),\n              f = q.length;\n          if (!f || e - q[f - 1] > h && (r || e) !== q[f - 1]) q.push(r || e), f++;\n          a.pageIx = f - 1;\n          r && (u[b - 1].pageIx = f - 1);\n          b === u.length - 1 && e + d - q[f - 1] > h && e !== r && (q.push(e), a.pageIx = f);\n          e !== r && (r = e);\n        }), k || (k = b.clipRect = f.clipRect(0, m, 9999, 0), b.contentGroup.clip(k)), v(h), e || (this.nav = e = f.g().attr({\n          zIndex: 1\n        }).add(this.group), this.up = f.symbol(\"triangle\", 0, 0, n, n).on(\"click\", function () {\n          b.scroll(-1, D);\n        }).add(e), this.pager = f.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\"), d.styledMode || this.pager.css(A.style), this.pager.add(e), this.down = f.symbol(\"triangle-down\", 0, 0, n, n).on(\"click\", function () {\n          b.scroll(1, D);\n        }).add(e)), b.scroll(0), a = g) : e && (v(), this.nav = e.destroy(), this.scrollGroup.attr({\n          translateY: 1\n        }), this.clipHeight = 0);\n        return a;\n      },\n      scroll: function scroll(a, b) {\n        var d = this.pages,\n            f = d.length;\n        a = this.currentPage + a;\n        var c = this.clipHeight,\n            g = this.options.navigation,\n            m = this.pager,\n            p = this.padding;\n        a > f && (a = f);\n        0 < a && (void 0 !== b && n(b, this.chart), this.nav.attr({\n          translateX: p,\n          translateY: c + this.padding + 7 + this.titleHeight,\n          visibility: \"visible\"\n        }), this.up.attr({\n          \"class\": 1 === a ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n        }), m.attr({\n          text: a + \"/\" + f\n        }), this.down.attr({\n          x: 18 + this.pager.getBBox().width,\n          \"class\": a === f ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n        }), this.chart.styledMode || (this.up.attr({\n          fill: 1 === a ? g.inactiveColor : g.activeColor\n        }).css({\n          cursor: 1 === a ? \"default\" : \"pointer\"\n        }), this.down.attr({\n          fill: a === f ? g.inactiveColor : g.activeColor\n        }).css({\n          cursor: a === f ? \"default\" : \"pointer\"\n        })), this.scrollOffset = -d[a - 1] + this.initialItemY, this.scrollGroup.animate({\n          translateY: this.scrollOffset\n        }), this.currentPage = a, this.positionCheckboxes());\n      }\n    };\n    a.LegendSymbolMixin = {\n      drawRectangle: function drawRectangle(a, b) {\n        var d = a.symbolHeight,\n            f = a.options.squareSymbol;\n        b.legendSymbol = this.chart.renderer.rect(f ? (a.symbolWidth - d) / 2 : 0, a.baseline - d + 1, f ? d : a.symbolWidth, d, w(a.options.symbolRadius, d / 2)).addClass(\"highcharts-point\").attr({\n          zIndex: 3\n        }).add(b.legendGroup);\n      },\n      drawLineMarker: function drawLineMarker(a) {\n        var b = this.options,\n            d = b.marker,\n            f = a.symbolWidth,\n            c = a.symbolHeight,\n            g = c / 2,\n            m = this.chart.renderer,\n            p = this.legendGroup;\n        a = a.baseline - Math.round(.3 * a.fontMetrics.b);\n        var h = {};\n        this.chart.styledMode || (h = {\n          \"stroke-width\": b.lineWidth || 0\n        }, b.dashStyle && (h.dashstyle = b.dashStyle));\n        this.legendLine = m.path([\"M\", 0, a, \"L\", f, a]).addClass(\"highcharts-graph\").attr(h).add(p);\n        d && !1 !== d.enabled && f && (b = Math.min(w(d.radius, g), g), 0 === this.symbol.indexOf(\"url\") && (d = v(d, {\n          width: c,\n          height: c\n        }), b = 0), this.legendSymbol = d = m.symbol(this.symbol, f / 2 - b, a - b, 2 * b, 2 * b, d).addClass(\"highcharts-point\").add(p), d.isMarker = !0);\n      }\n    };\n    (/Trident\\/7\\.0/.test(d.navigator.userAgent) || r) && m(a.Legend.prototype, \"positionItem\", function (a, b) {\n      var d = this,\n          f = function f() {\n        b._legendItemPos && a.call(d, b);\n      };\n\n      f();\n      d.bubbleLegend || setTimeout(f);\n    });\n  })(J);\n\n  (function (a) {\n    var y = a.addEvent,\n        G = a.animate,\n        E = a.animObject,\n        h = a.attr,\n        c = a.doc,\n        r = a.Axis,\n        u = a.createElement,\n        v = a.defaultOptions,\n        w = a.discardElement,\n        n = a.charts,\n        g = a.css,\n        d = a.defined,\n        m = a.extend,\n        p = a.find,\n        b = a.fireEvent,\n        l = a.isNumber,\n        f = a.isObject,\n        x = a.isString,\n        t = a.Legend,\n        H = a.marginNames,\n        F = a.merge,\n        z = a.objectEach,\n        k = a.Pointer,\n        A = a.pick,\n        D = a.pInt,\n        B = a.removeEvent,\n        e = a.seriesTypes,\n        q = a.splat,\n        L = a.syncTimeout,\n        I = a.win,\n        R = a.Chart = function () {\n      this.getArgs.apply(this, arguments);\n    };\n\n    a.chart = function (a, b, e) {\n      return new R(a, b, e);\n    };\n\n    m(R.prototype, {\n      callbacks: [],\n      getArgs: function getArgs() {\n        var a = [].slice.call(arguments);\n        if (x(a[0]) || a[0].nodeName) this.renderTo = a.shift();\n        this.init(a[0], a[1]);\n      },\n      init: function init(e, d) {\n        var f,\n            k,\n            c = e.series,\n            g = e.plotOptions || {};\n        b(this, \"init\", {\n          args: arguments\n        }, function () {\n          e.series = null;\n          f = F(v, e);\n\n          for (k in f.plotOptions) {\n            f.plotOptions[k].tooltip = g[k] && F(g[k].tooltip) || void 0;\n          }\n\n          f.tooltip.userOptions = e.chart && e.chart.forExport && e.tooltip.userOptions || e.tooltip;\n          f.series = e.series = c;\n          this.userOptions = e;\n          var q = f.chart,\n              l = q.events;\n          this.margin = [];\n          this.spacing = [];\n          this.bounds = {\n            h: {},\n            v: {}\n          };\n          this.labelCollectors = [];\n          this.callback = d;\n          this.isResizing = 0;\n          this.options = f;\n          this.axes = [];\n          this.series = [];\n          this.time = e.time && Object.keys(e.time).length ? new a.Time(e.time) : a.time;\n          this.styledMode = q.styledMode;\n          this.hasCartesianSeries = q.showAxes;\n          var m = this;\n          m.index = n.length;\n          n.push(m);\n          a.chartCount++;\n          l && z(l, function (a, b) {\n            y(m, b, a);\n          });\n          m.xAxis = [];\n          m.yAxis = [];\n          m.pointCount = m.colorCounter = m.symbolCounter = 0;\n          b(m, \"afterInit\");\n          m.firstRender();\n        });\n      },\n      initSeries: function initSeries(b) {\n        var d = this.options.chart;\n        (d = e[b.type || d.type || d.defaultSeriesType]) || a.error(17, !0, this);\n        d = new d();\n        d.init(this, b);\n        return d;\n      },\n      orderSeries: function orderSeries(a) {\n        var b = this.series;\n\n        for (a = a || 0; a < b.length; a++) {\n          b[a] && (b[a].index = a, b[a].name = b[a].getName());\n        }\n      },\n      isInsidePlot: function isInsidePlot(a, b, e) {\n        var d = e ? b : a;\n        a = e ? a : b;\n        return 0 <= d && d <= this.plotWidth && 0 <= a && a <= this.plotHeight;\n      },\n      redraw: function redraw(e) {\n        b(this, \"beforeRedraw\");\n        var d = this.axes,\n            f = this.series,\n            k = this.pointer,\n            c = this.legend,\n            g = this.userOptions.legend,\n            q = this.isDirtyLegend,\n            l,\n            p,\n            A = this.hasCartesianSeries,\n            h = this.isDirtyBox,\n            D,\n            t = this.renderer,\n            n = t.isHidden(),\n            B = [];\n        this.setResponsive && this.setResponsive(!1);\n        a.setAnimation(e, this);\n        n && this.temporaryDisplay();\n        this.layOutTitles();\n\n        for (e = f.length; e--;) {\n          if (D = f[e], D.options.stacking && (l = !0, D.isDirty)) {\n            p = !0;\n            break;\n          }\n        }\n\n        if (p) for (e = f.length; e--;) {\n          D = f[e], D.options.stacking && (D.isDirty = !0);\n        }\n        f.forEach(function (a) {\n          a.isDirty && (\"point\" === a.options.legendType ? (a.updateTotals && a.updateTotals(), q = !0) : g && (g.labelFormatter || g.labelFormat) && (q = !0));\n          a.isDirtyData && b(a, \"updatedData\");\n        });\n        q && c && c.options.enabled && (c.render(), this.isDirtyLegend = !1);\n        l && this.getStacks();\n        A && d.forEach(function (a) {\n          a.updateNames();\n          a.updateYNames && a.updateYNames();\n          a.setScale();\n        });\n        this.getMargins();\n        A && (d.forEach(function (a) {\n          a.isDirty && (h = !0);\n        }), d.forEach(function (a) {\n          var e = a.min + \",\" + a.max;\n          a.extKey !== e && (a.extKey = e, B.push(function () {\n            b(a, \"afterSetExtremes\", m(a.eventArgs, a.getExtremes()));\n            delete a.eventArgs;\n          }));\n          (h || l) && a.redraw();\n        }));\n        h && this.drawChartBox();\n        b(this, \"predraw\");\n        f.forEach(function (a) {\n          (h || a.isDirty) && a.visible && a.redraw();\n          a.isDirtyData = !1;\n        });\n        k && k.reset(!0);\n        t.draw();\n        b(this, \"redraw\");\n        b(this, \"render\");\n        n && this.temporaryDisplay(!0);\n        B.forEach(function (a) {\n          a.call();\n        });\n      },\n      get: function get(a) {\n        function b(b) {\n          return b.id === a || b.options && b.options.id === a;\n        }\n\n        var e,\n            d = this.series,\n            f;\n        e = p(this.axes, b) || p(this.series, b);\n\n        for (f = 0; !e && f < d.length; f++) {\n          e = p(d[f].points || [], b);\n        }\n\n        return e;\n      },\n      getAxes: function getAxes() {\n        var a = this,\n            e = this.options,\n            d = e.xAxis = q(e.xAxis || {}),\n            e = e.yAxis = q(e.yAxis || {});\n        b(this, \"getAxes\");\n        d.forEach(function (a, b) {\n          a.index = b;\n          a.isX = !0;\n        });\n        e.forEach(function (a, b) {\n          a.index = b;\n        });\n        d.concat(e).forEach(function (b) {\n          new r(a, b);\n        });\n        b(this, \"afterGetAxes\");\n      },\n      getSelectedPoints: function getSelectedPoints() {\n        var a = [];\n        this.series.forEach(function (b) {\n          a = a.concat((b.data || []).filter(function (a) {\n            return a.selected;\n          }));\n        });\n        return a;\n      },\n      getSelectedSeries: function getSelectedSeries() {\n        return this.series.filter(function (a) {\n          return a.selected;\n        });\n      },\n      setTitle: function setTitle(a, b, e) {\n        var d = this,\n            f = d.options,\n            k = d.styledMode,\n            c;\n        c = f.title = F(!k && {\n          style: {\n            color: \"#333333\",\n            fontSize: f.isStock ? \"16px\" : \"18px\"\n          }\n        }, f.title, a);\n        f = f.subtitle = F(!k && {\n          style: {\n            color: \"#666666\"\n          }\n        }, f.subtitle, b);\n        [[\"title\", a, c], [\"subtitle\", b, f]].forEach(function (a, b) {\n          var e = a[0],\n              f = d[e],\n              c = a[1];\n          a = a[2];\n          f && c && (d[e] = f = f.destroy());\n          a && !f && (d[e] = d.renderer.text(a.text, 0, 0, a.useHTML).attr({\n            align: a.align,\n            \"class\": \"highcharts-\" + e,\n            zIndex: a.zIndex || 4\n          }).add(), d[e].update = function (a) {\n            d.setTitle(!b && a, b && a);\n          }, k || d[e].css(a.style));\n        });\n        d.layOutTitles(e);\n      },\n      layOutTitles: function layOutTitles(a) {\n        var b = 0,\n            e,\n            d = this.renderer,\n            f = this.spacingBox;\n        [\"title\", \"subtitle\"].forEach(function (a) {\n          var e = this[a],\n              k = this.options[a];\n          a = \"title\" === a ? -3 : k.verticalAlign ? 0 : b + 2;\n          var c;\n          e && (this.styledMode || (c = k.style.fontSize), c = d.fontMetrics(c, e).b, e.css({\n            width: (k.width || f.width + k.widthAdjust) + \"px\"\n          }).align(m({\n            y: a + c\n          }, k), !1, \"spacingBox\"), k.floating || k.verticalAlign || (b = Math.ceil(b + e.getBBox(k.useHTML).height)));\n        }, this);\n        e = this.titleOffset !== b;\n        this.titleOffset = b;\n        !this.isDirtyBox && e && (this.isDirtyBox = this.isDirtyLegend = e, this.hasRendered && A(a, !0) && this.isDirtyBox && this.redraw());\n      },\n      getChartSize: function getChartSize() {\n        var b = this.options.chart,\n            e = b.width,\n            b = b.height,\n            f = this.renderTo;\n        d(e) || (this.containerWidth = a.getStyle(f, \"width\"));\n        d(b) || (this.containerHeight = a.getStyle(f, \"height\"));\n        this.chartWidth = Math.max(0, e || this.containerWidth || 600);\n        this.chartHeight = Math.max(0, a.relativeLength(b, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));\n      },\n      temporaryDisplay: function temporaryDisplay(b) {\n        var e = this.renderTo;\n        if (b) for (; e && e.style;) {\n          e.hcOrigStyle && (a.css(e, e.hcOrigStyle), delete e.hcOrigStyle), e.hcOrigDetached && (c.body.removeChild(e), e.hcOrigDetached = !1), e = e.parentNode;\n        } else for (; e && e.style;) {\n          c.body.contains(e) || e.parentNode || (e.hcOrigDetached = !0, c.body.appendChild(e));\n          if (\"none\" === a.getStyle(e, \"display\", !1) || e.hcOricDetached) e.hcOrigStyle = {\n            display: e.style.display,\n            height: e.style.height,\n            overflow: e.style.overflow\n          }, b = {\n            display: \"block\",\n            overflow: \"hidden\"\n          }, e !== this.renderTo && (b.height = 0), a.css(e, b), e.offsetWidth || e.style.setProperty(\"display\", \"block\", \"important\");\n          e = e.parentNode;\n          if (e === c.body) break;\n        }\n      },\n      setClassName: function setClassName(a) {\n        this.container.className = \"highcharts-container \" + (a || \"\");\n      },\n      getContainer: function getContainer() {\n        var e,\n            d = this.options,\n            f = d.chart,\n            k,\n            q;\n        e = this.renderTo;\n        var p = a.uniqueKey(),\n            A,\n            t;\n        e || (this.renderTo = e = f.renderTo);\n        x(e) && (this.renderTo = e = c.getElementById(e));\n        e || a.error(13, !0, this);\n        k = D(h(e, \"data-highcharts-chart\"));\n        l(k) && n[k] && n[k].hasRendered && n[k].destroy();\n        h(e, \"data-highcharts-chart\", this.index);\n        e.innerHTML = \"\";\n        f.skipClone || e.offsetWidth || this.temporaryDisplay();\n        this.getChartSize();\n        k = this.chartWidth;\n        q = this.chartHeight;\n        g(e, {\n          overflow: \"hidden\"\n        });\n        this.styledMode || (A = m({\n          position: \"relative\",\n          overflow: \"hidden\",\n          width: k + \"px\",\n          height: q + \"px\",\n          textAlign: \"left\",\n          lineHeight: \"normal\",\n          zIndex: 0,\n          \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\"\n        }, f.style));\n        this.container = e = u(\"div\", {\n          id: p\n        }, A, e);\n        this._cursor = e.style.cursor;\n        this.renderer = new (a[f.renderer] || a.Renderer)(e, k, q, null, f.forExport, d.exporting && d.exporting.allowHTML, this.styledMode);\n        this.setClassName(f.className);\n        if (this.styledMode) for (t in d.defs) {\n          this.renderer.definition(d.defs[t]);\n        } else this.renderer.setStyle(f.style);\n        this.renderer.chartIndex = this.index;\n        b(this, \"afterGetContainer\");\n      },\n      getMargins: function getMargins(a) {\n        var e = this.spacing,\n            f = this.margin,\n            k = this.titleOffset;\n        this.resetMargins();\n        k && !d(f[0]) && (this.plotTop = Math.max(this.plotTop, k + this.options.title.margin + e[0]));\n        this.legend && this.legend.display && this.legend.adjustMargins(f, e);\n        b(this, \"getMargins\");\n        a || this.getAxisMargins();\n      },\n      getAxisMargins: function getAxisMargins() {\n        var a = this,\n            b = a.axisOffset = [0, 0, 0, 0],\n            e = a.margin;\n        a.hasCartesianSeries && a.axes.forEach(function (a) {\n          a.visible && a.getOffset();\n        });\n        H.forEach(function (f, k) {\n          d(e[k]) || (a[f] += b[k]);\n        });\n        a.setChartSize();\n      },\n      reflow: function reflow(b) {\n        var e = this,\n            f = e.options.chart,\n            k = e.renderTo,\n            g = d(f.width) && d(f.height),\n            q = f.width || a.getStyle(k, \"width\"),\n            f = f.height || a.getStyle(k, \"height\"),\n            k = b ? b.target : I;\n\n        if (!g && !e.isPrinting && q && f && (k === I || k === c)) {\n          if (q !== e.containerWidth || f !== e.containerHeight) a.clearTimeout(e.reflowTimeout), e.reflowTimeout = L(function () {\n            e.container && e.setSize(void 0, void 0, !1);\n          }, b ? 100 : 0);\n          e.containerWidth = q;\n          e.containerHeight = f;\n        }\n      },\n      setReflow: function setReflow(a) {\n        var b = this;\n        !1 === a || this.unbindReflow ? !1 === a && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = y(I, \"resize\", function (a) {\n          b.reflow(a);\n        }), y(this, \"destroy\", this.unbindReflow));\n      },\n      setSize: function setSize(e, f, d) {\n        var k = this,\n            c = k.renderer,\n            q;\n        k.isResizing += 1;\n        a.setAnimation(d, k);\n        k.oldChartHeight = k.chartHeight;\n        k.oldChartWidth = k.chartWidth;\n        void 0 !== e && (k.options.chart.width = e);\n        void 0 !== f && (k.options.chart.height = f);\n        k.getChartSize();\n        k.styledMode || (q = c.globalAnimation, (q ? G : g)(k.container, {\n          width: k.chartWidth + \"px\",\n          height: k.chartHeight + \"px\"\n        }, q));\n        k.setChartSize(!0);\n        c.setSize(k.chartWidth, k.chartHeight, d);\n        k.axes.forEach(function (a) {\n          a.isDirty = !0;\n          a.setScale();\n        });\n        k.isDirtyLegend = !0;\n        k.isDirtyBox = !0;\n        k.layOutTitles();\n        k.getMargins();\n        k.redraw(d);\n        k.oldChartHeight = null;\n        b(k, \"resize\");\n        L(function () {\n          k && b(k, \"endResize\", null, function () {\n            --k.isResizing;\n          });\n        }, E(q).duration);\n      },\n      setChartSize: function setChartSize(a) {\n        var e = this.inverted,\n            f = this.renderer,\n            d = this.chartWidth,\n            k = this.chartHeight,\n            c = this.options.chart,\n            g = this.spacing,\n            q = this.clipOffset,\n            l,\n            m,\n            p,\n            A;\n        this.plotLeft = l = Math.round(this.plotLeft);\n        this.plotTop = m = Math.round(this.plotTop);\n        this.plotWidth = p = Math.max(0, Math.round(d - l - this.marginRight));\n        this.plotHeight = A = Math.max(0, Math.round(k - m - this.marginBottom));\n        this.plotSizeX = e ? A : p;\n        this.plotSizeY = e ? p : A;\n        this.plotBorderWidth = c.plotBorderWidth || 0;\n        this.spacingBox = f.spacingBox = {\n          x: g[3],\n          y: g[0],\n          width: d - g[3] - g[1],\n          height: k - g[0] - g[2]\n        };\n        this.plotBox = f.plotBox = {\n          x: l,\n          y: m,\n          width: p,\n          height: A\n        };\n        d = 2 * Math.floor(this.plotBorderWidth / 2);\n        e = Math.ceil(Math.max(d, q[3]) / 2);\n        f = Math.ceil(Math.max(d, q[0]) / 2);\n        this.clipBox = {\n          x: e,\n          y: f,\n          width: Math.floor(this.plotSizeX - Math.max(d, q[1]) / 2 - e),\n          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(d, q[2]) / 2 - f))\n        };\n        a || this.axes.forEach(function (a) {\n          a.setAxisSize();\n          a.setAxisTranslation();\n        });\n        b(this, \"afterSetChartSize\", {\n          skipAxes: a\n        });\n      },\n      resetMargins: function resetMargins() {\n        b(this, \"resetMargins\");\n        var a = this,\n            e = a.options.chart;\n        [\"margin\", \"spacing\"].forEach(function (b) {\n          var d = e[b],\n              k = f(d) ? d : [d, d, d, d];\n          [\"Top\", \"Right\", \"Bottom\", \"Left\"].forEach(function (d, f) {\n            a[b][f] = A(e[b + d], k[f]);\n          });\n        });\n        H.forEach(function (b, e) {\n          a[b] = A(a.margin[e], a.spacing[e]);\n        });\n        a.axisOffset = [0, 0, 0, 0];\n        a.clipOffset = [0, 0, 0, 0];\n      },\n      drawChartBox: function drawChartBox() {\n        var a = this.options.chart,\n            e = this.renderer,\n            d = this.chartWidth,\n            f = this.chartHeight,\n            k = this.chartBackground,\n            c = this.plotBackground,\n            g = this.plotBorder,\n            q,\n            l = this.styledMode,\n            m = this.plotBGImage,\n            p = a.backgroundColor,\n            A = a.plotBackgroundColor,\n            h = a.plotBackgroundImage,\n            D,\n            t = this.plotLeft,\n            n = this.plotTop,\n            B = this.plotWidth,\n            x = this.plotHeight,\n            r = this.plotBox,\n            z = this.clipRect,\n            u = this.clipBox,\n            v = \"animate\";\n        k || (this.chartBackground = k = e.rect().addClass(\"highcharts-background\").add(), v = \"attr\");\n        if (l) q = D = k.strokeWidth();else {\n          q = a.borderWidth || 0;\n          D = q + (a.shadow ? 8 : 0);\n          p = {\n            fill: p || \"none\"\n          };\n          if (q || k[\"stroke-width\"]) p.stroke = a.borderColor, p[\"stroke-width\"] = q;\n          k.attr(p).shadow(a.shadow);\n        }\n        k[v]({\n          x: D / 2,\n          y: D / 2,\n          width: d - D - q % 2,\n          height: f - D - q % 2,\n          r: a.borderRadius\n        });\n        v = \"animate\";\n        c || (v = \"attr\", this.plotBackground = c = e.rect().addClass(\"highcharts-plot-background\").add());\n        c[v](r);\n        l || (c.attr({\n          fill: A || \"none\"\n        }).shadow(a.plotShadow), h && (m ? m.animate(r) : this.plotBGImage = e.image(h, t, n, B, x).add()));\n        z ? z.animate({\n          width: u.width,\n          height: u.height\n        }) : this.clipRect = e.clipRect(u);\n        v = \"animate\";\n        g || (v = \"attr\", this.plotBorder = g = e.rect().addClass(\"highcharts-plot-border\").attr({\n          zIndex: 1\n        }).add());\n        l || g.attr({\n          stroke: a.plotBorderColor,\n          \"stroke-width\": a.plotBorderWidth || 0,\n          fill: \"none\"\n        });\n        g[v](g.crisp({\n          x: t,\n          y: n,\n          width: B,\n          height: x\n        }, -g.strokeWidth()));\n        this.isDirtyBox = !1;\n        b(this, \"afterDrawChartBox\");\n      },\n      propFromSeries: function propFromSeries() {\n        var a = this,\n            b = a.options.chart,\n            d,\n            f = a.options.series,\n            k,\n            c;\n        [\"inverted\", \"angular\", \"polar\"].forEach(function (g) {\n          d = e[b.type || b.defaultSeriesType];\n          c = b[g] || d && d.prototype[g];\n\n          for (k = f && f.length; !c && k--;) {\n            (d = e[f[k].type]) && d.prototype[g] && (c = !0);\n          }\n\n          a[g] = c;\n        });\n      },\n      linkSeries: function linkSeries() {\n        var a = this,\n            e = a.series;\n        e.forEach(function (a) {\n          a.linkedSeries.length = 0;\n        });\n        e.forEach(function (b) {\n          var e = b.options.linkedTo;\n          x(e) && (e = \":previous\" === e ? a.series[b.index - 1] : a.get(e)) && e.linkedParent !== b && (e.linkedSeries.push(b), b.linkedParent = e, b.visible = A(b.options.visible, e.options.visible, b.visible));\n        });\n        b(this, \"afterLinkSeries\");\n      },\n      renderSeries: function renderSeries() {\n        this.series.forEach(function (a) {\n          a.translate();\n          a.render();\n        });\n      },\n      renderLabels: function renderLabels() {\n        var a = this,\n            b = a.options.labels;\n        b.items && b.items.forEach(function (e) {\n          var d = m(b.style, e.style),\n              f = D(d.left) + a.plotLeft,\n              k = D(d.top) + a.plotTop + 12;\n          delete d.left;\n          delete d.top;\n          a.renderer.text(e.html, f, k).attr({\n            zIndex: 2\n          }).css(d).add();\n        });\n      },\n      render: function render() {\n        var a = this.axes,\n            b = this.renderer,\n            e = this.options,\n            d,\n            f,\n            k;\n        this.setTitle();\n        this.legend = new t(this, e.legend);\n        this.getStacks && this.getStacks();\n        this.getMargins(!0);\n        this.setChartSize();\n        e = this.plotWidth;\n        d = this.plotHeight = Math.max(this.plotHeight - 21, 0);\n        a.forEach(function (a) {\n          a.setScale();\n        });\n        this.getAxisMargins();\n        f = 1.1 < e / this.plotWidth;\n        k = 1.05 < d / this.plotHeight;\n        if (f || k) a.forEach(function (a) {\n          (a.horiz && f || !a.horiz && k) && a.setTickInterval(!0);\n        }), this.getMargins();\n        this.drawChartBox();\n        this.hasCartesianSeries && a.forEach(function (a) {\n          a.visible && a.render();\n        });\n        this.seriesGroup || (this.seriesGroup = b.g(\"series-group\").attr({\n          zIndex: 3\n        }).add());\n        this.renderSeries();\n        this.renderLabels();\n        this.addCredits();\n        this.setResponsive && this.setResponsive();\n        this.hasRendered = !0;\n      },\n      addCredits: function addCredits(a) {\n        var b = this;\n        a = F(!0, this.options.credits, a);\n        a.enabled && !this.credits && (this.credits = this.renderer.text(a.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n          a.href && (I.location.href = a.href);\n        }).attr({\n          align: a.position.align,\n          zIndex: 8\n        }), b.styledMode || this.credits.css(a.style), this.credits.add().align(a.position), this.credits.update = function (a) {\n          b.credits = b.credits.destroy();\n          b.addCredits(a);\n        });\n      },\n      destroy: function destroy() {\n        var e = this,\n            d = e.axes,\n            f = e.series,\n            k = e.container,\n            c,\n            g = k && k.parentNode;\n        b(e, \"destroy\");\n        e.renderer.forExport ? a.erase(n, e) : n[e.index] = void 0;\n        a.chartCount--;\n        e.renderTo.removeAttribute(\"data-highcharts-chart\");\n        B(e);\n\n        for (c = d.length; c--;) {\n          d[c] = d[c].destroy();\n        }\n\n        this.scroller && this.scroller.destroy && this.scroller.destroy();\n\n        for (c = f.length; c--;) {\n          f[c] = f[c].destroy();\n        }\n\n        \"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer\".split(\" \").forEach(function (a) {\n          var b = e[a];\n          b && b.destroy && (e[a] = b.destroy());\n        });\n        k && (k.innerHTML = \"\", B(k), g && w(k));\n        z(e, function (a, b) {\n          delete e[b];\n        });\n      },\n      firstRender: function firstRender() {\n        var e = this,\n            d = e.options;\n\n        if (!e.isReadyToRender || e.isReadyToRender()) {\n          e.getContainer();\n          e.resetMargins();\n          e.setChartSize();\n          e.propFromSeries();\n          e.getAxes();\n          (a.isArray(d.series) ? d.series : []).forEach(function (a) {\n            e.initSeries(a);\n          });\n          e.linkSeries();\n          b(e, \"beforeRender\");\n          k && (e.pointer = new k(e, d));\n          e.render();\n          if (!e.renderer.imgCount && e.onload) e.onload();\n          e.temporaryDisplay(!0);\n        }\n      },\n      onload: function onload() {\n        [this.callback].concat(this.callbacks).forEach(function (a) {\n          a && void 0 !== this.index && a.apply(this, [this]);\n        }, this);\n        b(this, \"load\");\n        b(this, \"render\");\n        d(this.index) && this.setReflow(this.options.chart.reflow);\n        this.onload = null;\n      }\n    });\n  })(J);\n\n  (function (a) {\n    var y = a.addEvent,\n        G = a.Chart;\n    y(G, \"afterSetChartSize\", function (y) {\n      var h = this.options.chart.scrollablePlotArea;\n      (h = h && h.minWidth) && !this.renderer.forExport && (this.scrollablePixels = h = Math.max(0, h - this.chartWidth)) && (this.plotWidth += h, this.clipBox.width += h, y.skipAxes || this.axes.forEach(function (c) {\n        1 === c.side ? c.getPlotLinePath = function () {\n          var h = this.right,\n              u;\n          this.right = h - c.chart.scrollablePixels;\n          u = a.Axis.prototype.getPlotLinePath.apply(this, arguments);\n          this.right = h;\n          return u;\n        } : (c.setAxisSize(), c.setAxisTranslation());\n      }));\n    });\n    y(G, \"render\", function () {\n      this.scrollablePixels ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();\n    });\n\n    G.prototype.setUpScrolling = function () {\n      this.scrollingContainer = a.createElement(\"div\", {\n        className: \"highcharts-scrolling\"\n      }, {\n        overflowX: \"auto\",\n        WebkitOverflowScrolling: \"touch\"\n      }, this.renderTo);\n      this.innerContainer = a.createElement(\"div\", {\n        className: \"highcharts-inner-container\"\n      }, null, this.scrollingContainer);\n      this.innerContainer.appendChild(this.container);\n      this.setUpScrolling = null;\n    };\n\n    G.prototype.applyFixed = function () {\n      var y = this.container,\n          h,\n          c,\n          r = !this.fixedDiv;\n      r && (this.fixedDiv = a.createElement(\"div\", {\n        className: \"highcharts-fixed\"\n      }, {\n        position: \"absolute\",\n        overflow: \"hidden\",\n        pointerEvents: \"none\",\n        zIndex: 2\n      }, null, !0), this.renderTo.insertBefore(this.fixedDiv, this.renderTo.firstChild), this.renderTo.style.overflow = \"visible\", this.fixedRenderer = h = new a.Renderer(this.fixedDiv, 0, 0), this.scrollableMask = h.path().attr({\n        fill: a.color(this.options.chart.backgroundColor || \"#fff\").setOpacity(.85).get(),\n        zIndex: -1\n      }).addClass(\"highcharts-scrollable-mask\").add(), [this.inverted ? \".highcharts-xaxis\" : \".highcharts-yaxis\", this.inverted ? \".highcharts-xaxis-labels\" : \".highcharts-yaxis-labels\", \".highcharts-contextbutton\", \".highcharts-credits\", \".highcharts-legend\", \".highcharts-subtitle\", \".highcharts-title\", \".highcharts-legend-checkbox\"].forEach(function (a) {\n        [].forEach.call(y.querySelectorAll(a), function (a) {\n          (a.namespaceURI === h.SVG_NS ? h.box : h.box.parentNode).appendChild(a);\n          a.style.pointerEvents = \"auto\";\n        });\n      }));\n      this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);\n      c = this.chartWidth + this.scrollablePixels;\n      a.stop(this.container);\n      this.container.style.width = c + \"px\";\n      this.renderer.boxWrapper.attr({\n        width: c,\n        height: this.chartHeight,\n        viewBox: [0, 0, c, this.chartHeight].join(\" \")\n      });\n      this.chartBackground.attr({\n        width: c\n      });\n      r && (c = this.options.chart.scrollablePlotArea, c.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixels * c.scrollPositionX));\n      r = this.axisOffset;\n      c = this.plotTop - r[0] - 1;\n      var r = this.plotTop + this.plotHeight + r[2],\n          u = this.plotLeft + this.plotWidth - this.scrollablePixels;\n      this.scrollableMask.attr({\n        d: this.scrollablePixels ? [\"M\", 0, c, \"L\", this.plotLeft - 1, c, \"L\", this.plotLeft - 1, r, \"L\", 0, r, \"Z\", \"M\", u, c, \"L\", this.chartWidth, c, \"L\", this.chartWidth, r, \"L\", u, r, \"Z\"] : [\"M\", 0, 0]\n      });\n    };\n  })(J);\n\n  (function (a) {\n    var y,\n        G = a.extend,\n        E = a.erase,\n        h = a.fireEvent,\n        c = a.format,\n        r = a.isArray,\n        u = a.isNumber,\n        v = a.pick,\n        w = a.uniqueKey,\n        n = a.defined,\n        g = a.removeEvent;\n\n    a.Point = y = function y() {};\n\n    a.Point.prototype = {\n      init: function init(a, c, g) {\n        var b;\n        b = a.chart.options.chart.colorCount;\n        var d = a.chart.styledMode;\n        this.series = a;\n        d || (this.color = a.color);\n        this.applyOptions(c, g);\n        this.id = n(this.id) ? this.id : w();\n        a.options.colorByPoint ? (d || (b = a.options.colors || a.chart.options.colors, this.color = this.color || b[a.colorCounter], b = b.length), c = a.colorCounter, a.colorCounter++, a.colorCounter === b && (a.colorCounter = 0)) : c = a.colorIndex;\n        this.colorIndex = v(this.colorIndex, c);\n        a.chart.pointCount++;\n        h(this, \"afterInit\");\n        return this;\n      },\n      applyOptions: function applyOptions(a, c) {\n        var d = this.series,\n            b = d.options.pointValKey || d.pointValKey;\n        a = y.prototype.optionsToObject.call(this, a);\n        G(this, a);\n        this.options = this.options ? G(this.options, a) : a;\n        a.group && delete this.group;\n        a.dataLabels && delete this.dataLabels;\n        b && (this.y = this[b]);\n        this.isNull = v(this.isValid && !this.isValid(), null === this.x || !u(this.y, !0));\n        this.selected && (this.state = \"select\");\n        \"name\" in this && void 0 === c && d.xAxis && d.xAxis.hasNames && (this.x = d.xAxis.nameToX(this));\n        void 0 === this.x && d && (this.x = void 0 === c ? d.autoIncrement(this) : c);\n        return this;\n      },\n      setNestedProperty: function setNestedProperty(d, c, g) {\n        g.split(\".\").reduce(function (b, d, f, g) {\n          b[d] = g.length - 1 === f ? c : a.isObject(b[d], !0) ? b[d] : {};\n          return b[d];\n        }, d);\n        return d;\n      },\n      optionsToObject: function optionsToObject(d) {\n        var c = {},\n            g = this.series,\n            b = g.options.keys,\n            l = b || g.pointArrayMap || [\"y\"],\n            f = l.length,\n            h = 0,\n            t = 0;\n        if (u(d) || null === d) c[l[0]] = d;else if (r(d)) for (!b && d.length > f && (g = _typeof(d[0]), \"string\" === g ? c.name = d[0] : \"number\" === g && (c.x = d[0]), h++); t < f;) {\n          b && void 0 === d[h] || (0 < l[t].indexOf(\".\") ? a.Point.prototype.setNestedProperty(c, d[h], l[t]) : c[l[t]] = d[h]), h++, t++;\n        } else \"object\" === _typeof(d) && (c = d, d.dataLabels && (g._hasPointLabels = !0), d.marker && (g._hasPointMarkers = !0));\n        return c;\n      },\n      getClassName: function getClassName() {\n        return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (void 0 !== this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n      },\n      getZone: function getZone() {\n        var a = this.series,\n            c = a.zones,\n            a = a.zoneAxis || \"y\",\n            g = 0,\n            b;\n\n        for (b = c[g]; this[a] >= b.value;) {\n          b = c[++g];\n        }\n\n        this.nonZonedColor || (this.nonZonedColor = this.color);\n        this.color = b && b.color && !this.options.color ? b.color : this.nonZonedColor;\n        return b;\n      },\n      destroy: function destroy() {\n        var a = this.series.chart,\n            c = a.hoverPoints,\n            h;\n        a.pointCount--;\n        c && (this.setState(), E(c, this), c.length || (a.hoverPoints = null));\n        if (this === a.hoverPoint) this.onMouseOut();\n        if (this.graphic || this.dataLabel || this.dataLabels) g(this), this.destroyElements();\n        this.legendItem && a.legend.destroyItem(this);\n\n        for (h in this) {\n          this[h] = null;\n        }\n      },\n      destroyElements: function destroyElements() {\n        for (var a = [\"graphic\", \"dataLabel\", \"dataLabelUpper\", \"connector\", \"shadowGroup\"], c, g = 6; g--;) {\n          c = a[g], this[c] && (this[c] = this[c].destroy());\n        }\n\n        this.dataLabels && (this.dataLabels.forEach(function (a) {\n          a.element && a.destroy();\n        }), delete this.dataLabels);\n        this.connectors && (this.connectors.forEach(function (a) {\n          a.element && a.destroy();\n        }), delete this.connectors);\n      },\n      getLabelConfig: function getLabelConfig() {\n        return {\n          x: this.category,\n          y: this.y,\n          color: this.color,\n          colorIndex: this.colorIndex,\n          key: this.name || this.category,\n          series: this.series,\n          point: this,\n          percentage: this.percentage,\n          total: this.total || this.stackTotal\n        };\n      },\n      tooltipFormatter: function tooltipFormatter(a) {\n        var d = this.series,\n            g = d.tooltipOptions,\n            b = v(g.valueDecimals, \"\"),\n            l = g.valuePrefix || \"\",\n            f = g.valueSuffix || \"\";\n        d.chart.styledMode && (a = d.chart.tooltip.styledModeFormat(a));\n        (d.pointArrayMap || [\"y\"]).forEach(function (d) {\n          d = \"{point.\" + d;\n          if (l || f) a = a.replace(RegExp(d + \"}\", \"g\"), l + d + \"}\" + f);\n          a = a.replace(RegExp(d + \"}\", \"g\"), d + \":,.\" + b + \"f}\");\n        });\n        return c(a, {\n          point: this,\n          series: this.series\n        }, d.chart.time);\n      },\n      firePointEvent: function firePointEvent(a, c, g) {\n        var b = this,\n            d = this.series.options;\n        (d.point.events[a] || b.options && b.options.events && b.options.events[a]) && this.importEvents();\n        \"click\" === a && d.allowPointSelect && (g = function g(a) {\n          b.select && b.select(null, a.ctrlKey || a.metaKey || a.shiftKey);\n        });\n        h(this, a, c, g);\n      },\n      visible: !0\n    };\n  })(J);\n\n  (function (a) {\n    var y = a.addEvent,\n        G = a.animObject,\n        E = a.arrayMax,\n        h = a.arrayMin,\n        c = a.correctFloat,\n        r = a.defaultOptions,\n        u = a.defaultPlotOptions,\n        v = a.defined,\n        w = a.erase,\n        n = a.extend,\n        g = a.fireEvent,\n        d = a.isArray,\n        m = a.isNumber,\n        p = a.isString,\n        b = a.merge,\n        l = a.objectEach,\n        f = a.pick,\n        x = a.removeEvent,\n        t = a.splat,\n        H = a.SVGElement,\n        F = a.syncTimeout,\n        z = a.win;\n    a.Series = a.seriesType(\"line\", null, {\n      lineWidth: 2,\n      allowPointSelect: !1,\n      showCheckbox: !1,\n      animation: {\n        duration: 1E3\n      },\n      events: {},\n      marker: {\n        lineWidth: 0,\n        lineColor: \"#ffffff\",\n        enabledThreshold: 2,\n        radius: 4,\n        states: {\n          normal: {\n            animation: !0\n          },\n          hover: {\n            animation: {\n              duration: 50\n            },\n            enabled: !0,\n            radiusPlus: 2,\n            lineWidthPlus: 1\n          },\n          select: {\n            fillColor: \"#cccccc\",\n            lineColor: \"#000000\",\n            lineWidth: 2\n          }\n        }\n      },\n      point: {\n        events: {}\n      },\n      dataLabels: {\n        align: \"center\",\n        formatter: function formatter() {\n          return null === this.y ? \"\" : a.numberFormat(this.y, -1);\n        },\n        style: {\n          fontSize: \"11px\",\n          fontWeight: \"bold\",\n          color: \"contrast\",\n          textOutline: \"1px contrast\"\n        },\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0,\n        padding: 5\n      },\n      cropThreshold: 300,\n      pointRange: 0,\n      softThreshold: !0,\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          animation: {\n            duration: 50\n          },\n          lineWidthPlus: 1,\n          marker: {},\n          halo: {\n            size: 10,\n            opacity: .25\n          }\n        },\n        select: {}\n      },\n      stickyTracking: !0,\n      turboThreshold: 1E3,\n      findNearestPointBy: \"x\"\n    }, {\n      isCartesian: !0,\n      pointClass: a.Point,\n      sorted: !0,\n      requireSorting: !0,\n      directTouch: !1,\n      axisTypes: [\"xAxis\", \"yAxis\"],\n      colorCounter: 0,\n      parallelArrays: [\"x\", \"y\"],\n      coll: \"series\",\n      init: function init(a, b) {\n        g(this, \"init\", {\n          options: b\n        });\n        var d = this,\n            k,\n            e = a.series,\n            c;\n        d.chart = a;\n        d.options = b = d.setOptions(b);\n        d.linkedSeries = [];\n        d.bindAxes();\n        n(d, {\n          name: b.name,\n          state: \"\",\n          visible: !1 !== b.visible,\n          selected: !0 === b.selected\n        });\n        k = b.events;\n        l(k, function (a, b) {\n          y(d, b, a);\n        });\n        if (k && k.click || b.point && b.point.events && b.point.events.click || b.allowPointSelect) a.runTrackerClick = !0;\n        d.getColor();\n        d.getSymbol();\n        d.parallelArrays.forEach(function (a) {\n          d[a + \"Data\"] = [];\n        });\n        d.setData(b.data, !1);\n        d.isCartesian && (a.hasCartesianSeries = !0);\n        e.length && (c = e[e.length - 1]);\n        d._i = f(c && c._i, -1) + 1;\n        a.orderSeries(this.insert(e));\n        g(this, \"afterInit\");\n      },\n      insert: function insert(a) {\n        var b = this.options.index,\n            d;\n\n        if (m(b)) {\n          for (d = a.length; d--;) {\n            if (b >= f(a[d].options.index, a[d]._i)) {\n              a.splice(d + 1, 0, this);\n              break;\n            }\n          }\n\n          -1 === d && a.unshift(this);\n          d += 1;\n        } else a.push(this);\n\n        return f(d, a.length - 1);\n      },\n      bindAxes: function bindAxes() {\n        var b = this,\n            d = b.options,\n            f = b.chart,\n            c;\n        (b.axisTypes || []).forEach(function (e) {\n          f[e].forEach(function (a) {\n            c = a.options;\n            if (d[e] === c.index || void 0 !== d[e] && d[e] === c.id || void 0 === d[e] && 0 === c.index) b.insert(a.series), b[e] = a, a.isDirty = !0;\n          });\n          b[e] || b.optionalAxis === e || a.error(18, !0, f);\n        });\n      },\n      updateParallelArrays: function updateParallelArrays(a, b) {\n        var d = a.series,\n            f = arguments,\n            e = m(b) ? function (e) {\n          var f = \"y\" === e && d.toYData ? d.toYData(a) : a[e];\n          d[e + \"Data\"][b] = f;\n        } : function (a) {\n          Array.prototype[b].apply(d[a + \"Data\"], Array.prototype.slice.call(f, 2));\n        };\n        d.parallelArrays.forEach(e);\n      },\n      autoIncrement: function autoIncrement() {\n        var a = this.options,\n            b = this.xIncrement,\n            d,\n            c = a.pointIntervalUnit,\n            e = this.chart.time,\n            b = f(b, a.pointStart, 0);\n        this.pointInterval = d = f(this.pointInterval, a.pointInterval, 1);\n        c && (a = new e.Date(b), \"day\" === c ? e.set(\"Date\", a, e.get(\"Date\", a) + d) : \"month\" === c ? e.set(\"Month\", a, e.get(\"Month\", a) + d) : \"year\" === c && e.set(\"FullYear\", a, e.get(\"FullYear\", a) + d), d = a.getTime() - b);\n        this.xIncrement = b + d;\n        return b;\n      },\n      setOptions: function setOptions(a) {\n        var d = this.chart,\n            c = d.options,\n            k = c.plotOptions,\n            e = (d.userOptions || {}).plotOptions || {},\n            q = k[this.type],\n            l = d.styledMode;\n        this.userOptions = a;\n        d = b(q, k.series, a);\n        this.tooltipOptions = b(r.tooltip, r.plotOptions.series && r.plotOptions.series.tooltip, r.plotOptions[this.type].tooltip, c.tooltip.userOptions, k.series && k.series.tooltip, k[this.type].tooltip, a.tooltip);\n        this.stickyTracking = f(a.stickyTracking, e[this.type] && e[this.type].stickyTracking, e.series && e.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : d.stickyTracking);\n        null === q.marker && delete d.marker;\n        this.zoneAxis = d.zoneAxis;\n        a = this.zones = (d.zones || []).slice();\n        !d.negativeColor && !d.negativeFillColor || d.zones || (c = {\n          value: d[this.zoneAxis + \"Threshold\"] || d.threshold || 0,\n          className: \"highcharts-negative\"\n        }, l || (c.color = d.negativeColor, c.fillColor = d.negativeFillColor), a.push(c));\n        a.length && v(a[a.length - 1].value) && a.push(l ? {} : {\n          color: this.color,\n          fillColor: this.fillColor\n        });\n        g(this, \"afterSetOptions\", {\n          options: d\n        });\n        return d;\n      },\n      getName: function getName() {\n        return f(this.options.name, \"Series \" + (this.index + 1));\n      },\n      getCyclic: function getCyclic(a, b, d) {\n        var c,\n            e = this.chart,\n            k = this.userOptions,\n            g = a + \"Index\",\n            l = a + \"Counter\",\n            m = d ? d.length : f(e.options.chart[a + \"Count\"], e[a + \"Count\"]);\n        b || (c = f(k[g], k[\"_\" + g]), v(c) || (e.series.length || (e[l] = 0), k[\"_\" + g] = c = e[l] % m, e[l] += 1), d && (b = d[c]));\n        void 0 !== c && (this[g] = c);\n        this[a] = b;\n      },\n      getColor: function getColor() {\n        this.chart.styledMode ? this.getCyclic(\"color\") : this.options.colorByPoint ? this.options.color = null : this.getCyclic(\"color\", this.options.color || u[this.type].color, this.chart.options.colors);\n      },\n      getSymbol: function getSymbol() {\n        this.getCyclic(\"symbol\", this.options.marker.symbol, this.chart.options.symbols);\n      },\n      drawLegendSymbol: a.LegendSymbolMixin.drawLineMarker,\n      updateData: function updateData(b) {\n        var d = this.options,\n            f = this.points,\n            c = [],\n            e,\n            k,\n            g,\n            l = this.requireSorting;\n        this.xIncrement = null;\n        b.forEach(function (b) {\n          var k, q, h;\n          k = a.defined(b) && this.pointClass.prototype.optionsToObject.call({\n            series: this\n          }, b) || {};\n          h = k.x;\n          if ((k = k.id) || m(h)) k && (q = (q = this.chart.get(k)) && q.x), void 0 === q && m(h) && (q = this.xData.indexOf(h, g)), -1 === q || void 0 === q || f[q].touched ? c.push(b) : b !== d.data[q] ? (f[q].update(b, !1, null, !1), f[q].touched = !0, l && (g = q + 1)) : f[q] && (f[q].touched = !0), e = !0;\n        }, this);\n        if (e) for (b = f.length; b--;) {\n          k = f[b], k.touched || k.remove(!1), k.touched = !1;\n        } else if (b.length === f.length) b.forEach(function (a, b) {\n          f[b].update && a !== d.data[b] && f[b].update(a, !1, null, !1);\n        });else return !1;\n        c.forEach(function (a) {\n          this.addPoint(a, !1);\n        }, this);\n        return !0;\n      },\n      setData: function setData(b, c, g, l) {\n        var e = this,\n            k = e.points,\n            h = k && k.length || 0,\n            A,\n            t = e.options,\n            n = e.chart,\n            D = null,\n            B = e.xAxis,\n            x = t.turboThreshold,\n            z = this.xData,\n            r = this.yData,\n            u = (A = e.pointArrayMap) && A.length,\n            v;\n        b = b || [];\n        A = b.length;\n        c = f(c, !0);\n        !1 !== l && A && h && !e.cropped && !e.hasGroupedData && e.visible && !e.isSeriesBoosting && (v = this.updateData(b));\n\n        if (!v) {\n          e.xIncrement = null;\n          e.colorCounter = 0;\n          this.parallelArrays.forEach(function (a) {\n            e[a + \"Data\"].length = 0;\n          });\n\n          if (x && A > x) {\n            for (g = 0; null === D && g < A;) {\n              D = b[g], g++;\n            }\n\n            if (m(D)) for (g = 0; g < A; g++) {\n              z[g] = this.autoIncrement(), r[g] = b[g];\n            } else if (d(D)) {\n              if (u) for (g = 0; g < A; g++) {\n                D = b[g], z[g] = D[0], r[g] = D.slice(1, u + 1);\n              } else for (g = 0; g < A; g++) {\n                D = b[g], z[g] = D[0], r[g] = D[1];\n              }\n            } else a.error(12, !1, n);\n          } else for (g = 0; g < A; g++) {\n            void 0 !== b[g] && (D = {\n              series: e\n            }, e.pointClass.prototype.applyOptions.apply(D, [b[g]]), e.updateParallelArrays(D, g));\n          }\n\n          r && p(r[0]) && a.error(14, !0, n);\n          e.data = [];\n          e.options.data = e.userOptions.data = b;\n\n          for (g = h; g--;) {\n            k[g] && k[g].destroy && k[g].destroy();\n          }\n\n          B && (B.minRange = B.userMinRange);\n          e.isDirty = n.isDirtyBox = !0;\n          e.isDirtyData = !!k;\n          g = !1;\n        }\n\n        \"point\" === t.legendType && (this.processData(), this.generatePoints());\n        c && n.redraw(g);\n      },\n      processData: function processData(b) {\n        var d = this.xData,\n            f = this.yData,\n            c = d.length,\n            e;\n        e = 0;\n        var k,\n            g,\n            l = this.xAxis,\n            m,\n            h = this.options;\n        m = h.cropThreshold;\n        var p = this.getExtremesFromAll || h.getExtremesFromAll,\n            t = this.isCartesian,\n            h = l && l.val2lin,\n            n = l && l.isLog,\n            x = this.requireSorting,\n            r,\n            z;\n        if (t && !this.isDirty && !l.isDirty && !this.yAxis.isDirty && !b) return !1;\n        l && (b = l.getExtremes(), r = b.min, z = b.max);\n        t && this.sorted && !p && (!m || c > m || this.forceCrop) && (d[c - 1] < r || d[0] > z ? (d = [], f = []) : this.yData && (d[0] < r || d[c - 1] > z) && (e = this.cropData(this.xData, this.yData, r, z), d = e.xData, f = e.yData, e = e.start, k = !0));\n\n        for (m = d.length || 1; --m;) {\n          c = n ? h(d[m]) - h(d[m - 1]) : d[m] - d[m - 1], 0 < c && (void 0 === g || c < g) ? g = c : 0 > c && x && (a.error(15, !1, this.chart), x = !1);\n        }\n\n        this.cropped = k;\n        this.cropStart = e;\n        this.processedXData = d;\n        this.processedYData = f;\n        this.closestPointRange = g;\n      },\n      cropData: function cropData(a, b, d, c, e) {\n        var k = a.length,\n            g = 0,\n            l = k,\n            m;\n        e = f(e, this.cropShoulder, 1);\n\n        for (m = 0; m < k; m++) {\n          if (a[m] >= d) {\n            g = Math.max(0, m - e);\n            break;\n          }\n        }\n\n        for (d = m; d < k; d++) {\n          if (a[d] > c) {\n            l = d + e;\n            break;\n          }\n        }\n\n        return {\n          xData: a.slice(g, l),\n          yData: b.slice(g, l),\n          start: g,\n          end: l\n        };\n      },\n      generatePoints: function generatePoints() {\n        var a = this.options,\n            b = a.data,\n            d = this.data,\n            f,\n            e = this.processedXData,\n            c = this.processedYData,\n            g = this.pointClass,\n            l = e.length,\n            m = this.cropStart || 0,\n            h,\n            p = this.hasGroupedData,\n            a = a.keys,\n            x,\n            r = [],\n            z;\n        d || p || (d = [], d.length = b.length, d = this.data = d);\n        a && p && (this.options.keys = !1);\n\n        for (z = 0; z < l; z++) {\n          h = m + z, p ? (x = new g().init(this, [e[z]].concat(t(c[z]))), x.dataGroup = this.groupMap[z], x.dataGroup.options && (x.options = x.dataGroup.options, n(x, x.dataGroup.options))) : (x = d[h]) || void 0 === b[h] || (d[h] = x = new g().init(this, b[h], e[z])), x && (x.index = h, r[z] = x);\n        }\n\n        this.options.keys = a;\n        if (d && (l !== (f = d.length) || p)) for (z = 0; z < f; z++) {\n          z !== m || p || (z += l), d[z] && (d[z].destroyElements(), d[z].plotX = void 0);\n        }\n        this.data = d;\n        this.points = r;\n      },\n      getExtremes: function getExtremes(a) {\n        var b = this.yAxis,\n            f = this.processedXData,\n            c,\n            e = [],\n            k = 0;\n        c = this.xAxis.getExtremes();\n        var g = c.min,\n            l = c.max,\n            p,\n            t,\n            n = this.requireSorting ? 1 : 0,\n            x,\n            z;\n        a = a || this.stackedYData || this.processedYData || [];\n        c = a.length;\n\n        for (z = 0; z < c; z++) {\n          if (t = f[z], x = a[z], p = (m(x, !0) || d(x)) && (!b.positiveValuesOnly || x.length || 0 < x), t = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || (f[z + n] || t) >= g && (f[z - n] || t) <= l, p && t) if (p = x.length) for (; p--;) {\n            \"number\" === typeof x[p] && (e[k++] = x[p]);\n          } else e[k++] = x;\n        }\n\n        this.dataMin = h(e);\n        this.dataMax = E(e);\n      },\n      translate: function translate() {\n        this.processedXData || this.processData();\n        this.generatePoints();\n        var a = this.options,\n            b = a.stacking,\n            d = this.xAxis,\n            l = d.categories,\n            e = this.yAxis,\n            q = this.points,\n            h = q.length,\n            p = !!this.modifyValue,\n            t = a.pointPlacement,\n            n = \"between\" === t || m(t),\n            x = a.threshold,\n            z = a.startFromThreshold ? x : 0,\n            r,\n            u,\n            F,\n            H,\n            w = Number.MAX_VALUE;\n        \"between\" === t && (t = .5);\n        m(t) && (t *= f(a.pointRange || d.pointRange));\n\n        for (a = 0; a < h; a++) {\n          var y = q[a],\n              E = y.x,\n              G = y.y;\n          u = y.low;\n          var J = b && e.stacks[(this.negStacks && G < (z ? 0 : x) ? \"-\" : \"\") + this.stackKey],\n              U;\n          e.positiveValuesOnly && null !== G && 0 >= G && (y.isNull = !0);\n          y.plotX = r = c(Math.min(Math.max(-1E5, d.translate(E, 0, 0, 0, 1, t, \"flags\" === this.type)), 1E5));\n          b && this.visible && !y.isNull && J && J[E] && (H = this.getStackIndicator(H, E, this.index), U = J[E], G = U.points[H.key], u = G[0], G = G[1], u === z && H.key === J[E].base && (u = f(m(x) && x, e.min)), e.positiveValuesOnly && 0 >= u && (u = null), y.total = y.stackTotal = U.total, y.percentage = U.total && y.y / U.total * 100, y.stackY = G, U.setOffset(this.pointXOffset || 0, this.barW || 0));\n          y.yBottom = v(u) ? Math.min(Math.max(-1E5, e.translate(u, 0, 1, 0, 1)), 1E5) : null;\n          p && (G = this.modifyValue(G, y));\n          y.plotY = u = \"number\" === typeof G && Infinity !== G ? Math.min(Math.max(-1E5, e.translate(G, 0, 1, 0, 1)), 1E5) : void 0;\n          y.isInside = void 0 !== u && 0 <= u && u <= e.len && 0 <= r && r <= d.len;\n          y.clientX = n ? c(d.translate(E, 0, 0, 0, 1, t)) : r;\n          y.negative = y.y < (x || 0);\n          y.category = l && void 0 !== l[y.x] ? l[y.x] : y.x;\n          y.isNull || (void 0 !== F && (w = Math.min(w, Math.abs(r - F))), F = r);\n          y.zone = this.zones.length && y.getZone();\n        }\n\n        this.closestPointRangePx = w;\n        g(this, \"afterTranslate\");\n      },\n      getValidPoints: function getValidPoints(a, b) {\n        var d = this.chart;\n        return (a || this.points || []).filter(function (a) {\n          return b && !d.isInsidePlot(a.plotX, a.plotY, d.inverted) ? !1 : !a.isNull;\n        });\n      },\n      setClip: function setClip(a) {\n        var b = this.chart,\n            d = this.options,\n            f = b.renderer,\n            e = b.inverted,\n            c = this.clipBox,\n            k = c || b.clipBox,\n            g = this.sharedClipKey || [\"_sharedClip\", a && a.duration, a && a.easing, k.height, d.xAxis, d.yAxis].join(),\n            l = b[g],\n            m = b[g + \"m\"];\n        l || (a && (k.width = 0, e && (k.x = b.plotSizeX), b[g + \"m\"] = m = f.clipRect(e ? b.plotSizeX + 99 : -99, e ? -b.plotLeft : -b.plotTop, 99, e ? b.chartWidth : b.chartHeight)), b[g] = l = f.clipRect(k), l.count = {\n          length: 0\n        });\n        a && !l.count[this.index] && (l.count[this.index] = !0, l.count.length += 1);\n        !1 !== d.clip && (this.group.clip(a || c ? l : b.clipRect), this.markerGroup.clip(m), this.sharedClipKey = g);\n        a || (l.count[this.index] && (delete l.count[this.index], --l.count.length), 0 === l.count.length && g && b[g] && (c || (b[g] = b[g].destroy()), b[g + \"m\"] && (b[g + \"m\"] = b[g + \"m\"].destroy())));\n      },\n      animate: function animate(a) {\n        var b = this.chart,\n            d = G(this.options.animation),\n            f;\n        a ? this.setClip(d) : (f = this.sharedClipKey, (a = b[f]) && a.animate({\n          width: b.plotSizeX,\n          x: 0\n        }, d), b[f + \"m\"] && b[f + \"m\"].animate({\n          width: b.plotSizeX + 99,\n          x: 0\n        }, d), this.animate = null);\n      },\n      afterAnimate: function afterAnimate() {\n        this.setClip();\n        g(this, \"afterAnimate\");\n        this.finishedAnimating = !0;\n      },\n      drawPoints: function drawPoints() {\n        var a = this.points,\n            b = this.chart,\n            d,\n            c,\n            e,\n            g,\n            l = this.options.marker,\n            m,\n            h,\n            p,\n            t = this[this.specialGroup] || this.markerGroup;\n        d = this.xAxis;\n        var n,\n            x = f(l.enabled, !d || d.isRadial ? !0 : null, this.closestPointRangePx >= l.enabledThreshold * l.radius);\n        if (!1 !== l.enabled || this._hasPointMarkers) for (d = 0; d < a.length; d++) {\n          c = a[d], g = c.graphic, m = c.marker || {}, h = !!c.marker, e = x && void 0 === m.enabled || m.enabled, p = !1 !== c.isInside, e && !c.isNull ? (e = f(m.symbol, this.symbol), n = this.markerAttribs(c, c.selected && \"select\"), g ? g[p ? \"show\" : \"hide\"](!0).animate(n) : p && (0 < n.width || c.hasImage) && (c.graphic = g = b.renderer.symbol(e, n.x, n.y, n.width, n.height, h ? m : l).add(t)), g && !b.styledMode && g.attr(this.pointAttribs(c, c.selected && \"select\")), g && g.addClass(c.getClassName(), !0)) : g && (c.graphic = g.destroy());\n        }\n      },\n      markerAttribs: function markerAttribs(a, b) {\n        var d = this.options.marker,\n            c = a.marker || {},\n            e = c.symbol || d.symbol,\n            k = f(c.radius, d.radius);\n        b && (d = d.states[b], b = c.states && c.states[b], k = f(b && b.radius, d && d.radius, k + (d && d.radiusPlus || 0)));\n        a.hasImage = e && 0 === e.indexOf(\"url\");\n        a.hasImage && (k = 0);\n        a = {\n          x: Math.floor(a.plotX) - k,\n          y: a.plotY - k\n        };\n        k && (a.width = a.height = 2 * k);\n        return a;\n      },\n      pointAttribs: function pointAttribs(a, b) {\n        var d = this.options.marker,\n            c = a && a.options,\n            e = c && c.marker || {},\n            k = this.color,\n            g = c && c.color,\n            l = a && a.color,\n            c = f(e.lineWidth, d.lineWidth);\n        a = a && a.zone && a.zone.color;\n        k = g || a || l || k;\n        a = e.fillColor || d.fillColor || k;\n        k = e.lineColor || d.lineColor || k;\n        b && (d = d.states[b], b = e.states && e.states[b] || {}, c = f(b.lineWidth, d.lineWidth, c + f(b.lineWidthPlus, d.lineWidthPlus, 0)), a = b.fillColor || d.fillColor || a, k = b.lineColor || d.lineColor || k);\n        return {\n          stroke: k,\n          \"stroke-width\": c,\n          fill: a\n        };\n      },\n      destroy: function destroy() {\n        var b = this,\n            d = b.chart,\n            f = /AppleWebKit\\/533/.test(z.navigator.userAgent),\n            c,\n            e,\n            q = b.data || [],\n            m,\n            h;\n        g(b, \"destroy\");\n        x(b);\n        (b.axisTypes || []).forEach(function (a) {\n          (h = b[a]) && h.series && (w(h.series, b), h.isDirty = h.forceRedraw = !0);\n        });\n        b.legendItem && b.chart.legend.destroyItem(b);\n\n        for (e = q.length; e--;) {\n          (m = q[e]) && m.destroy && m.destroy();\n        }\n\n        b.points = null;\n        a.clearTimeout(b.animationTimeout);\n        l(b, function (a, b) {\n          a instanceof H && !a.survive && (c = f && \"group\" === b ? \"hide\" : \"destroy\", a[c]());\n        });\n        d.hoverSeries === b && (d.hoverSeries = null);\n        w(d.series, b);\n        d.orderSeries();\n        l(b, function (a, e) {\n          delete b[e];\n        });\n      },\n      getGraphPath: function getGraphPath(a, b, d) {\n        var f = this,\n            e = f.options,\n            c = e.step,\n            g,\n            k = [],\n            l = [],\n            m;\n        a = a || f.points;\n        (g = a.reversed) && a.reverse();\n        (c = {\n          right: 1,\n          center: 2\n        }[c] || c && 3) && g && (c = 4 - c);\n        !e.connectNulls || b || d || (a = this.getValidPoints(a));\n        a.forEach(function (g, q) {\n          var h = g.plotX,\n              p = g.plotY,\n              t = a[q - 1];\n          (g.leftCliff || t && t.rightCliff) && !d && (m = !0);\n          g.isNull && !v(b) && 0 < q ? m = !e.connectNulls : g.isNull && !b ? m = !0 : (0 === q || m ? q = [\"M\", g.plotX, g.plotY] : f.getPointSpline ? q = f.getPointSpline(a, g, q) : c ? (q = 1 === c ? [\"L\", t.plotX, p] : 2 === c ? [\"L\", (t.plotX + h) / 2, t.plotY, \"L\", (t.plotX + h) / 2, p] : [\"L\", h, t.plotY], q.push(\"L\", h, p)) : q = [\"L\", h, p], l.push(g.x), c && (l.push(g.x), 2 === c && l.push(g.x)), k.push.apply(k, q), m = !1);\n        });\n        k.xMap = l;\n        return f.graphPath = k;\n      },\n      drawGraph: function drawGraph() {\n        var a = this,\n            b = this.options,\n            d = (this.gappedPath || this.getGraphPath).call(this),\n            f = this.chart.styledMode,\n            e = [[\"graph\", \"highcharts-graph\"]];\n        f || e[0].push(b.lineColor || this.color, b.dashStyle);\n        e = a.getZonesGraphs(e);\n        e.forEach(function (e, c) {\n          var g = e[0],\n              k = a[g];\n          k ? (k.endX = a.preventGraphAnimation ? null : d.xMap, k.animate({\n            d: d\n          })) : d.length && (a[g] = a.chart.renderer.path(d).addClass(e[1]).attr({\n            zIndex: 1\n          }).add(a.group), f || (k = {\n            stroke: e[2],\n            \"stroke-width\": b.lineWidth,\n            fill: a.fillGraph && a.color || \"none\"\n          }, e[3] ? k.dashstyle = e[3] : \"square\" !== b.linecap && (k[\"stroke-linecap\"] = k[\"stroke-linejoin\"] = \"round\"), k = a[g].attr(k).shadow(2 > c && b.shadow)));\n          k && (k.startX = d.xMap, k.isArea = d.isArea);\n        });\n      },\n      getZonesGraphs: function getZonesGraphs(a) {\n        this.zones.forEach(function (b, d) {\n          d = [\"zone-graph-\" + d, \"highcharts-graph highcharts-zone-graph-\" + d + \" \" + (b.className || \"\")];\n          this.chart.styledMode || d.push(b.color || this.color, b.dashStyle || this.options.dashStyle);\n          a.push(d);\n        }, this);\n        return a;\n      },\n      applyZones: function applyZones() {\n        var a = this,\n            b = this.chart,\n            d = b.renderer,\n            c = this.zones,\n            e,\n            g,\n            l = this.clips || [],\n            m,\n            h = this.graph,\n            p = this.area,\n            t = Math.max(b.chartWidth, b.chartHeight),\n            n = this[(this.zoneAxis || \"y\") + \"Axis\"],\n            x,\n            z,\n            r = b.inverted,\n            u,\n            v,\n            F,\n            H,\n            w = !1;\n        c.length && (h || p) && n && void 0 !== n.min && (z = n.reversed, u = n.horiz, h && !this.showLine && h.hide(), p && p.hide(), x = n.getExtremes(), c.forEach(function (c, k) {\n          e = z ? u ? b.plotWidth : 0 : u ? 0 : n.toPixels(x.min) || 0;\n          e = Math.min(Math.max(f(g, e), 0), t);\n          g = Math.min(Math.max(Math.round(n.toPixels(f(c.value, x.max), !0) || 0), 0), t);\n          w && (e = g = n.toPixels(x.max));\n          v = Math.abs(e - g);\n          F = Math.min(e, g);\n          H = Math.max(e, g);\n          n.isXAxis ? (m = {\n            x: r ? H : F,\n            y: 0,\n            width: v,\n            height: t\n          }, u || (m.x = b.plotHeight - m.x)) : (m = {\n            x: 0,\n            y: r ? H : F,\n            width: t,\n            height: v\n          }, u && (m.y = b.plotWidth - m.y));\n          r && d.isVML && (m = n.isXAxis ? {\n            x: 0,\n            y: z ? F : H,\n            height: m.width,\n            width: b.chartWidth\n          } : {\n            x: m.y - b.plotLeft - b.spacingBox.x,\n            y: 0,\n            width: m.height,\n            height: b.chartHeight\n          });\n          l[k] ? l[k].animate(m) : (l[k] = d.clipRect(m), h && a[\"zone-graph-\" + k].clip(l[k]), p && a[\"zone-area-\" + k].clip(l[k]));\n          w = c.value > x.max;\n          a.resetZones && 0 === g && (g = void 0);\n        }), this.clips = l);\n      },\n      invertGroups: function invertGroups(a) {\n        function b() {\n          [\"group\", \"markerGroup\"].forEach(function (b) {\n            d[b] && (f.renderer.isVML && d[b].attr({\n              width: d.yAxis.len,\n              height: d.xAxis.len\n            }), d[b].width = d.yAxis.len, d[b].height = d.xAxis.len, d[b].invert(a));\n          });\n        }\n\n        var d = this,\n            f = d.chart,\n            e;\n        d.xAxis && (e = y(f, \"resize\", b), y(d, \"destroy\", e), b(a), d.invertGroups = b);\n      },\n      plotGroup: function plotGroup(a, b, d, f, e) {\n        var c = this[a],\n            g = !c;\n        g && (this[a] = c = this.chart.renderer.g().attr({\n          zIndex: f || .1\n        }).add(e));\n        c.addClass(\"highcharts-\" + b + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (v(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (c.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0);\n        c.attr({\n          visibility: d\n        })[g ? \"attr\" : \"animate\"](this.getPlotBox());\n        return c;\n      },\n      getPlotBox: function getPlotBox() {\n        var a = this.chart,\n            b = this.xAxis,\n            d = this.yAxis;\n        a.inverted && (b = d, d = this.xAxis);\n        return {\n          translateX: b ? b.left : a.plotLeft,\n          translateY: d ? d.top : a.plotTop,\n          scaleX: 1,\n          scaleY: 1\n        };\n      },\n      render: function render() {\n        var a = this,\n            b = a.chart,\n            d,\n            f = a.options,\n            e = !!a.animate && b.renderer.isSVG && G(f.animation).duration,\n            c = a.visible ? \"inherit\" : \"hidden\",\n            l = f.zIndex,\n            m = a.hasRendered,\n            h = b.seriesGroup,\n            p = b.inverted;\n        d = a.plotGroup(\"group\", \"series\", c, l, h);\n        a.markerGroup = a.plotGroup(\"markerGroup\", \"markers\", c, l, h);\n        e && a.animate(!0);\n        d.inverted = a.isCartesian ? p : !1;\n        a.drawGraph && (a.drawGraph(), a.applyZones());\n        a.drawDataLabels && a.drawDataLabels();\n        a.visible && a.drawPoints();\n        a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();\n        a.invertGroups(p);\n        !1 === f.clip || a.sharedClipKey || m || d.clip(b.clipRect);\n        e && a.animate();\n        m || (a.animationTimeout = F(function () {\n          a.afterAnimate();\n        }, e));\n        a.isDirty = !1;\n        a.hasRendered = !0;\n        g(a, \"afterRender\");\n      },\n      redraw: function redraw() {\n        var a = this.chart,\n            b = this.isDirty || this.isDirtyData,\n            d = this.group,\n            c = this.xAxis,\n            e = this.yAxis;\n        d && (a.inverted && d.attr({\n          width: a.plotWidth,\n          height: a.plotHeight\n        }), d.animate({\n          translateX: f(c && c.left, a.plotLeft),\n          translateY: f(e && e.top, a.plotTop)\n        }));\n        this.translate();\n        this.render();\n        b && delete this.kdTree;\n      },\n      kdAxisArray: [\"clientX\", \"plotY\"],\n      searchPoint: function searchPoint(a, b) {\n        var d = this.xAxis,\n            f = this.yAxis,\n            e = this.chart.inverted;\n        return this.searchKDTree({\n          clientX: e ? d.len - a.chartY + d.pos : a.chartX - d.pos,\n          plotY: e ? f.len - a.chartX + f.pos : a.chartY - f.pos\n        }, b);\n      },\n      buildKDTree: function buildKDTree() {\n        function a(d, e, f) {\n          var c, g;\n          if (g = d && d.length) return c = b.kdAxisArray[e % f], d.sort(function (a, b) {\n            return a[c] - b[c];\n          }), g = Math.floor(g / 2), {\n            point: d[g],\n            left: a(d.slice(0, g), e + 1, f),\n            right: a(d.slice(g + 1), e + 1, f)\n          };\n        }\n\n        this.buildingKdTree = !0;\n        var b = this,\n            d = -1 < b.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        delete b.kdTree;\n        F(function () {\n          b.kdTree = a(b.getValidPoints(null, !b.directTouch), d, d);\n          b.buildingKdTree = !1;\n        }, b.options.kdNow ? 0 : 1);\n      },\n      searchKDTree: function searchKDTree(a, b) {\n        function d(a, b, k, l) {\n          var m = b.point,\n              h = f.kdAxisArray[k % l],\n              q,\n              p,\n              t = m;\n          p = v(a[e]) && v(m[e]) ? Math.pow(a[e] - m[e], 2) : null;\n          q = v(a[c]) && v(m[c]) ? Math.pow(a[c] - m[c], 2) : null;\n          q = (p || 0) + (q || 0);\n          m.dist = v(q) ? Math.sqrt(q) : Number.MAX_VALUE;\n          m.distX = v(p) ? Math.sqrt(p) : Number.MAX_VALUE;\n          h = a[h] - m[h];\n          q = 0 > h ? \"left\" : \"right\";\n          p = 0 > h ? \"right\" : \"left\";\n          b[q] && (q = d(a, b[q], k + 1, l), t = q[g] < t[g] ? q : m);\n          b[p] && Math.sqrt(h * h) < t[g] && (a = d(a, b[p], k + 1, l), t = a[g] < t[g] ? a : t);\n          return t;\n        }\n\n        var f = this,\n            e = this.kdAxisArray[0],\n            c = this.kdAxisArray[1],\n            g = b ? \"distX\" : \"dist\";\n        b = -1 < f.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        this.kdTree || this.buildingKdTree || this.buildKDTree();\n        if (this.kdTree) return d(a, this.kdTree, b, b);\n      }\n    });\n  })(J);\n\n  (function (a) {\n    var y = a.Axis,\n        G = a.Chart,\n        E = a.correctFloat,\n        h = a.defined,\n        c = a.destroyObjectProperties,\n        r = a.format,\n        u = a.objectEach,\n        v = a.pick,\n        w = a.Series;\n\n    a.StackItem = function (a, c, d, m, h) {\n      var b = a.chart.inverted;\n      this.axis = a;\n      this.isNegative = d;\n      this.options = c;\n      this.x = m;\n      this.total = null;\n      this.points = {};\n      this.stack = h;\n      this.rightCliff = this.leftCliff = 0;\n      this.alignOptions = {\n        align: c.align || (b ? d ? \"left\" : \"right\" : \"center\"),\n        verticalAlign: c.verticalAlign || (b ? \"middle\" : d ? \"bottom\" : \"top\"),\n        y: v(c.y, b ? 4 : d ? 14 : -6),\n        x: v(c.x, b ? d ? -6 : 6 : 0)\n      };\n      this.textAlign = c.textAlign || (b ? d ? \"right\" : \"left\" : \"center\");\n    };\n\n    a.StackItem.prototype = {\n      destroy: function destroy() {\n        c(this, this.axis);\n      },\n      render: function render(a) {\n        var c = this.axis.chart,\n            d = this.options,\n            m = d.format,\n            m = m ? r(m, this, c.time) : d.formatter.call(this);\n        this.label ? this.label.attr({\n          text: m,\n          visibility: \"hidden\"\n        }) : this.label = c.renderer.text(m, null, null, d.useHTML).css(d.style).attr({\n          align: this.textAlign,\n          rotation: d.rotation,\n          visibility: \"hidden\"\n        }).add(a);\n        this.label.labelrank = c.plotHeight;\n      },\n      setOffset: function setOffset(a, c) {\n        var d = this.axis,\n            g = d.chart,\n            p = d.translate(d.usePercentage ? 100 : this.total, 0, 0, 0, 1),\n            b = d.translate(0),\n            b = h(p) && Math.abs(p - b);\n        a = g.xAxis[0].translate(this.x) + a;\n        d = h(p) && this.getStackBox(g, this, a, p, c, b, d);\n        (c = this.label) && d && (c.align(this.alignOptions, null, d), d = c.alignAttr, c[!1 === this.options.crop || g.isInsidePlot(d.x, d.y) ? \"show\" : \"hide\"](!0));\n      },\n      getStackBox: function getStackBox(a, c, d, m, h, b, l) {\n        var f = c.axis.reversed,\n            g = a.inverted;\n        a = l.height + l.pos - (g ? a.plotLeft : a.plotTop);\n        c = c.isNegative && !f || !c.isNegative && f;\n        return {\n          x: g ? c ? m : m - b : d,\n          y: g ? a - d - h : c ? a - m - b : a - m,\n          width: g ? b : h,\n          height: g ? h : b\n        };\n      }\n    };\n\n    G.prototype.getStacks = function () {\n      var a = this;\n      a.yAxis.forEach(function (a) {\n        a.stacks && a.hasVisibleSeries && (a.oldStacks = a.stacks);\n      });\n      a.series.forEach(function (c) {\n        !c.options.stacking || !0 !== c.visible && !1 !== a.options.chart.ignoreHiddenSeries || (c.stackKey = c.type + v(c.options.stack, \"\"));\n      });\n    };\n\n    y.prototype.buildStacks = function () {\n      var a = this.series,\n          c = v(this.options.reversedStacks, !0),\n          d = a.length,\n          m;\n\n      if (!this.isXAxis) {\n        this.usePercentage = !1;\n\n        for (m = d; m--;) {\n          a[c ? m : d - m - 1].setStackedPoints();\n        }\n\n        for (m = 0; m < d; m++) {\n          a[m].modifyStacks();\n        }\n      }\n    };\n\n    y.prototype.renderStackTotals = function () {\n      var a = this.chart,\n          c = a.renderer,\n          d = this.stacks,\n          m = this.stackTotalGroup;\n      m || (this.stackTotalGroup = m = c.g(\"stack-labels\").attr({\n        visibility: \"visible\",\n        zIndex: 6\n      }).add());\n      m.translate(a.plotLeft, a.plotTop);\n      u(d, function (a) {\n        u(a, function (a) {\n          a.render(m);\n        });\n      });\n    };\n\n    y.prototype.resetStacks = function () {\n      var a = this,\n          c = a.stacks;\n      a.isXAxis || u(c, function (d) {\n        u(d, function (c, g) {\n          c.touched < a.stacksTouched ? (c.destroy(), delete d[g]) : (c.total = null, c.cumulative = null);\n        });\n      });\n    };\n\n    y.prototype.cleanStacks = function () {\n      var a;\n      this.isXAxis || (this.oldStacks && (a = this.stacks = this.oldStacks), u(a, function (a) {\n        u(a, function (a) {\n          a.cumulative = a.total;\n        });\n      }));\n    };\n\n    w.prototype.setStackedPoints = function () {\n      if (this.options.stacking && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {\n        var c = this.processedXData,\n            g = this.processedYData,\n            d = [],\n            m = g.length,\n            p = this.options,\n            b = p.threshold,\n            l = v(p.startFromThreshold && b, 0),\n            f = p.stack,\n            p = p.stacking,\n            x = this.stackKey,\n            t = \"-\" + x,\n            r = this.negStacks,\n            u = this.yAxis,\n            z = u.stacks,\n            k = u.oldStacks,\n            A,\n            D,\n            B,\n            e,\n            q,\n            w,\n            y;\n        u.stacksTouched += 1;\n\n        for (q = 0; q < m; q++) {\n          w = c[q], y = g[q], A = this.getStackIndicator(A, w, this.index), e = A.key, B = (D = r && y < (l ? 0 : b)) ? t : x, z[B] || (z[B] = {}), z[B][w] || (k[B] && k[B][w] ? (z[B][w] = k[B][w], z[B][w].total = null) : z[B][w] = new a.StackItem(u, u.options.stackLabels, D, w, f)), B = z[B][w], null !== y ? (B.points[e] = B.points[this.index] = [v(B.cumulative, l)], h(B.cumulative) || (B.base = e), B.touched = u.stacksTouched, 0 < A.index && !1 === this.singleStacks && (B.points[e][0] = B.points[this.index + \",\" + w + \",0\"][0])) : B.points[e] = B.points[this.index] = null, \"percent\" === p ? (D = D ? x : t, r && z[D] && z[D][w] ? (D = z[D][w], B.total = D.total = Math.max(D.total, B.total) + Math.abs(y) || 0) : B.total = E(B.total + (Math.abs(y) || 0))) : B.total = E(B.total + (y || 0)), B.cumulative = v(B.cumulative, l) + (y || 0), null !== y && (B.points[e].push(B.cumulative), d[q] = B.cumulative);\n        }\n\n        \"percent\" === p && (u.usePercentage = !0);\n        this.stackedYData = d;\n        u.oldStacks = {};\n      }\n    };\n\n    w.prototype.modifyStacks = function () {\n      var a = this,\n          c = a.stackKey,\n          d = a.yAxis.stacks,\n          m = a.processedXData,\n          h,\n          b = a.options.stacking;\n      a[b + \"Stacker\"] && [c, \"-\" + c].forEach(function (c) {\n        for (var f = m.length, g, l; f--;) {\n          if (g = m[f], h = a.getStackIndicator(h, g, a.index, c), l = (g = d[c] && d[c][g]) && g.points[h.key]) a[b + \"Stacker\"](l, g, f);\n        }\n      });\n    };\n\n    w.prototype.percentStacker = function (a, c, d) {\n      c = c.total ? 100 / c.total : 0;\n      a[0] = E(a[0] * c);\n      a[1] = E(a[1] * c);\n      this.stackedYData[d] = a[1];\n    };\n\n    w.prototype.getStackIndicator = function (a, c, d, m) {\n      !h(a) || a.x !== c || m && a.key !== m ? a = {\n        x: c,\n        index: 0,\n        key: m\n      } : a.index++;\n      a.key = [d, c, a.index].join();\n      return a;\n    };\n  })(J);\n\n  (function (a) {\n    var y = a.addEvent,\n        G = a.animate,\n        E = a.Axis,\n        h = a.Chart,\n        c = a.createElement,\n        r = a.css,\n        u = a.defined,\n        v = a.erase,\n        w = a.extend,\n        n = a.fireEvent,\n        g = a.isNumber,\n        d = a.isObject,\n        m = a.isArray,\n        p = a.merge,\n        b = a.objectEach,\n        l = a.pick,\n        f = a.Point,\n        x = a.Series,\n        t = a.seriesTypes,\n        H = a.setAnimation,\n        F = a.splat;\n\n    a.cleanRecursively = function (c, f) {\n      var g = {};\n      b(c, function (b, k) {\n        if (d(c[k], !0) && f[k]) b = a.cleanRecursively(c[k], f[k]), Object.keys(b).length && (g[k] = b);else if (d(c[k]) || c[k] !== f[k]) g[k] = c[k];\n      });\n      return g;\n    };\n\n    w(h.prototype, {\n      addSeries: function addSeries(a, b, d) {\n        var c,\n            f = this;\n        a && (b = l(b, !0), n(f, \"addSeries\", {\n          options: a\n        }, function () {\n          c = f.initSeries(a);\n          f.isDirtyLegend = !0;\n          f.linkSeries();\n          n(f, \"afterAddSeries\");\n          b && f.redraw(d);\n        }));\n        return c;\n      },\n      addAxis: function addAxis(a, b, d, c) {\n        var f = b ? \"xAxis\" : \"yAxis\",\n            e = this.options;\n        a = p(a, {\n          index: this[f].length,\n          isX: b\n        });\n        b = new E(this, a);\n        e[f] = F(e[f] || {});\n        e[f].push(a);\n        l(d, !0) && this.redraw(c);\n        return b;\n      },\n      showLoading: function showLoading(a) {\n        var b = this,\n            d = b.options,\n            f = b.loadingDiv,\n            g = d.loading,\n            e = function e() {\n          f && r(f, {\n            left: b.plotLeft + \"px\",\n            top: b.plotTop + \"px\",\n            width: b.plotWidth + \"px\",\n            height: b.plotHeight + \"px\"\n          });\n        };\n\n        f || (b.loadingDiv = f = c(\"div\", {\n          className: \"highcharts-loading highcharts-loading-hidden\"\n        }, null, b.container), b.loadingSpan = c(\"span\", {\n          className: \"highcharts-loading-inner\"\n        }, null, f), y(b, \"redraw\", e));\n        f.className = \"highcharts-loading\";\n        b.loadingSpan.innerHTML = a || d.lang.loading;\n        b.styledMode || (r(f, w(g.style, {\n          zIndex: 10\n        })), r(b.loadingSpan, g.labelStyle), b.loadingShown || (r(f, {\n          opacity: 0,\n          display: \"\"\n        }), G(f, {\n          opacity: g.style.opacity || .5\n        }, {\n          duration: g.showDuration || 0\n        })));\n        b.loadingShown = !0;\n        e();\n      },\n      hideLoading: function hideLoading() {\n        var a = this.options,\n            b = this.loadingDiv;\n        b && (b.className = \"highcharts-loading highcharts-loading-hidden\", this.styledMode || G(b, {\n          opacity: 0\n        }, {\n          duration: a.loading.hideDuration || 100,\n          complete: function complete() {\n            r(b, {\n              display: \"none\"\n            });\n          }\n        }));\n        this.loadingShown = !1;\n      },\n      propsRequireDirtyBox: \"backgroundColor borderColor borderWidth margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow\".split(\" \"),\n      propsRequireUpdateSeries: \"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip\".split(\" \"),\n      collectionsWithUpdate: \"xAxis yAxis zAxis series colorAxis pane\".split(\" \"),\n      update: function update(d, c, f, m) {\n        var k = this,\n            e = {\n          credits: \"addCredits\",\n          title: \"setTitle\",\n          subtitle: \"setSubtitle\"\n        },\n            h,\n            t,\n            x,\n            r = [];\n        n(k, \"update\", {\n          options: d\n        });\n        d = a.cleanRecursively(d, k.options);\n\n        if (h = d.chart) {\n          p(!0, k.options.chart, h);\n          \"className\" in h && k.setClassName(h.className);\n          \"reflow\" in h && k.setReflow(h.reflow);\n          if (\"inverted\" in h || \"polar\" in h || \"type\" in h) k.propFromSeries(), t = !0;\n          \"alignTicks\" in h && (t = !0);\n          b(h, function (a, b) {\n            -1 !== k.propsRequireUpdateSeries.indexOf(\"chart.\" + b) && (x = !0);\n            -1 !== k.propsRequireDirtyBox.indexOf(b) && (k.isDirtyBox = !0);\n          });\n          !k.styledMode && \"style\" in h && k.renderer.setStyle(h.style);\n        }\n\n        !k.styledMode && d.colors && (this.options.colors = d.colors);\n        d.plotOptions && p(!0, this.options.plotOptions, d.plotOptions);\n        b(d, function (a, b) {\n          if (k[b] && \"function\" === typeof k[b].update) k[b].update(a, !1);else if (\"function\" === typeof k[e[b]]) k[e[b]](a);\n          \"chart\" !== b && -1 !== k.propsRequireUpdateSeries.indexOf(b) && (x = !0);\n        });\n        this.collectionsWithUpdate.forEach(function (a) {\n          var b;\n          d[a] && (\"series\" === a && (b = [], k[a].forEach(function (a, d) {\n            a.options.isInternal || b.push(l(a.options.index, d));\n          })), F(d[a]).forEach(function (d, e) {\n            (e = u(d.id) && k.get(d.id) || k[a][b ? b[e] : e]) && e.coll === a && (e.update(d, !1), f && (e.touched = !0));\n            if (!e && f) if (\"series\" === a) k.addSeries(d, !1).touched = !0;else if (\"xAxis\" === a || \"yAxis\" === a) k.addAxis(d, \"xAxis\" === a, !1).touched = !0;\n          }), f && k[a].forEach(function (a) {\n            a.touched || a.options.isInternal ? delete a.touched : r.push(a);\n          }));\n        });\n        r.forEach(function (a) {\n          a.remove && a.remove(!1);\n        });\n        t && k.axes.forEach(function (a) {\n          a.update({}, !1);\n        });\n        x && k.series.forEach(function (a) {\n          a.update({}, !1);\n        });\n        d.loading && p(!0, k.options.loading, d.loading);\n        t = h && h.width;\n        h = h && h.height;\n        g(t) && t !== k.chartWidth || g(h) && h !== k.chartHeight ? k.setSize(t, h, m) : l(c, !0) && k.redraw(m);\n        n(k, \"afterUpdate\", {\n          options: d\n        });\n      },\n      setSubtitle: function setSubtitle(a) {\n        this.setTitle(void 0, a);\n      }\n    });\n    w(f.prototype, {\n      update: function update(a, b, c, f) {\n        function g() {\n          e.applyOptions(a);\n          null === e.y && h && (e.graphic = h.destroy());\n          d(a, !0) && (h && h.element && a && a.marker && void 0 !== a.marker.symbol && (e.graphic = h.destroy()), a && a.dataLabels && e.dataLabel && (e.dataLabel = e.dataLabel.destroy()), e.connector && (e.connector = e.connector.destroy()));\n          m = e.index;\n          k.updateParallelArrays(e, m);\n          t.data[m] = d(t.data[m], !0) || d(a, !0) ? e.options : l(a, t.data[m]);\n          k.isDirty = k.isDirtyData = !0;\n          !k.fixedBox && k.hasCartesianSeries && (p.isDirtyBox = !0);\n          \"point\" === t.legendType && (p.isDirtyLegend = !0);\n          b && p.redraw(c);\n        }\n\n        var e = this,\n            k = e.series,\n            h = e.graphic,\n            m,\n            p = k.chart,\n            t = k.options;\n        b = l(b, !0);\n        !1 === f ? g() : e.firePointEvent(\"update\", {\n          options: a\n        }, g);\n      },\n      remove: function remove(a, b) {\n        this.series.removePoint(this.series.data.indexOf(this), a, b);\n      }\n    });\n    w(x.prototype, {\n      addPoint: function addPoint(a, b, d, c) {\n        var f = this.options,\n            e = this.data,\n            g = this.chart,\n            k = this.xAxis,\n            k = k && k.hasNames && k.names,\n            h = f.data,\n            m,\n            p,\n            t = this.xData,\n            n,\n            x;\n        b = l(b, !0);\n        m = {\n          series: this\n        };\n        this.pointClass.prototype.applyOptions.apply(m, [a]);\n        x = m.x;\n        n = t.length;\n        if (this.requireSorting && x < t[n - 1]) for (p = !0; n && t[n - 1] > x;) {\n          n--;\n        }\n        this.updateParallelArrays(m, \"splice\", n, 0, 0);\n        this.updateParallelArrays(m, n);\n        k && m.name && (k[x] = m.name);\n        h.splice(n, 0, a);\n        p && (this.data.splice(n, 0, null), this.processData());\n        \"point\" === f.legendType && this.generatePoints();\n        d && (e[0] && e[0].remove ? e[0].remove(!1) : (e.shift(), this.updateParallelArrays(m, \"shift\"), h.shift()));\n        this.isDirtyData = this.isDirty = !0;\n        b && g.redraw(c);\n      },\n      removePoint: function removePoint(a, b, d) {\n        var c = this,\n            f = c.data,\n            e = f[a],\n            g = c.points,\n            k = c.chart,\n            h = function h() {\n          g && g.length === f.length && g.splice(a, 1);\n          f.splice(a, 1);\n          c.options.data.splice(a, 1);\n          c.updateParallelArrays(e || {\n            series: c\n          }, \"splice\", a, 1);\n          e && e.destroy();\n          c.isDirty = !0;\n          c.isDirtyData = !0;\n          b && k.redraw();\n        };\n\n        H(d, k);\n        b = l(b, !0);\n        e ? e.firePointEvent(\"remove\", null, h) : h();\n      },\n      remove: function remove(a, b, d) {\n        function c() {\n          f.destroy();\n          f.remove = null;\n          e.isDirtyLegend = e.isDirtyBox = !0;\n          e.linkSeries();\n          l(a, !0) && e.redraw(b);\n        }\n\n        var f = this,\n            e = f.chart;\n        !1 !== d ? n(f, \"remove\", null, c) : c();\n      },\n      update: function update(b, d) {\n        b = a.cleanRecursively(b, this.userOptions);\n        var c = this,\n            f = c.chart,\n            g = c.userOptions,\n            e = c.oldType || c.type,\n            k = b.type || g.type || f.options.chart.type,\n            h = t[e].prototype,\n            m,\n            x = [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n            r = [\"navigatorSeries\", \"baseSeries\"],\n            u = c.finishedAnimating && {\n          animation: !1\n        },\n            z = [\"data\", \"name\", \"turboThreshold\"],\n            v = Object.keys(b),\n            F = 0 < v.length;\n        v.forEach(function (a) {\n          -1 === z.indexOf(a) && (F = !1);\n        });\n        if (F) b.data && this.setData(b.data, !1), b.name && this.setName(b.name, !1);else {\n          r = x.concat(r);\n          r.forEach(function (a) {\n            r[a] = c[a];\n            delete c[a];\n          });\n          b = p(g, u, {\n            index: c.index,\n            pointStart: l(g.pointStart, c.xData[0])\n          }, {\n            data: c.options.data\n          }, b);\n          c.remove(!1, null, !1);\n\n          for (m in h) {\n            c[m] = void 0;\n          }\n\n          t[k || e] ? w(c, t[k || e].prototype) : a.error(17, !0, f);\n          r.forEach(function (a) {\n            c[a] = r[a];\n          });\n          c.init(f, b);\n          b.zIndex !== g.zIndex && x.forEach(function (a) {\n            c[a] && c[a].attr({\n              zIndex: b.zIndex\n            });\n          });\n          c.oldType = e;\n          f.linkSeries();\n        }\n        n(this, \"afterUpdate\");\n        l(d, !0) && f.redraw(F ? void 0 : !1);\n      },\n      setName: function setName(a) {\n        this.name = this.options.name = this.userOptions.name = a;\n        this.chart.isDirtyLegend = !0;\n      }\n    });\n    w(E.prototype, {\n      update: function update(a, d) {\n        var c = this.chart,\n            f = a && a.events || {};\n        a = p(this.userOptions, a);\n        c.options[this.coll].indexOf && (c.options[this.coll][c.options[this.coll].indexOf(this.userOptions)] = a);\n        b(c.options[this.coll].events, function (a, b) {\n          \"undefined\" === typeof f[b] && (f[b] = void 0);\n        });\n        this.destroy(!0);\n        this.init(c, w(a, {\n          events: f\n        }));\n        c.isDirtyBox = !0;\n        l(d, !0) && c.redraw();\n      },\n      remove: function remove(a) {\n        for (var b = this.chart, d = this.coll, c = this.series, f = c.length; f--;) {\n          c[f] && c[f].remove(!1);\n        }\n\n        v(b.axes, this);\n        v(b[d], this);\n        m(b.options[d]) ? b.options[d].splice(this.options.index, 1) : delete b.options[d];\n        b[d].forEach(function (a, b) {\n          a.options.index = a.userOptions.index = b;\n        });\n        this.destroy();\n        b.isDirtyBox = !0;\n        l(a, !0) && b.redraw();\n      },\n      setTitle: function setTitle(a, b) {\n        this.update({\n          title: a\n        }, b);\n      },\n      setCategories: function setCategories(a, b) {\n        this.update({\n          categories: a\n        }, b);\n      }\n    });\n  })(J);\n\n  (function (a) {\n    var y = a.color,\n        G = a.pick,\n        E = a.Series,\n        h = a.seriesType;\n    h(\"area\", \"line\", {\n      softThreshold: !1,\n      threshold: 0\n    }, {\n      singleStacks: !1,\n      getStackPoints: function getStackPoints(c) {\n        var h = [],\n            u = [],\n            v = this.xAxis,\n            w = this.yAxis,\n            n = w.stacks[this.stackKey],\n            g = {},\n            d = this.index,\n            m = w.series,\n            p = m.length,\n            b,\n            l = G(w.options.reversedStacks, !0) ? 1 : -1,\n            f;\n        c = c || this.points;\n\n        if (this.options.stacking) {\n          for (f = 0; f < c.length; f++) {\n            c[f].leftNull = c[f].rightNull = null, g[c[f].x] = c[f];\n          }\n\n          a.objectEach(n, function (a, b) {\n            null !== a.total && u.push(b);\n          });\n          u.sort(function (a, b) {\n            return a - b;\n          });\n          b = m.map(function (a) {\n            return a.visible;\n          });\n          u.forEach(function (a, c) {\n            var m = 0,\n                t,\n                x;\n            if (g[a] && !g[a].isNull) h.push(g[a]), [-1, 1].forEach(function (k) {\n              var h = 1 === k ? \"rightNull\" : \"leftNull\",\n                  m = 0,\n                  r = n[u[c + k]];\n              if (r) for (f = d; 0 <= f && f < p;) {\n                t = r.points[f], t || (f === d ? g[a][h] = !0 : b[f] && (x = n[a].points[f]) && (m -= x[1] - x[0])), f += l;\n              }\n              g[a][1 === k ? \"rightCliff\" : \"leftCliff\"] = m;\n            });else {\n              for (f = d; 0 <= f && f < p;) {\n                if (t = n[a].points[f]) {\n                  m = t[1];\n                  break;\n                }\n\n                f += l;\n              }\n\n              m = w.translate(m, 0, 1, 0, 1);\n              h.push({\n                isNull: !0,\n                plotX: v.translate(a, 0, 0, 0, 1),\n                x: a,\n                plotY: m,\n                yBottom: m\n              });\n            }\n          });\n        }\n\n        return h;\n      },\n      getGraphPath: function getGraphPath(a) {\n        var c = E.prototype.getGraphPath,\n            h = this.options,\n            v = h.stacking,\n            w = this.yAxis,\n            n,\n            g,\n            d = [],\n            m = [],\n            p = this.index,\n            b,\n            l = w.stacks[this.stackKey],\n            f = h.threshold,\n            x = w.getThreshold(h.threshold),\n            t,\n            h = h.connectNulls || \"percent\" === v,\n            H = function H(c, g, k) {\n          var h = a[c];\n          c = v && l[h.x].points[p];\n          var t = h[k + \"Null\"] || 0;\n          k = h[k + \"Cliff\"] || 0;\n          var n,\n              e,\n              h = !0;\n          k || t ? (n = (t ? c[0] : c[1]) + k, e = c[0] + k, h = !!t) : !v && a[g] && a[g].isNull && (n = e = f);\n          void 0 !== n && (m.push({\n            plotX: b,\n            plotY: null === n ? x : w.getThreshold(n),\n            isNull: h,\n            isCliff: !0\n          }), d.push({\n            plotX: b,\n            plotY: null === e ? x : w.getThreshold(e),\n            doCurve: !1\n          }));\n        };\n\n        a = a || this.points;\n        v && (a = this.getStackPoints(a));\n\n        for (n = 0; n < a.length; n++) {\n          if (g = a[n].isNull, b = G(a[n].rectPlotX, a[n].plotX), t = G(a[n].yBottom, x), !g || h) h || H(n, n - 1, \"left\"), g && !v && h || (m.push(a[n]), d.push({\n            x: n,\n            plotX: b,\n            plotY: t\n          })), h || H(n, n + 1, \"right\");\n        }\n\n        n = c.call(this, m, !0, !0);\n        d.reversed = !0;\n        g = c.call(this, d, !0, !0);\n        g.length && (g[0] = \"L\");\n        g = n.concat(g);\n        c = c.call(this, m, !1, h);\n        g.xMap = n.xMap;\n        this.areaPath = g;\n        return c;\n      },\n      drawGraph: function drawGraph() {\n        this.areaPath = [];\n        E.prototype.drawGraph.apply(this);\n        var a = this,\n            h = this.areaPath,\n            u = this.options,\n            v = [[\"area\", \"highcharts-area\", this.color, u.fillColor]];\n        this.zones.forEach(function (c, h) {\n          v.push([\"zone-area-\" + h, \"highcharts-area highcharts-zone-area-\" + h + \" \" + c.className, c.color || a.color, c.fillColor || u.fillColor]);\n        });\n        v.forEach(function (c) {\n          var n = c[0],\n              g = a[n];\n          g ? (g.endX = a.preventGraphAnimation ? null : h.xMap, g.animate({\n            d: h\n          })) : (g = {\n            zIndex: 0\n          }, a.chart.styledMode || (g.fill = G(c[3], y(c[2]).setOpacity(G(u.fillOpacity, .75)).get())), g = a[n] = a.chart.renderer.path(h).addClass(c[1]).attr(g).add(a.group), g.isArea = !0);\n          g.startX = h.xMap;\n          g.shiftUnit = u.step ? 2 : 1;\n        });\n      },\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle\n    });\n  })(J);\n\n  (function (a) {\n    var y = a.pick;\n    a = a.seriesType;\n    a(\"spline\", \"line\", {}, {\n      getPointSpline: function getPointSpline(a, E, h) {\n        var c = E.plotX,\n            r = E.plotY,\n            u = a[h - 1];\n        h = a[h + 1];\n        var v, w, n, g;\n\n        if (u && !u.isNull && !1 !== u.doCurve && !E.isCliff && h && !h.isNull && !1 !== h.doCurve && !E.isCliff) {\n          a = u.plotY;\n          n = h.plotX;\n          h = h.plotY;\n          var d = 0;\n          v = (1.5 * c + u.plotX) / 2.5;\n          w = (1.5 * r + a) / 2.5;\n          n = (1.5 * c + n) / 2.5;\n          g = (1.5 * r + h) / 2.5;\n          n !== v && (d = (g - w) * (n - c) / (n - v) + r - g);\n          w += d;\n          g += d;\n          w > a && w > r ? (w = Math.max(a, r), g = 2 * r - w) : w < a && w < r && (w = Math.min(a, r), g = 2 * r - w);\n          g > h && g > r ? (g = Math.max(h, r), w = 2 * r - g) : g < h && g < r && (g = Math.min(h, r), w = 2 * r - g);\n          E.rightContX = n;\n          E.rightContY = g;\n        }\n\n        E = [\"C\", y(u.rightContX, u.plotX), y(u.rightContY, u.plotY), y(v, c), y(w, r), c, r];\n        u.rightContX = u.rightContY = null;\n        return E;\n      }\n    });\n  })(J);\n\n  (function (a) {\n    var y = a.seriesTypes.area.prototype,\n        G = a.seriesType;\n    G(\"areaspline\", \"spline\", a.defaultPlotOptions.area, {\n      getStackPoints: y.getStackPoints,\n      getGraphPath: y.getGraphPath,\n      drawGraph: y.drawGraph,\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle\n    });\n  })(J);\n\n  (function (a) {\n    var y = a.animObject,\n        G = a.color,\n        E = a.extend,\n        h = a.defined,\n        c = a.isNumber,\n        r = a.merge,\n        u = a.pick,\n        v = a.Series,\n        w = a.seriesType,\n        n = a.svg;\n    w(\"column\", \"line\", {\n      borderRadius: 0,\n      crisp: !0,\n      groupPadding: .2,\n      marker: null,\n      pointPadding: .1,\n      minPointLength: 0,\n      cropThreshold: 50,\n      pointRange: null,\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .1\n        },\n        select: {\n          color: \"#cccccc\",\n          borderColor: \"#000000\"\n        }\n      },\n      dataLabels: {\n        align: null,\n        verticalAlign: null,\n        y: null\n      },\n      softThreshold: !1,\n      startFromThreshold: !0,\n      stickyTracking: !1,\n      tooltip: {\n        distance: 6\n      },\n      threshold: 0,\n      borderColor: \"#ffffff\"\n    }, {\n      cropShoulder: 0,\n      directTouch: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      negStacks: !0,\n      init: function init() {\n        v.prototype.init.apply(this, arguments);\n        var a = this,\n            d = a.chart;\n        d.hasRendered && d.series.forEach(function (d) {\n          d.type === a.type && (d.isDirty = !0);\n        });\n      },\n      getColumnMetrics: function getColumnMetrics() {\n        var a = this,\n            d = a.options,\n            c = a.xAxis,\n            h = a.yAxis,\n            b = c.options.reversedStacks,\n            b = c.reversed && !b || !c.reversed && b,\n            l,\n            f = {},\n            n = 0;\n        !1 === d.grouping ? n = 1 : a.chart.series.forEach(function (b) {\n          var d = b.options,\n              c = b.yAxis,\n              g;\n          b.type !== a.type || !b.visible && a.chart.options.chart.ignoreHiddenSeries || h.len !== c.len || h.pos !== c.pos || (d.stacking ? (l = b.stackKey, void 0 === f[l] && (f[l] = n++), g = f[l]) : !1 !== d.grouping && (g = n++), b.columnIndex = g);\n        });\n        var t = Math.min(Math.abs(c.transA) * (c.ordinalSlope || d.pointRange || c.closestPointRange || c.tickInterval || 1), c.len),\n            r = t * d.groupPadding,\n            v = (t - 2 * r) / (n || 1),\n            d = Math.min(d.maxPointWidth || c.len, u(d.pointWidth, v * (1 - 2 * d.pointPadding)));\n        a.columnMetrics = {\n          width: d,\n          offset: (v - d) / 2 + (r + ((a.columnIndex || 0) + (b ? 1 : 0)) * v - t / 2) * (b ? -1 : 1)\n        };\n        return a.columnMetrics;\n      },\n      crispCol: function crispCol(a, d, c, h) {\n        var b = this.chart,\n            g = this.borderWidth,\n            f = -(g % 2 ? .5 : 0),\n            g = g % 2 ? .5 : 1;\n        b.inverted && b.renderer.isVML && (g += 1);\n        this.options.crisp && (c = Math.round(a + c) + f, a = Math.round(a) + f, c -= a);\n        h = Math.round(d + h) + g;\n        f = .5 >= Math.abs(d) && .5 < h;\n        d = Math.round(d) + g;\n        h -= d;\n        f && h && (--d, h += 1);\n        return {\n          x: a,\n          y: d,\n          width: c,\n          height: h\n        };\n      },\n      translate: function translate() {\n        var a = this,\n            d = a.chart,\n            c = a.options,\n            p = a.dense = 2 > a.closestPointRange * a.xAxis.transA,\n            p = a.borderWidth = u(c.borderWidth, p ? 0 : 1),\n            b = a.yAxis,\n            l = c.threshold,\n            f = a.translatedThreshold = b.getThreshold(l),\n            n = u(c.minPointLength, 5),\n            t = a.getColumnMetrics(),\n            r = t.width,\n            F = a.barW = Math.max(r, 1 + 2 * p),\n            z = a.pointXOffset = t.offset;\n        d.inverted && (f -= .5);\n        c.pointPadding && (F = Math.ceil(F));\n        v.prototype.translate.apply(a);\n        a.points.forEach(function (c) {\n          var g = u(c.yBottom, f),\n              k = 999 + Math.abs(g),\n              m = r,\n              k = Math.min(Math.max(-k, c.plotY), b.len + k),\n              e = c.plotX + z,\n              q = F,\n              p = Math.min(k, g),\n              t,\n              x = Math.max(k, g) - p;\n          n && Math.abs(x) < n && (x = n, t = !b.reversed && !c.negative || b.reversed && c.negative, c.y === l && a.dataMax <= l && b.min < l && (t = !t), p = Math.abs(p - f) > n ? g - n : f - (t ? n : 0));\n          h(c.options.pointWidth) && (m = q = Math.ceil(c.options.pointWidth), e -= Math.round((m - r) / 2));\n          c.barX = e;\n          c.pointWidth = m;\n          c.tooltipPos = d.inverted ? [b.len + b.pos - d.plotLeft - k, a.xAxis.len - e - q / 2, x] : [e + q / 2, k + b.pos - d.plotTop, x];\n          c.shapeType = c.shapeType || \"rect\";\n          c.shapeArgs = a.crispCol.apply(a, c.isNull ? [e, f, q, 0] : [e, p, q, x]);\n        });\n      },\n      getSymbol: a.noop,\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,\n      drawGraph: function drawGraph() {\n        this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n      },\n      pointAttribs: function pointAttribs(a, d) {\n        var c = this.options,\n            g,\n            b = this.pointAttrToOptions || {};\n        g = b.stroke || \"borderColor\";\n        var l = b[\"stroke-width\"] || \"borderWidth\",\n            f = a && a.color || this.color,\n            h = a && a[g] || c[g] || this.color || f,\n            t = a && a[l] || c[l] || this[l] || 0,\n            b = c.dashStyle;\n        a && this.zones.length && (f = a.getZone(), f = a.options.color || f && f.color || this.color);\n        d && (a = r(c.states[d], a.options.states && a.options.states[d] || {}), d = a.brightness, f = a.color || void 0 !== d && G(f).brighten(a.brightness).get() || f, h = a[g] || h, t = a[l] || t, b = a.dashStyle || b);\n        g = {\n          fill: f,\n          stroke: h,\n          \"stroke-width\": t\n        };\n        b && (g.dashstyle = b);\n        return g;\n      },\n      drawPoints: function drawPoints() {\n        var a = this,\n            d = this.chart,\n            h = a.options,\n            p = d.renderer,\n            b = h.animationLimit || 250,\n            l;\n        a.points.forEach(function (f) {\n          var g = f.graphic,\n              m = g && d.pointCount < b ? \"animate\" : \"attr\";\n\n          if (c(f.plotY) && null !== f.y) {\n            l = f.shapeArgs;\n            if (g) g[m](r(l));else f.graphic = g = p[f.shapeType](l).add(f.group || a.group);\n            h.borderRadius && g.attr({\n              r: h.borderRadius\n            });\n            d.styledMode || g[m](a.pointAttribs(f, f.selected && \"select\")).shadow(h.shadow, null, h.stacking && !h.borderRadius);\n            g.addClass(f.getClassName(), !0);\n          } else g && (f.graphic = g.destroy());\n        });\n      },\n      animate: function animate(a) {\n        var d = this,\n            c = this.yAxis,\n            g = d.options,\n            b = this.chart.inverted,\n            h = {},\n            f = b ? \"translateX\" : \"translateY\",\n            x;\n        n && (a ? (h.scaleY = .001, a = Math.min(c.pos + c.len, Math.max(c.pos, c.toPixels(g.threshold))), b ? h.translateX = a - c.len : h.translateY = a, d.group.attr(h)) : (x = d.group.attr(f), d.group.animate({\n          scaleY: 1\n        }, E(y(d.options.animation), {\n          step: function step(a, b) {\n            h[f] = x + b.pos * (c.pos - x);\n            d.group.attr(h);\n          }\n        })), d.animate = null));\n      },\n      remove: function remove() {\n        var a = this,\n            d = a.chart;\n        d.hasRendered && d.series.forEach(function (d) {\n          d.type === a.type && (d.isDirty = !0);\n        });\n        v.prototype.remove.apply(a, arguments);\n      }\n    });\n  })(J);\n\n  (function (a) {\n    a = a.seriesType;\n    a(\"bar\", \"column\", null, {\n      inverted: !0\n    });\n  })(J);\n\n  (function (a) {\n    var y = a.Series;\n    a = a.seriesType;\n    a(\"scatter\", \"line\", {\n      lineWidth: 0,\n      findNearestPointBy: \"xy\",\n      marker: {\n        enabled: !0\n      },\n      tooltip: {\n        headerFormat: \"<span style=\\\"color:{point.color}\\\">\\u25CF</span> <span style=\\\"font-size: 10px\\\"> {series.name}</span><br/>\",\n        pointFormat: \"x: \\x3cb\\x3e{point.x}\\x3c/b\\x3e\\x3cbr/\\x3ey: \\x3cb\\x3e{point.y}\\x3c/b\\x3e\\x3cbr/\\x3e\"\n      }\n    }, {\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      takeOrdinalPosition: !1,\n      drawGraph: function drawGraph() {\n        this.options.lineWidth && y.prototype.drawGraph.call(this);\n      }\n    });\n  })(J);\n\n  (function (a) {\n    var y = a.deg2rad,\n        G = a.isNumber,\n        E = a.pick,\n        h = a.relativeLength;\n    a.CenteredSeriesMixin = {\n      getCenter: function getCenter() {\n        var a = this.options,\n            r = this.chart,\n            u = 2 * (a.slicedOffset || 0),\n            v = r.plotWidth - 2 * u,\n            r = r.plotHeight - 2 * u,\n            w = a.center,\n            w = [E(w[0], \"50%\"), E(w[1], \"50%\"), a.size || \"100%\", a.innerSize || 0],\n            n = Math.min(v, r),\n            g,\n            d;\n\n        for (g = 0; 4 > g; ++g) {\n          d = w[g], a = 2 > g || 2 === g && /%$/.test(d), w[g] = h(d, [v, r, n, w[2]][g]) + (a ? u : 0);\n        }\n\n        w[3] > w[2] && (w[3] = w[2]);\n        return w;\n      },\n      getStartAndEndRadians: function getStartAndEndRadians(a, h) {\n        a = G(a) ? a : 0;\n        h = G(h) && h > a && 360 > h - a ? h : a + 360;\n        return {\n          start: y * (a + -90),\n          end: y * (h + -90)\n        };\n      }\n    };\n  })(J);\n\n  (function (a) {\n    var y = a.addEvent,\n        G = a.CenteredSeriesMixin,\n        E = a.defined,\n        h = a.extend,\n        c = G.getStartAndEndRadians,\n        r = a.noop,\n        u = a.pick,\n        v = a.Point,\n        w = a.Series,\n        n = a.seriesType,\n        g = a.setAnimation;\n    n(\"pie\", \"line\", {\n      center: [null, null],\n      clip: !1,\n      colorByPoint: !0,\n      dataLabels: {\n        allowOverlap: !0,\n        connectorPadding: 5,\n        distance: 30,\n        enabled: !0,\n        formatter: function formatter() {\n          return this.point.isNull ? void 0 : this.point.name;\n        },\n        softConnector: !0,\n        x: 0,\n        connectorShape: \"fixedOffset\",\n        crookDistance: \"70%\"\n      },\n      ignoreHiddenPoint: !0,\n      legendType: \"point\",\n      marker: null,\n      size: null,\n      showInLegend: !1,\n      slicedOffset: 10,\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0\n      },\n      borderColor: \"#ffffff\",\n      borderWidth: 1,\n      states: {\n        hover: {\n          brightness: .1\n        }\n      }\n    }, {\n      isCartesian: !1,\n      requireSorting: !1,\n      directTouch: !0,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      axisTypes: [],\n      pointAttribs: a.seriesTypes.column.prototype.pointAttribs,\n      animate: function animate(a) {\n        var d = this,\n            c = d.points,\n            b = d.startAngleRad;\n        a || (c.forEach(function (a) {\n          var c = a.graphic,\n              g = a.shapeArgs;\n          c && (c.attr({\n            r: a.startR || d.center[3] / 2,\n            start: b,\n            end: b\n          }), c.animate({\n            r: g.r,\n            start: g.start,\n            end: g.end\n          }, d.options.animation));\n        }), d.animate = null);\n      },\n      updateTotals: function updateTotals() {\n        var a,\n            c = 0,\n            g = this.points,\n            b = g.length,\n            h,\n            f = this.options.ignoreHiddenPoint;\n\n        for (a = 0; a < b; a++) {\n          h = g[a], c += f && !h.visible ? 0 : h.isNull ? 0 : h.y;\n        }\n\n        this.total = c;\n\n        for (a = 0; a < b; a++) {\n          h = g[a], h.percentage = 0 < c && (h.visible || !f) ? h.y / c * 100 : 0, h.total = c;\n        }\n      },\n      generatePoints: function generatePoints() {\n        w.prototype.generatePoints.call(this);\n        this.updateTotals();\n      },\n      getX: function getX(a, c, g) {\n        var b = this.center,\n            d = this.radii ? this.radii[g.index] : b[2] / 2;\n        return b[0] + (c ? -1 : 1) * Math.cos(Math.asin(Math.max(Math.min((a - b[1]) / (d + g.labelDistance), 1), -1))) * (d + g.labelDistance) + (0 < g.labelDistance ? (c ? -1 : 1) * this.options.dataLabels.padding : 0);\n      },\n      translate: function translate(a) {\n        this.generatePoints();\n        var d = 0,\n            g = this.options,\n            b = g.slicedOffset,\n            h = b + (g.borderWidth || 0),\n            f,\n            n,\n            t = c(g.startAngle, g.endAngle),\n            r = this.startAngleRad = t.start,\n            t = (this.endAngleRad = t.end) - r,\n            v = this.points,\n            z,\n            k,\n            A = g.dataLabels.distance,\n            g = g.ignoreHiddenPoint,\n            w,\n            B = v.length,\n            e;\n        a || (this.center = a = this.getCenter());\n\n        for (w = 0; w < B; w++) {\n          e = v[w];\n          e.labelDistance = u(e.options.dataLabels && e.options.dataLabels.distance, A);\n          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, e.labelDistance);\n          f = r + d * t;\n          if (!g || e.visible) d += e.percentage / 100;\n          n = r + d * t;\n          e.shapeType = \"arc\";\n          e.shapeArgs = {\n            x: a[0],\n            y: a[1],\n            r: a[2] / 2,\n            innerR: a[3] / 2,\n            start: Math.round(1E3 * f) / 1E3,\n            end: Math.round(1E3 * n) / 1E3\n          };\n          n = (n + f) / 2;\n          n > 1.5 * Math.PI ? n -= 2 * Math.PI : n < -Math.PI / 2 && (n += 2 * Math.PI);\n          e.slicedTranslation = {\n            translateX: Math.round(Math.cos(n) * b),\n            translateY: Math.round(Math.sin(n) * b)\n          };\n          z = Math.cos(n) * a[2] / 2;\n          k = Math.sin(n) * a[2] / 2;\n          e.tooltipPos = [a[0] + .7 * z, a[1] + .7 * k];\n          e.half = n < -Math.PI / 2 || n > Math.PI / 2 ? 1 : 0;\n          e.angle = n;\n          f = Math.min(h, e.labelDistance / 5);\n          e.labelPosition = {\n            natural: {\n              x: a[0] + z + Math.cos(n) * e.labelDistance,\n              y: a[1] + k + Math.sin(n) * e.labelDistance\n            },\n            \"final\": {},\n            alignment: 0 > e.labelDistance ? \"center\" : e.half ? \"right\" : \"left\",\n            connectorPosition: {\n              breakAt: {\n                x: a[0] + z + Math.cos(n) * f,\n                y: a[1] + k + Math.sin(n) * f\n              },\n              touchingSliceAt: {\n                x: a[0] + z,\n                y: a[1] + k\n              }\n            }\n          };\n        }\n      },\n      drawGraph: null,\n      drawPoints: function drawPoints() {\n        var a = this,\n            c = a.chart,\n            g = c.renderer,\n            b,\n            l,\n            f,\n            n,\n            t = a.options.shadow;\n        !t || a.shadowGroup || c.styledMode || (a.shadowGroup = g.g(\"shadow\").add(a.group));\n        a.points.forEach(function (d) {\n          l = d.graphic;\n          if (d.isNull) l && (d.graphic = l.destroy());else {\n            n = d.shapeArgs;\n            b = d.getTranslate();\n\n            if (!c.styledMode) {\n              var m = d.shadowGroup;\n              t && !m && (m = d.shadowGroup = g.g(\"shadow\").add(a.shadowGroup));\n              m && m.attr(b);\n              f = a.pointAttribs(d, d.selected && \"select\");\n            }\n\n            l ? (l.setRadialReference(a.center), c.styledMode || l.attr(f), l.animate(h(n, b))) : (d.graphic = l = g[d.shapeType](n).setRadialReference(a.center).attr(b).add(a.group), c.styledMode || l.attr(f).attr({\n              \"stroke-linejoin\": \"round\"\n            }).shadow(t, m));\n            l.attr({\n              visibility: d.visible ? \"inherit\" : \"hidden\"\n            });\n            l.addClass(d.getClassName());\n          }\n        });\n      },\n      searchPoint: r,\n      sortByAngle: function sortByAngle(a, c) {\n        a.sort(function (a, b) {\n          return void 0 !== a.angle && (b.angle - a.angle) * c;\n        });\n      },\n      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,\n      getCenter: G.getCenter,\n      getSymbol: r\n    }, {\n      init: function init() {\n        v.prototype.init.apply(this, arguments);\n        var a = this,\n            c;\n        a.name = u(a.name, \"Slice\");\n\n        c = function c(d) {\n          a.slice(\"select\" === d.type);\n        };\n\n        y(a, \"select\", c);\n        y(a, \"unselect\", c);\n        return a;\n      },\n      isValid: function isValid() {\n        return a.isNumber(this.y, !0) && 0 <= this.y;\n      },\n      setVisible: function setVisible(a, c) {\n        var d = this,\n            b = d.series,\n            g = b.chart,\n            f = b.options.ignoreHiddenPoint;\n        c = u(c, f);\n        a !== d.visible && (d.visible = d.options.visible = a = void 0 === a ? !d.visible : a, b.options.data[b.data.indexOf(d)] = d.options, [\"graphic\", \"dataLabel\", \"connector\", \"shadowGroup\"].forEach(function (b) {\n          if (d[b]) d[b][a ? \"show\" : \"hide\"](!0);\n        }), d.legendItem && g.legend.colorizeItem(d, a), a || \"hover\" !== d.state || d.setState(\"\"), f && (b.isDirty = !0), c && g.redraw());\n      },\n      slice: function slice(a, c, h) {\n        var b = this.series;\n        g(h, b.chart);\n        u(c, !0);\n        this.sliced = this.options.sliced = E(a) ? a : !this.sliced;\n        b.options.data[b.data.indexOf(this)] = this.options;\n        this.graphic.animate(this.getTranslate());\n        this.shadowGroup && this.shadowGroup.animate(this.getTranslate());\n      },\n      getTranslate: function getTranslate() {\n        return this.sliced ? this.slicedTranslation : {\n          translateX: 0,\n          translateY: 0\n        };\n      },\n      haloPath: function haloPath(a) {\n        var d = this.shapeArgs;\n        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(d.x, d.y, d.r + a, d.r + a, {\n          innerR: this.shapeArgs.r - 1,\n          start: d.start,\n          end: d.end\n        });\n      },\n      connectorShapes: {\n        fixedOffset: function fixedOffset(a, c, g) {\n          var b = c.breakAt;\n          c = c.touchingSliceAt;\n          return [\"M\", a.x, a.y].concat(g.softConnector ? [\"C\", a.x + (\"left\" === a.alignment ? -5 : 5), a.y, 2 * b.x - c.x, 2 * b.y - c.y, b.x, b.y] : [\"L\", b.x, b.y]).concat([\"L\", c.x, c.y]);\n        },\n        straight: function straight(a, c) {\n          c = c.touchingSliceAt;\n          return [\"M\", a.x, a.y, \"L\", c.x, c.y];\n        },\n        crookedLine: function crookedLine(d, c, g) {\n          c = c.touchingSliceAt;\n          var b = this.series,\n              h = b.center[0],\n              f = b.chart.plotWidth,\n              m = b.chart.plotLeft,\n              b = d.alignment,\n              t = this.shapeArgs.r;\n          g = a.relativeLength(g.crookDistance, 1);\n          g = \"left\" === b ? h + t + (f + m - h - t) * (1 - g) : m + (h - t) * g;\n          h = [\"L\", g, d.y];\n          if (\"left\" === b ? g > d.x || g < c.x : g < d.x || g > c.x) h = [];\n          return [\"M\", d.x, d.y].concat(h).concat([\"L\", c.x, c.y]);\n        }\n      },\n      getConnectorPath: function getConnectorPath() {\n        var a = this.labelPosition,\n            c = this.series.options.dataLabels,\n            g = c.connectorShape,\n            b = this.connectorShapes;\n        b[g] && (g = b[g]);\n        return g.call(this, {\n          x: a.final.x,\n          y: a.final.y,\n          alignment: a.alignment\n        }, a.connectorPosition, c);\n      }\n    });\n  })(J);\n\n  (function (a) {\n    var y = a.addEvent,\n        G = a.arrayMax,\n        E = a.defined,\n        h = a.extend,\n        c = a.format,\n        r = a.merge,\n        u = a.noop,\n        v = a.pick,\n        w = a.relativeLength,\n        n = a.Series,\n        g = a.seriesTypes,\n        d = a.stableSort,\n        m = a.isArray,\n        p = a.splat;\n\n    a.distribute = function (b, c, f) {\n      function g(a, b) {\n        return a.target - b.target;\n      }\n\n      var h,\n          l = !0,\n          m = b,\n          p = [],\n          k;\n      k = 0;\n      var n = m.reducedLen || c;\n\n      for (h = b.length; h--;) {\n        k += b[h].size;\n      }\n\n      if (k > n) {\n        d(b, function (a, b) {\n          return (b.rank || 0) - (a.rank || 0);\n        });\n\n        for (k = h = 0; k <= n;) {\n          k += b[h].size, h++;\n        }\n\n        p = b.splice(h - 1, b.length);\n      }\n\n      d(b, g);\n\n      for (b = b.map(function (a) {\n        return {\n          size: a.size,\n          targets: [a.target],\n          align: v(a.align, .5)\n        };\n      }); l;) {\n        for (h = b.length; h--;) {\n          l = b[h], k = (Math.min.apply(0, l.targets) + Math.max.apply(0, l.targets)) / 2, l.pos = Math.min(Math.max(0, k - l.size * l.align), c - l.size);\n        }\n\n        h = b.length;\n\n        for (l = !1; h--;) {\n          0 < h && b[h - 1].pos + b[h - 1].size > b[h].pos && (b[h - 1].size += b[h].size, b[h - 1].targets = b[h - 1].targets.concat(b[h].targets), b[h - 1].align = .5, b[h - 1].pos + b[h - 1].size > c && (b[h - 1].pos = c - b[h - 1].size), b.splice(h, 1), l = !0);\n        }\n      }\n\n      m.push.apply(m, p);\n      h = 0;\n      b.some(function (b) {\n        var d = 0;\n        if (b.targets.some(function () {\n          m[h].pos = b.pos + d;\n          if (Math.abs(m[h].pos - m[h].target) > f) return m.slice(0, h + 1).forEach(function (a) {\n            delete a.pos;\n          }), m.reducedLen = (m.reducedLen || c) - .1 * c, m.reducedLen > .1 * c && a.distribute(m, c, f), !0;\n          d += m[h].size;\n          h++;\n        })) return !0;\n      });\n      d(m, g);\n    };\n\n    n.prototype.drawDataLabels = function () {\n      function b(a, b) {\n        var c = b.filter;\n        return c ? (b = c.operator, a = a[c.property], c = c.value, \"\\x3e\" === b && a > c || \"\\x3c\" === b && a < c || \"\\x3e\\x3d\" === b && a >= c || \"\\x3c\\x3d\" === b && a <= c || \"\\x3d\\x3d\" === b && a == c || \"\\x3d\\x3d\\x3d\" === b && a === c ? !0 : !1) : !0;\n      }\n\n      function d(a, b) {\n        var c = [],\n            d;\n        if (m(a) && !m(b)) c = a.map(function (a) {\n          return r(a, b);\n        });else if (m(b) && !m(a)) c = b.map(function (b) {\n          return r(a, b);\n        });else if (m(a) || m(b)) for (d = Math.max(a.length, b.length); d--;) {\n          c[d] = r(a[d], b[d]);\n        } else c = r(a, b);\n        return c;\n      }\n\n      var f = this,\n          g = f.chart,\n          h = f.options,\n          n = h.dataLabels,\n          u = f.points,\n          z,\n          k = f.hasRendered || 0,\n          A,\n          w = v(n.defer, !!h.animation),\n          B = g.renderer,\n          n = d(d(g.options.plotOptions && g.options.plotOptions.series && g.options.plotOptions.series.dataLabels, g.options.plotOptions && g.options.plotOptions[f.type] && g.options.plotOptions[f.type].dataLabels), n);\n      a.fireEvent(this, \"drawDataLabels\");\n      if (m(n) || n.enabled || f._hasPointLabels) A = f.plotGroup(\"dataLabelsGroup\", \"data-labels\", w && !k ? \"hidden\" : \"visible\", n.zIndex || 6), w && (A.attr({\n        opacity: +k\n      }), k || y(f, \"afterAnimate\", function () {\n        f.visible && A.show(!0);\n        A[h.animation ? \"animate\" : \"attr\"]({\n          opacity: 1\n        }, {\n          duration: 200\n        });\n      })), u.forEach(function (e) {\n        z = p(d(n, e.dlOptions || e.options && e.options.dataLabels));\n        z.forEach(function (d, k) {\n          var l = d.enabled && !e.isNull && b(e, d),\n              m,\n              q,\n              t,\n              p,\n              n = e.dataLabels ? e.dataLabels[k] : e.dataLabel,\n              r = e.connectors ? e.connectors[k] : e.connector,\n              u = !n;\n          l && (m = e.getLabelConfig(), q = d[e.formatPrefix + \"Format\"] || d.format, m = E(q) ? c(q, m, g.time) : (d[e.formatPrefix + \"Formatter\"] || d.formatter).call(m, d), q = d.style, t = d.rotation, g.styledMode || (q.color = v(d.color, q.color, f.color, \"#000000\"), \"contrast\" === q.color && (e.contrastColor = B.getContrast(e.color || f.color), q.color = d.inside || 0 > v(d.distance, e.labelDistance) || h.stacking ? e.contrastColor : \"#000000\"), h.cursor && (q.cursor = h.cursor)), p = {\n            r: d.borderRadius || 0,\n            rotation: t,\n            padding: d.padding,\n            zIndex: 1\n          }, g.styledMode || (p.fill = d.backgroundColor, p.stroke = d.borderColor, p[\"stroke-width\"] = d.borderWidth), a.objectEach(p, function (a, b) {\n            void 0 === a && delete p[b];\n          }));\n          !n || l && E(m) ? l && E(m) && (n ? p.text = m : (e.dataLabels = e.dataLabels || [], n = e.dataLabels[k] = t ? B.text(m, 0, -9999).addClass(\"highcharts-data-label\") : B.label(m, 0, -9999, d.shape, null, null, d.useHTML, null, \"data-label\"), k || (e.dataLabel = n), n.addClass(\" highcharts-data-label-color-\" + e.colorIndex + \" \" + (d.className || \"\") + (d.useHTML ? \" highcharts-tracker\" : \"\"))), n.options = d, n.attr(p), g.styledMode || n.css(q).shadow(d.shadow), n.added || n.add(A), f.alignDataLabel(e, n, d, null, u)) : (e.dataLabel = e.dataLabel && e.dataLabel.destroy(), e.dataLabels && (1 === e.dataLabels.length ? delete e.dataLabels : delete e.dataLabels[k]), k || delete e.dataLabel, r && (e.connector = e.connector.destroy(), e.connectors && (1 === e.connectors.length ? delete e.connectors : delete e.connectors[k])));\n        });\n      });\n      a.fireEvent(this, \"afterDrawDataLabels\");\n    };\n\n    n.prototype.alignDataLabel = function (a, d, c, g, m) {\n      var b = this.chart,\n          f = this.isCartesian && b.inverted,\n          l = v(a.dlBox && a.dlBox.centerX, a.plotX, -9999),\n          k = v(a.plotY, -9999),\n          n = d.getBBox(),\n          p,\n          t = c.rotation,\n          e = c.align,\n          q = this.visible && (a.series.forceDL || b.isInsidePlot(l, Math.round(k), f) || g && b.isInsidePlot(l, f ? g.x + 1 : g.y + g.height - 1, f)),\n          r = \"justify\" === v(c.overflow, \"justify\");\n      if (q && (p = b.renderer.fontMetrics(b.styledMode ? void 0 : c.style.fontSize, d).b, g = h({\n        x: f ? this.yAxis.len - k : l,\n        y: Math.round(f ? this.xAxis.len - l : k),\n        width: 0,\n        height: 0\n      }, g), h(c, {\n        width: n.width,\n        height: n.height\n      }), t ? (r = !1, l = b.renderer.rotCorr(p, t), l = {\n        x: g.x + c.x + g.width / 2 + l.x,\n        y: g.y + c.y + {\n          top: 0,\n          middle: .5,\n          bottom: 1\n        }[c.verticalAlign] * g.height\n      }, d[m ? \"attr\" : \"animate\"](l).attr({\n        align: e\n      }), k = (t + 720) % 360, k = 180 < k && 360 > k, \"left\" === e ? l.y -= k ? n.height : 0 : \"center\" === e ? (l.x -= n.width / 2, l.y -= n.height / 2) : \"right\" === e && (l.x -= n.width, l.y -= k ? 0 : n.height), d.placed = !0, d.alignAttr = l) : (d.align(c, null, g), l = d.alignAttr), r && 0 <= g.height ? a.isLabelJustified = this.justifyDataLabel(d, c, l, n, g, m) : v(c.crop, !0) && (q = b.isInsidePlot(l.x, l.y) && b.isInsidePlot(l.x + n.width, l.y + n.height)), c.shape && !t)) d[m ? \"attr\" : \"animate\"]({\n        anchorX: f ? b.plotWidth - a.plotY : a.plotX,\n        anchorY: f ? b.plotHeight - a.plotX : a.plotY\n      });\n      q || (d.attr({\n        y: -9999\n      }), d.placed = !1);\n    };\n\n    n.prototype.justifyDataLabel = function (a, d, c, g, h, m) {\n      var b = this.chart,\n          f = d.align,\n          k = d.verticalAlign,\n          l,\n          n,\n          p = a.box ? 0 : a.padding || 0;\n      l = c.x + p;\n      0 > l && (\"right\" === f ? d.align = \"left\" : d.x = -l, n = !0);\n      l = c.x + g.width - p;\n      l > b.plotWidth && (\"left\" === f ? d.align = \"right\" : d.x = b.plotWidth - l, n = !0);\n      l = c.y + p;\n      0 > l && (\"bottom\" === k ? d.verticalAlign = \"top\" : d.y = -l, n = !0);\n      l = c.y + g.height - p;\n      l > b.plotHeight && (\"top\" === k ? d.verticalAlign = \"bottom\" : d.y = b.plotHeight - l, n = !0);\n      n && (a.placed = !m, a.align(d, null, h));\n      return n;\n    };\n\n    g.pie && (g.pie.prototype.dataLabelPositioners = {\n      radialDistributionY: function radialDistributionY(a) {\n        return a.top + a.distributeBox.pos;\n      },\n      radialDistributionX: function radialDistributionX(a, d, c, g) {\n        return a.getX(c < d.top + 2 || c > d.bottom - 2 ? g : c, d.half, d);\n      },\n      justify: function justify(a, d, c) {\n        return c[0] + (a.half ? -1 : 1) * (d + a.labelDistance);\n      },\n      alignToPlotEdges: function alignToPlotEdges(a, d, c, g) {\n        a = a.getBBox().width;\n        return d ? a + g : c - a - g;\n      },\n      alignToConnectors: function alignToConnectors(a, d, c, g) {\n        var b = 0,\n            f;\n        a.forEach(function (a) {\n          f = a.dataLabel.getBBox().width;\n          f > b && (b = f);\n        });\n        return d ? b + g : c - b - g;\n      }\n    }, g.pie.prototype.drawDataLabels = function () {\n      var b = this,\n          d = b.data,\n          c,\n          g = b.chart,\n          h = b.options.dataLabels,\n          m = h.connectorPadding,\n          p = v(h.connectorWidth, 1),\n          r = g.plotWidth,\n          k = g.plotHeight,\n          u = g.plotLeft,\n          w = Math.round(g.chartWidth / 3),\n          B,\n          e = b.center,\n          q = e[2] / 2,\n          y = e[1],\n          I,\n          J,\n          K,\n          M,\n          S = [[], []],\n          C,\n          N,\n          P,\n          T,\n          Q = [0, 0, 0, 0],\n          O = b.dataLabelPositioners;\n      b.visible && (h.enabled || b._hasPointLabels) && (d.forEach(function (a) {\n        a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({\n          width: \"auto\"\n        }).css({\n          width: \"auto\",\n          textOverflow: \"clip\"\n        }), a.dataLabel.shortened = !1);\n      }), n.prototype.drawDataLabels.apply(b), d.forEach(function (a) {\n        a.dataLabel && (a.visible ? (S[a.half].push(a), a.dataLabel._pos = null, !E(h.style.width) && !E(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > w && (a.dataLabel.css({\n          width: .7 * w\n        }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));\n      }), S.forEach(function (d, f) {\n        var l,\n            n,\n            p = d.length,\n            t = [],\n            x;\n        if (p) for (b.sortByAngle(d, f - .5), 0 < b.maxLabelDistance && (l = Math.max(0, y - q - b.maxLabelDistance), n = Math.min(y + q + b.maxLabelDistance, g.plotHeight), d.forEach(function (a) {\n          0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, y - q - a.labelDistance), a.bottom = Math.min(y + q + a.labelDistance, g.plotHeight), x = a.dataLabel.getBBox().height || 21, a.distributeBox = {\n            target: a.labelPosition.natural.y - a.top + x / 2,\n            size: x,\n            rank: a.y\n          }, t.push(a.distributeBox));\n        }), l = n + x - l, a.distribute(t, l, l / 5)), T = 0; T < p; T++) {\n          c = d[T];\n          K = c.labelPosition;\n          I = c.dataLabel;\n          P = !1 === c.visible ? \"hidden\" : \"inherit\";\n          N = l = K.natural.y;\n          t && E(c.distributeBox) && (void 0 === c.distributeBox.pos ? P = \"hidden\" : (M = c.distributeBox.size, N = O.radialDistributionY(c)));\n          delete c.positionIndex;\n          if (h.justify) C = O.justify(c, q, e);else switch (h.alignTo) {\n            case \"connectors\":\n              C = O.alignToConnectors(d, f, r, u);\n              break;\n\n            case \"plotEdges\":\n              C = O.alignToPlotEdges(I, f, r, u);\n              break;\n\n            default:\n              C = O.radialDistributionX(b, c, N, l);\n          }\n          I._attr = {\n            visibility: P,\n            align: K.alignment\n          };\n          I._pos = {\n            x: C + h.x + ({\n              left: m,\n              right: -m\n            }[K.alignment] || 0),\n            y: N + h.y - 10\n          };\n          K.final.x = C;\n          K.final.y = N;\n          v(h.crop, !0) && (J = I.getBBox().width, l = null, C - J < m && 1 === f ? (l = Math.round(J - C + m), Q[3] = Math.max(l, Q[3])) : C + J > r - m && 0 === f && (l = Math.round(C + J - r + m), Q[1] = Math.max(l, Q[1])), 0 > N - M / 2 ? Q[0] = Math.max(Math.round(-N + M / 2), Q[0]) : N + M / 2 > k && (Q[2] = Math.max(Math.round(N + M / 2 - k), Q[2])), I.sideOverflow = l);\n        }\n      }), 0 === G(Q) || this.verifyDataLabelOverflow(Q)) && (this.placeDataLabels(), p && this.points.forEach(function (a) {\n        var d;\n        B = a.connector;\n\n        if ((I = a.dataLabel) && I._pos && a.visible && 0 < a.labelDistance) {\n          P = I._attr.visibility;\n          if (d = !B) a.connector = B = g.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + a.colorIndex + (a.className ? \" \" + a.className : \"\")).add(b.dataLabelsGroup), g.styledMode || B.attr({\n            \"stroke-width\": p,\n            stroke: h.connectorColor || a.color || \"#666666\"\n          });\n          B[d ? \"attr\" : \"animate\"]({\n            d: a.getConnectorPath()\n          });\n          B.attr(\"visibility\", P);\n        } else B && (a.connector = B.destroy());\n      }));\n    }, g.pie.prototype.placeDataLabels = function () {\n      this.points.forEach(function (a) {\n        var b = a.dataLabel;\n        b && a.visible && ((a = b._pos) ? (b.sideOverflow && (b._attr.width = b.getBBox().width - b.sideOverflow, b.css({\n          width: b._attr.width + \"px\",\n          textOverflow: (this.options.dataLabels.style || {}).textOverflow || \"ellipsis\"\n        }), b.shortened = !0), b.attr(b._attr), b[b.moved ? \"animate\" : \"attr\"](a), b.moved = !0) : b && b.attr({\n          y: -9999\n        }));\n      }, this);\n    }, g.pie.prototype.alignDataLabel = u, g.pie.prototype.verifyDataLabelOverflow = function (a) {\n      var b = this.center,\n          d = this.options,\n          c = d.center,\n          g = d.minSize || 80,\n          h,\n          m = null !== d.size;\n      m || (null !== c[0] ? h = Math.max(b[2] - Math.max(a[1], a[3]), g) : (h = Math.max(b[2] - a[1] - a[3], g), b[0] += (a[3] - a[1]) / 2), null !== c[1] ? h = Math.max(Math.min(h, b[2] - Math.max(a[0], a[2])), g) : (h = Math.max(Math.min(h, b[2] - a[0] - a[2]), g), b[1] += (a[0] - a[2]) / 2), h < b[2] ? (b[2] = h, b[3] = Math.min(w(d.innerSize || 0, h), h), this.translate(b), this.drawDataLabels && this.drawDataLabels()) : m = !0);\n      return m;\n    });\n    g.column && (g.column.prototype.alignDataLabel = function (a, d, c, g, h) {\n      var b = this.chart.inverted,\n          f = a.series,\n          l = a.dlBox || a.shapeArgs,\n          k = v(a.below, a.plotY > v(this.translatedThreshold, f.yAxis.len)),\n          m = v(c.inside, !!this.options.stacking);\n      l && (g = r(l), 0 > g.y && (g.height += g.y, g.y = 0), l = g.y + g.height - f.yAxis.len, 0 < l && (g.height -= l), b && (g = {\n        x: f.yAxis.len - g.y - g.height,\n        y: f.xAxis.len - g.x - g.width,\n        width: g.height,\n        height: g.width\n      }), m || (b ? (g.x += k ? 0 : g.width, g.width = 0) : (g.y += k ? g.height : 0, g.height = 0)));\n      c.align = v(c.align, !b || m ? \"center\" : k ? \"right\" : \"left\");\n      c.verticalAlign = v(c.verticalAlign, b || m ? \"middle\" : k ? \"top\" : \"bottom\");\n      n.prototype.alignDataLabel.call(this, a, d, c, g, h);\n      a.isLabelJustified && a.contrastColor && d.css({\n        color: a.contrastColor\n      });\n    });\n  })(J);\n\n  (function (a) {\n    var y = a.Chart,\n        G = a.isArray,\n        E = a.objectEach,\n        h = a.pick,\n        c = a.addEvent,\n        r = a.fireEvent;\n    c(y, \"render\", function () {\n      var a = [];\n      (this.labelCollectors || []).forEach(function (c) {\n        a = a.concat(c());\n      });\n      (this.yAxis || []).forEach(function (c) {\n        c.options.stackLabels && !c.options.stackLabels.allowOverlap && E(c.stacks, function (c) {\n          E(c, function (c) {\n            a.push(c.label);\n          });\n        });\n      });\n      (this.series || []).forEach(function (c) {\n        var r = c.options.dataLabels;\n        c.visible && (!1 !== r.enabled || c._hasPointLabels) && c.points.forEach(function (c) {\n          c.visible && (G(c.dataLabels) ? c.dataLabels : c.dataLabel ? [c.dataLabel] : []).forEach(function (g) {\n            var d = g.options;\n            g.labelrank = h(d.labelrank, c.labelrank, c.shapeArgs && c.shapeArgs.height);\n            d.allowOverlap || a.push(g);\n          });\n        });\n      });\n      this.hideOverlappingLabels(a);\n    });\n\n    y.prototype.hideOverlappingLabels = function (a) {\n      var c = this,\n          h = a.length,\n          n = c.renderer,\n          g,\n          d,\n          m,\n          p,\n          b,\n          l,\n          f = function f(a, b, c, d, _f, g, h, l) {\n        return !(_f > a + c || _f + h < a || g > b + d || g + l < b);\n      };\n\n      m = function m(a) {\n        var b,\n            c,\n            d,\n            f = a.box ? 0 : a.padding || 0;\n        d = 0;\n        if (a && (!a.alignAttr || a.placed)) return b = a.alignAttr || {\n          x: a.attr(\"x\"),\n          y: a.attr(\"y\")\n        }, c = a.parentGroup, a.width || (d = a.getBBox(), a.width = d.width, a.height = d.height, d = n.fontMetrics(null, a.element).h), {\n          x: b.x + (c.translateX || 0) + f,\n          y: b.y + (c.translateY || 0) + f - d,\n          width: a.width - 2 * f,\n          height: a.height - 2 * f\n        };\n      };\n\n      for (d = 0; d < h; d++) {\n        if (g = a[d]) g.oldOpacity = g.opacity, g.newOpacity = 1, g.absoluteBox = m(g);\n      }\n\n      a.sort(function (a, b) {\n        return (b.labelrank || 0) - (a.labelrank || 0);\n      });\n\n      for (d = 0; d < h; d++) {\n        for (l = (m = a[d]) && m.absoluteBox, g = d + 1; g < h; ++g) {\n          if (b = (p = a[g]) && p.absoluteBox, l && b && m !== p && 0 !== m.newOpacity && 0 !== p.newOpacity && (b = f(l.x, l.y, l.width, l.height, b.x, b.y, b.width, b.height))) (m.labelrank < p.labelrank ? m : p).newOpacity = 0;\n        }\n      }\n\n      a.forEach(function (a) {\n        var b, d;\n        a && (d = a.newOpacity, a.oldOpacity !== d && (a.alignAttr && a.placed ? (d ? a.show(!0) : b = function b() {\n          a.hide();\n        }, a.alignAttr.opacity = d, a[a.isOld ? \"animate\" : \"attr\"](a.alignAttr, null, b), r(c, \"afterHideOverlappingLabels\")) : a.attr({\n          opacity: d\n        })), a.isOld = !0);\n      });\n    };\n  })(J);\n\n  (function (a) {\n    var y = a.addEvent,\n        G = a.Chart,\n        E = a.createElement,\n        h = a.css,\n        c = a.defaultOptions,\n        r = a.defaultPlotOptions,\n        u = a.extend,\n        v = a.fireEvent,\n        w = a.hasTouch,\n        n = a.isObject,\n        g = a.Legend,\n        d = a.merge,\n        m = a.pick,\n        p = a.Point,\n        b = a.Series,\n        l = a.seriesTypes,\n        f = a.svg,\n        x;\n    x = a.TrackerMixin = {\n      drawTrackerPoint: function drawTrackerPoint() {\n        var a = this,\n            b = a.chart,\n            c = b.pointer,\n            d = function d(a) {\n          var b = c.getPointFromEvent(a);\n          void 0 !== b && (c.isDirectTouch = !0, b.onMouseOver(a));\n        };\n\n        a.points.forEach(function (a) {\n          a.graphic && (a.graphic.element.point = a);\n          a.dataLabel && (a.dataLabel.div ? a.dataLabel.div.point = a : a.dataLabel.element.point = a);\n        });\n        a._hasTracking || (a.trackerGroups.forEach(function (f) {\n          if (a[f]) {\n            a[f].addClass(\"highcharts-tracker\").on(\"mouseover\", d).on(\"mouseout\", function (a) {\n              c.onTrackerMouseOut(a);\n            });\n            if (w) a[f].on(\"touchstart\", d);\n            !b.styledMode && a.options.cursor && a[f].css(h).css({\n              cursor: a.options.cursor\n            });\n          }\n        }), a._hasTracking = !0);\n        v(this, \"afterDrawTracker\");\n      },\n      drawTrackerGraph: function drawTrackerGraph() {\n        var a = this,\n            b = a.options,\n            c = b.trackByArea,\n            d = [].concat(c ? a.areaPath : a.graphPath),\n            g = d.length,\n            h = a.chart,\n            l = h.pointer,\n            m = h.renderer,\n            e = h.options.tooltip.snap,\n            q = a.tracker,\n            p,\n            n = function n() {\n          if (h.hoverSeries !== a) a.onMouseOver();\n        },\n            r = \"rgba(192,192,192,\" + (f ? .0001 : .002) + \")\";\n\n        if (g && !c) for (p = g + 1; p--;) {\n          \"M\" === d[p] && d.splice(p + 1, 0, d[p + 1] - e, d[p + 2], \"L\"), (p && \"M\" === d[p] || p === g) && d.splice(p, 0, \"L\", d[p - 2] + e, d[p - 1]);\n        }\n        q ? q.attr({\n          d: d\n        }) : a.graph && (a.tracker = m.path(d).attr({\n          visibility: a.visible ? \"visible\" : \"hidden\",\n          zIndex: 2\n        }).addClass(c ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(a.group), h.styledMode || a.tracker.attr({\n          \"stroke-linejoin\": \"round\",\n          stroke: r,\n          fill: c ? r : \"none\",\n          \"stroke-width\": a.graph.strokeWidth() + (c ? 0 : 2 * e)\n        }), [a.tracker, a.markerGroup].forEach(function (a) {\n          a.addClass(\"highcharts-tracker\").on(\"mouseover\", n).on(\"mouseout\", function (a) {\n            l.onTrackerMouseOut(a);\n          });\n          b.cursor && !h.styledMode && a.css({\n            cursor: b.cursor\n          });\n          if (w) a.on(\"touchstart\", n);\n        }));\n        v(this, \"afterDrawTracker\");\n      }\n    };\n    l.column && (l.column.prototype.drawTracker = x.drawTrackerPoint);\n    l.pie && (l.pie.prototype.drawTracker = x.drawTrackerPoint);\n    l.scatter && (l.scatter.prototype.drawTracker = x.drawTrackerPoint);\n    u(g.prototype, {\n      setItemEvents: function setItemEvents(a, b, c) {\n        var f = this,\n            g = f.chart.renderer.boxWrapper,\n            h = \"highcharts-legend-\" + (a instanceof p ? \"point\" : \"series\") + \"-active\",\n            l = f.chart.styledMode;\n        (c ? b : a.legendGroup).on(\"mouseover\", function () {\n          a.setState(\"hover\");\n          g.addClass(h);\n          l || b.css(f.options.itemHoverStyle);\n        }).on(\"mouseout\", function () {\n          f.styledMode || b.css(d(a.visible ? f.itemStyle : f.itemHiddenStyle));\n          g.removeClass(h);\n          a.setState();\n        }).on(\"click\", function (b) {\n          var c = function c() {\n            a.setVisible && a.setVisible();\n          };\n\n          g.removeClass(h);\n          b = {\n            browserEvent: b\n          };\n          a.firePointEvent ? a.firePointEvent(\"legendItemClick\", b, c) : v(a, \"legendItemClick\", b, c);\n        });\n      },\n      createCheckboxForItem: function createCheckboxForItem(a) {\n        a.checkbox = E(\"input\", {\n          type: \"checkbox\",\n          className: \"highcharts-legend-checkbox\",\n          checked: a.selected,\n          defaultChecked: a.selected\n        }, this.options.itemCheckboxStyle, this.chart.container);\n        y(a.checkbox, \"click\", function (b) {\n          v(a.series || a, \"checkboxClick\", {\n            checked: b.target.checked,\n            item: a\n          }, function () {\n            a.select();\n          });\n        });\n      }\n    });\n    u(G.prototype, {\n      showResetZoom: function showResetZoom() {\n        function a() {\n          b.zoomOut();\n        }\n\n        var b = this,\n            d = c.lang,\n            f = b.options.chart.resetZoomButton,\n            g = f.theme,\n            h = g.states,\n            l = \"chart\" === f.relativeTo ? null : \"plotBox\";\n        v(this, \"beforeShowResetZoom\", null, function () {\n          b.resetZoomButton = b.renderer.button(d.resetZoom, null, null, a, g, h && h.hover).attr({\n            align: f.position.align,\n            title: d.resetZoomTitle\n          }).addClass(\"highcharts-reset-zoom\").add().align(f.position, !1, l);\n        });\n      },\n      zoomOut: function zoomOut() {\n        v(this, \"selection\", {\n          resetSelection: !0\n        }, this.zoom);\n      },\n      zoom: function zoom(a) {\n        var b,\n            c = this.pointer,\n            d = !1,\n            f;\n        !a || a.resetSelection ? (this.axes.forEach(function (a) {\n          b = a.zoom();\n        }), c.initiated = !1) : a.xAxis.concat(a.yAxis).forEach(function (a) {\n          var f = a.axis;\n          c[f.isXAxis ? \"zoomX\" : \"zoomY\"] && (b = f.zoom(a.min, a.max), f.displayBtn && (d = !0));\n        });\n        f = this.resetZoomButton;\n        d && !f ? this.showResetZoom() : !d && n(f) && (this.resetZoomButton = f.destroy());\n        b && this.redraw(m(this.options.chart.animation, a && a.animation, 100 > this.pointCount));\n      },\n      pan: function pan(a, b) {\n        var c = this,\n            d = c.hoverPoints,\n            f;\n        d && d.forEach(function (a) {\n          a.setState();\n        });\n        (\"xy\" === b ? [1, 0] : [1]).forEach(function (b) {\n          b = c[b ? \"xAxis\" : \"yAxis\"][0];\n          var d = b.horiz,\n              g = a[d ? \"chartX\" : \"chartY\"],\n              d = d ? \"mouseDownX\" : \"mouseDownY\",\n              e = c[d],\n              h = (b.pointRange || 0) / 2,\n              k = b.reversed && !c.inverted || !b.reversed && c.inverted ? -1 : 1,\n              l = b.getExtremes(),\n              m = b.toValue(e - g, !0) + h * k,\n              k = b.toValue(e + b.len - g, !0) - h * k,\n              p = k < m,\n              e = p ? k : m,\n              m = p ? m : k,\n              k = Math.min(l.dataMin, h ? l.min : b.toValue(b.toPixels(l.min) - b.minPixelPadding)),\n              h = Math.max(l.dataMax, h ? l.max : b.toValue(b.toPixels(l.max) + b.minPixelPadding)),\n              p = k - e;\n          0 < p && (m += p, e = k);\n          p = m - h;\n          0 < p && (m = h, e -= p);\n          b.series.length && e !== l.min && m !== l.max && (b.setExtremes(e, m, !1, !1, {\n            trigger: \"pan\"\n          }), f = !0);\n          c[d] = g;\n        });\n        f && c.redraw(!1);\n        h(c.container, {\n          cursor: \"move\"\n        });\n      }\n    });\n    u(p.prototype, {\n      select: function select(a, b) {\n        var c = this,\n            d = c.series,\n            f = d.chart;\n        a = m(a, !c.selected);\n        c.firePointEvent(a ? \"select\" : \"unselect\", {\n          accumulate: b\n        }, function () {\n          c.selected = c.options.selected = a;\n          d.options.data[d.data.indexOf(c)] = c.options;\n          c.setState(a && \"select\");\n          b || f.getSelectedPoints().forEach(function (a) {\n            a.selected && a !== c && (a.selected = a.options.selected = !1, d.options.data[d.data.indexOf(a)] = a.options, a.setState(\"\"), a.firePointEvent(\"unselect\"));\n          });\n        });\n      },\n      onMouseOver: function onMouseOver(a) {\n        var b = this.series.chart,\n            c = b.pointer;\n        a = a ? c.normalize(a) : c.getChartCoordinatesFromPoint(this, b.inverted);\n        c.runPointActions(a, this);\n      },\n      onMouseOut: function onMouseOut() {\n        var a = this.series.chart;\n        this.firePointEvent(\"mouseOut\");\n        (a.hoverPoints || []).forEach(function (a) {\n          a.setState();\n        });\n        a.hoverPoints = a.hoverPoint = null;\n      },\n      importEvents: function importEvents() {\n        if (!this.hasImportedEvents) {\n          var b = this,\n              c = d(b.series.options.point, b.options).events;\n          b.events = c;\n          a.objectEach(c, function (a, c) {\n            y(b, c, a);\n          });\n          this.hasImportedEvents = !0;\n        }\n      },\n      setState: function setState(a, b) {\n        var c = Math.floor(this.plotX),\n            d = this.plotY,\n            f = this.series,\n            g = f.options.states[a || \"normal\"] || {},\n            h = r[f.type].marker && f.options.marker,\n            l = h && !1 === h.enabled,\n            e = h && h.states && h.states[a || \"normal\"] || {},\n            p = !1 === e.enabled,\n            n = f.stateMarkerGraphic,\n            t = this.marker || {},\n            w = f.chart,\n            x = f.halo,\n            y,\n            E = h && f.markerAttribs;\n        a = a || \"\";\n\n        if (!(a === this.state && !b || this.selected && \"select\" !== a || !1 === g.enabled || a && (p || l && !1 === e.enabled) || a && t.states && t.states[a] && !1 === t.states[a].enabled)) {\n          E && (y = f.markerAttribs(this, a));\n          if (this.graphic) this.state && this.graphic.removeClass(\"highcharts-point-\" + this.state), a && this.graphic.addClass(\"highcharts-point-\" + a), w.styledMode || this.graphic.animate(f.pointAttribs(this, a), m(w.options.chart.animation, g.animation)), y && this.graphic.animate(y, m(w.options.chart.animation, e.animation, h.animation)), n && n.hide();else {\n            if (a && e) {\n              h = t.symbol || f.symbol;\n              n && n.currentSymbol !== h && (n = n.destroy());\n              if (n) n[b ? \"animate\" : \"attr\"]({\n                x: y.x,\n                y: y.y\n              });else h && (f.stateMarkerGraphic = n = w.renderer.symbol(h, y.x, y.y, y.width, y.height).add(f.markerGroup), n.currentSymbol = h);\n              !w.styledMode && n && n.attr(f.pointAttribs(this, a));\n            }\n\n            n && (n[a && w.isInsidePlot(c, d, w.inverted) ? \"show\" : \"hide\"](), n.element.point = this);\n          }\n          (c = g.halo) && c.size ? (x || (f.halo = x = w.renderer.path().add((this.graphic || n).parentGroup)), x.show()[b ? \"animate\" : \"attr\"]({\n            d: this.haloPath(c.size)\n          }), x.attr({\n            \"class\": \"highcharts-halo highcharts-color-\" + m(this.colorIndex, f.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n            zIndex: -1\n          }), x.point = this, w.styledMode || x.attr(u({\n            fill: this.color || f.color,\n            \"fill-opacity\": c.opacity\n          }, c.attributes))) : x && x.point && x.point.haloPath && x.animate({\n            d: x.point.haloPath(0)\n          }, null, x.hide);\n          this.state = a;\n          v(this, \"afterSetState\");\n        }\n      },\n      haloPath: function haloPath(a) {\n        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);\n      }\n    });\n    u(b.prototype, {\n      onMouseOver: function onMouseOver() {\n        var a = this.chart,\n            b = a.hoverSeries;\n        if (b && b !== this) b.onMouseOut();\n        this.options.events.mouseOver && v(this, \"mouseOver\");\n        this.setState(\"hover\");\n        a.hoverSeries = this;\n      },\n      onMouseOut: function onMouseOut() {\n        var a = this.options,\n            b = this.chart,\n            c = b.tooltip,\n            d = b.hoverPoint;\n        b.hoverSeries = null;\n        if (d) d.onMouseOut();\n        this && a.events.mouseOut && v(this, \"mouseOut\");\n        !c || this.stickyTracking || c.shared && !this.noSharedTooltip || c.hide();\n        this.setState();\n      },\n      setState: function setState(a) {\n        var b = this,\n            c = b.options,\n            d = b.graph,\n            f = c.states,\n            g = c.lineWidth,\n            c = 0;\n        a = a || \"\";\n        if (b.state !== a && ([b.group, b.markerGroup, b.dataLabelsGroup].forEach(function (c) {\n          c && (b.state && c.removeClass(\"highcharts-series-\" + b.state), a && c.addClass(\"highcharts-series-\" + a));\n        }), b.state = a, !(b.chart.styledMode || f[a] && !1 === f[a].enabled) && (a && (g = f[a].lineWidth || g + (f[a].lineWidthPlus || 0)), d && !d.dashstyle))) for (g = {\n          \"stroke-width\": g\n        }, d.animate(g, m(f[a || \"normal\"] && f[a || \"normal\"].animation, b.chart.options.chart.animation)); b[\"zone-graph-\" + c];) {\n          b[\"zone-graph-\" + c].attr(g), c += 1;\n        }\n      },\n      setVisible: function setVisible(a, b) {\n        var c = this,\n            d = c.chart,\n            f = c.legendItem,\n            g,\n            h = d.options.chart.ignoreHiddenSeries,\n            l = c.visible;\n        g = (c.visible = a = c.options.visible = c.userOptions.visible = void 0 === a ? !l : a) ? \"show\" : \"hide\";\n        [\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"].forEach(function (a) {\n          if (c[a]) c[a][g]();\n        });\n        if (d.hoverSeries === c || (d.hoverPoint && d.hoverPoint.series) === c) c.onMouseOut();\n        f && d.legend.colorizeItem(c, a);\n        c.isDirty = !0;\n        c.options.stacking && d.series.forEach(function (a) {\n          a.options.stacking && a.visible && (a.isDirty = !0);\n        });\n        c.linkedSeries.forEach(function (b) {\n          b.setVisible(a, !1);\n        });\n        h && (d.isDirtyBox = !0);\n        v(c, g);\n        !1 !== b && d.redraw();\n      },\n      show: function show() {\n        this.setVisible(!0);\n      },\n      hide: function hide() {\n        this.setVisible(!1);\n      },\n      select: function select(a) {\n        this.selected = a = this.options.selected = void 0 === a ? !this.selected : a;\n        this.checkbox && (this.checkbox.checked = a);\n        v(this, a ? \"select\" : \"unselect\");\n      },\n      drawTracker: x.drawTrackerGraph\n    });\n  })(J);\n\n  (function (a) {\n    var y = a.Chart,\n        G = a.isArray,\n        E = a.isObject,\n        h = a.pick,\n        c = a.splat;\n\n    y.prototype.setResponsive = function (c) {\n      var h = this.options.responsive,\n          r = [],\n          w = this.currentResponsive;\n      h && h.rules && h.rules.forEach(function (g) {\n        void 0 === g._id && (g._id = a.uniqueKey());\n        this.matchResponsiveRule(g, r, c);\n      }, this);\n      var n = a.merge.apply(0, r.map(function (c) {\n        return a.find(h.rules, function (a) {\n          return a._id === c;\n        }).chartOptions;\n      })),\n          r = r.toString() || void 0;\n      r !== (w && w.ruleIds) && (w && this.update(w.undoOptions, c), r ? (this.currentResponsive = {\n        ruleIds: r,\n        mergedOptions: n,\n        undoOptions: this.currentOptions(n)\n      }, this.update(n, c)) : this.currentResponsive = void 0);\n    };\n\n    y.prototype.matchResponsiveRule = function (a, c) {\n      var r = a.condition;\n      (r.callback || function () {\n        return this.chartWidth <= h(r.maxWidth, Number.MAX_VALUE) && this.chartHeight <= h(r.maxHeight, Number.MAX_VALUE) && this.chartWidth >= h(r.minWidth, 0) && this.chartHeight >= h(r.minHeight, 0);\n      }).call(this) && c.push(a._id);\n    };\n\n    y.prototype.currentOptions = function (h) {\n      function r(h, n, g, d) {\n        var m;\n        a.objectEach(h, function (a, b) {\n          if (!d && -1 < [\"series\", \"xAxis\", \"yAxis\"].indexOf(b)) for (a = c(a), g[b] = [], m = 0; m < a.length; m++) {\n            n[b][m] && (g[b][m] = {}, r(a[m], n[b][m], g[b][m], d + 1));\n          } else E(a) ? (g[b] = G(a) ? [] : {}, r(a, n[b] || {}, g[b], d + 1)) : g[b] = n[b] || null;\n        });\n      }\n\n      var v = {};\n      r(h, this.options, v, 0);\n      return v;\n    };\n  })(J);\n\n  return J;\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./js/highcharts.js?");

/***/ }),

/***/ "./js/script.js":
/*!**********************!*\
  !*** ./js/script.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _targetblank__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./targetblank */ \"./js/targetblank.js\");\n/* harmony import */ var _targetblank__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_targetblank__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _highcharts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./highcharts */ \"./js/highcharts.js\");\n/* harmony import */ var _highcharts__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_highcharts__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _series_label__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./series-label */ \"./js/series-label.js\");\n/* harmony import */ var _series_label__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_series_label__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _graf1__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./graf1 */ \"./js/graf1.js\");\n/* harmony import */ var _graf1__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_graf1__WEBPACK_IMPORTED_MODULE_3__);\n // pro otvírání odkazů v novém okně\n\n\n\n\n\n//# sourceURL=webpack:///./js/script.js?");

/***/ }),

/***/ "./js/series-label.js":
/*!****************************!*\
  !*** ./js/series-label.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*\n Highcharts JS v7.0.1 (2018-12-19)\n\n (c) 2009-2018 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (r) {\n  \"object\" === ( false ? undefined : _typeof(module)) && module.exports ? module.exports = r :  true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n    return r;\n  }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;\n})(function (r) {\n  (function (n) {\n    function r(c, b, a, k, d, e) {\n      c = (e - b) * (a - c) - (k - b) * (d - c);\n      return 0 < c ? !0 : 0 > c ? !1 : !0;\n    }\n\n    function v(c, b, a, k, d, e, f, m) {\n      return r(c, b, d, e, f, m) !== r(a, k, d, e, f, m) && r(c, b, a, k, d, e) !== r(c, b, a, k, f, m);\n    }\n\n    function z(c, b, a, k, d, e, f, m) {\n      return v(c, b, c + a, b, d, e, f, m) || v(c + a, b, c + a, b + k, d, e, f, m) || v(c, b + k, c + a, b + k, d, e, f, m) || v(c, b, c, b + k, d, e, f, m);\n    }\n\n    var C = n.addEvent,\n        A = n.extend,\n        w = n.isNumber,\n        x = n.pick,\n        y = n.Series,\n        D = n.SVGRenderer,\n        B = n.Chart;\n    n.setOptions({\n      plotOptions: {\n        series: {\n          label: {\n            enabled: !0,\n            connectorAllowed: !1,\n            connectorNeighbourDistance: 24,\n            minFontSize: null,\n            maxFontSize: null,\n            onArea: null,\n            style: {\n              fontWeight: \"bold\"\n            },\n            boxesToAvoid: []\n          }\n        }\n      }\n    });\n\n    D.prototype.symbols.connector = function (c, b, a, k, d) {\n      var e = d && d.anchorX;\n      d = d && d.anchorY;\n      var f,\n          m,\n          h = a / 2;\n      w(e) && w(d) && (f = [\"M\", e, d], m = b - d, 0 > m && (m = -k - m), m < a && (h = e < c + a / 2 ? m : a - m), d > b + k ? f.push(\"L\", c + h, b + k) : d < b ? f.push(\"L\", c + h, b) : e < c ? f.push(\"L\", c, b + k / 2) : e > c + a && f.push(\"L\", c + a, b + k / 2));\n      return f || [];\n    };\n\n    y.prototype.getPointsOnGraph = function () {\n      if (this.xAxis || this.yAxis) {\n        var c = this.points,\n            b,\n            a,\n            k = [],\n            d,\n            e,\n            f,\n            m;\n        e = this.graph || this.area;\n        f = e.element;\n        var h = this.chart.inverted,\n            q = this.xAxis;\n        b = this.yAxis;\n        var u = h ? b.pos : q.pos,\n            h = h ? q.pos : b.pos,\n            q = x(this.options.label.onArea, !!this.area),\n            p = b.getThreshold(this.options.threshold);\n\n        if (this.getPointSpline && f.getPointAtLength && !q) {\n          e.toD && (a = e.attr(\"d\"), e.attr({\n            d: e.toD\n          }));\n          m = f.getTotalLength();\n\n          for (d = 0; d < m; d += 16) {\n            b = f.getPointAtLength(d), k.push({\n              chartX: u + b.x,\n              chartY: h + b.y,\n              plotX: b.x,\n              plotY: b.y\n            });\n          }\n\n          a && e.attr({\n            d: a\n          });\n          b = c[c.length - 1];\n          b.chartX = u + b.plotX;\n          b.chartY = h + b.plotY;\n          k.push(b);\n        } else for (m = c.length, d = 0; d < m; d += 1) {\n          b = c[d];\n          a = c[d - 1];\n          b.chartX = u + b.plotX;\n          b.chartY = h + b.plotY;\n          q && (b.chartCenterY = h + (b.plotY + x(b.yBottom, p)) / 2);\n          if (0 < d && (e = Math.abs(b.chartX - a.chartX), f = Math.abs(b.chartY - a.chartY), e = Math.max(e, f), 16 < e)) for (e = Math.ceil(e / 16), f = 1; f < e; f += 1) {\n            k.push({\n              chartX: a.chartX + f / e * (b.chartX - a.chartX),\n              chartY: a.chartY + f / e * (b.chartY - a.chartY),\n              chartCenterY: a.chartCenterY + f / e * (b.chartCenterY - a.chartCenterY),\n              plotX: a.plotX + f / e * (b.plotX - a.plotX),\n              plotY: a.plotY + f / e * (b.plotY - a.plotY)\n            });\n          }\n          w(b.plotY) && k.push(b);\n        }\n\n        return k;\n      }\n    };\n\n    y.prototype.labelFontSize = function (c, b) {\n      return c + this.sum / this.chart.labelSeriesMaxSum * (b - c) + \"px\";\n    };\n\n    y.prototype.checkClearPoint = function (c, b, a, k) {\n      var d = Number.MAX_VALUE,\n          e = Number.MAX_VALUE,\n          f,\n          m,\n          h = this.options.label.connectorAllowed,\n          q = x(this.options.label.onArea, !!this.area),\n          u = this.chart,\n          p,\n          l,\n          n,\n          r,\n          t,\n          g;\n\n      for (t = 0; t < u.boxesToAvoid.length; t += 1) {\n        if (l = u.boxesToAvoid[t], g = c + a.width, p = b, n = b + a.height, !(c > l.right || g < l.left || p > l.bottom || n < l.top)) return !1;\n      }\n\n      for (t = 0; t < u.series.length; t += 1) {\n        if (p = u.series[t], l = p.interpolatedPoints, p.visible && l) {\n          for (g = 1; g < l.length; g += 1) {\n            if (l[g].chartX >= c - 16 && l[g - 1].chartX <= c + a.width + 16) {\n              if (z(c, b, a.width, a.height, l[g - 1].chartX, l[g - 1].chartY, l[g].chartX, l[g].chartY)) return !1;\n              this === p && !f && k && (f = z(c - 16, b - 16, a.width + 32, a.height + 32, l[g - 1].chartX, l[g - 1].chartY, l[g].chartX, l[g].chartY));\n            }\n\n            !h && !f || this === p && !q || (n = c + a.width / 2 - l[g].chartX, r = b + a.height / 2 - l[g].chartY, d = Math.min(d, n * n + r * r));\n          }\n\n          if (!q && h && this === p && (k && !f || d < Math.pow(this.options.label.connectorNeighbourDistance, 2))) {\n            for (g = 1; g < l.length; g += 1) {\n              f = Math.min(Math.pow(c + a.width / 2 - l[g].chartX, 2) + Math.pow(b + a.height / 2 - l[g].chartY, 2), Math.pow(c - l[g].chartX, 2) + Math.pow(b - l[g].chartY, 2), Math.pow(c + a.width - l[g].chartX, 2) + Math.pow(b - l[g].chartY, 2), Math.pow(c + a.width - l[g].chartX, 2) + Math.pow(b + a.height - l[g].chartY, 2), Math.pow(c - l[g].chartX, 2) + Math.pow(b + a.height - l[g].chartY, 2)), f < e && (e = f, m = l[g]);\n            }\n\n            f = !0;\n          }\n        }\n      }\n\n      return !k || f ? {\n        x: c,\n        y: b,\n        weight: d - (m ? e : 0),\n        connectorPoint: m\n      } : !1;\n    };\n\n    B.prototype.drawSeriesLabels = function () {\n      var c = this,\n          b = this.labelSeries;\n      c.boxesToAvoid = [];\n      b.forEach(function (a) {\n        a.interpolatedPoints = a.getPointsOnGraph();\n        (a.options.label.boxesToAvoid || []).forEach(function (a) {\n          c.boxesToAvoid.push(a);\n        });\n      });\n      c.series.forEach(function (a) {\n        function b(a, b, c) {\n          return a > l && a <= l + v - c.width && b >= r && b <= r + t - c.height;\n        }\n\n        if (a.xAxis || a.yAxis) {\n          var d,\n              e,\n              f,\n              m = [],\n              h,\n              q,\n              n = a.options.label,\n              p = c.inverted,\n              l = p ? a.yAxis.pos : a.xAxis.pos,\n              r = p ? a.xAxis.pos : a.yAxis.pos,\n              v = c.inverted ? a.yAxis.len : a.xAxis.len,\n              t = c.inverted ? a.xAxis.len : a.yAxis.len,\n              g = a.interpolatedPoints,\n              w = x(n.onArea, !!a.area),\n              p = a.labelBySeries;\n          d = n.minFontSize;\n          e = n.maxFontSize;\n\n          if (a.visible && !a.isSeriesBoosting && g) {\n            p || (a.labelBySeries = p = c.renderer.label(a.name, 0, -9999, \"connector\").css(A({\n              color: w ? c.renderer.getContrast(a.color) : a.color\n            }, a.options.label.style)), d && e && p.css({\n              fontSize: a.labelFontSize(d, e)\n            }), p.attr({\n              padding: 0,\n              opacity: c.renderer.forExport ? 1 : 0,\n              stroke: a.color,\n              \"stroke-width\": 1,\n              zIndex: 3\n            }).add().animate({\n              opacity: 1\n            }, {\n              duration: 200\n            }));\n            d = p.getBBox();\n            d.width = Math.round(d.width);\n\n            for (q = g.length - 1; 0 < q; --q) {\n              w ? (e = g[q].chartX - d.width / 2, f = g[q].chartCenterY - d.height / 2) : (e = g[q].chartX + 3, f = g[q].chartY - d.height - 3, b(e, f, d) && (h = a.checkClearPoint(e, f, d)), h && m.push(h), e = g[q].chartX + 3, f = g[q].chartY + 3, b(e, f, d) && (h = a.checkClearPoint(e, f, d)), h && m.push(h), e = g[q].chartX - d.width - 3, f = g[q].chartY + 3, b(e, f, d) && (h = a.checkClearPoint(e, f, d)), h && m.push(h), e = g[q].chartX - d.width - 3, f = g[q].chartY - d.height - 3), b(e, f, d) && (h = a.checkClearPoint(e, f, d)), h && m.push(h);\n            }\n\n            if (n.connectorAllowed && !m.length && !w) for (e = l + v - d.width; e >= l; e -= 16) {\n              for (f = r; f < r + t - d.height; f += 16) {\n                (h = a.checkClearPoint(e, f, d, !0)) && m.push(h);\n              }\n            }\n\n            if (m.length) {\n              if (m.sort(function (a, b) {\n                return b.weight - a.weight;\n              }), h = m[0], c.boxesToAvoid.push({\n                left: h.x,\n                right: h.x + d.width,\n                top: h.y,\n                bottom: h.y + d.height\n              }), m = Math.sqrt(Math.pow(Math.abs(h.x - p.x), 2), Math.pow(Math.abs(h.y - p.y), 2))) n = {\n                opacity: c.renderer.forExport ? 1 : 0,\n                x: h.x,\n                y: h.y\n              }, g = {\n                opacity: 1\n              }, 10 >= m && (g = {\n                x: n.x,\n                y: n.y\n              }, n = {}), a.labelBySeries.attr(A(n, {\n                anchorX: h.connectorPoint && h.connectorPoint.plotX + l,\n                anchorY: h.connectorPoint && h.connectorPoint.plotY + r\n              })).animate(g), a.options.kdNow = !0, a.buildKDTree(), a = a.searchPoint({\n                chartX: h.x,\n                chartY: h.y\n              }, !0), p.closest = [a, h.x - a.plotX, h.y - a.plotY];\n            } else p && (a.labelBySeries = p.destroy());\n          } else p && (a.labelBySeries = p.destroy());\n        }\n      });\n    };\n\n    C(B, \"render\", function () {\n      var c = this,\n          b = Math.max(n.animObject(c.renderer.globalAnimation).duration, 250),\n          a = !c.hasRendered;\n      c.labelSeries = [];\n      c.labelSeriesMaxSum = 0;\n      n.clearTimeout(c.seriesLabelTimer);\n      c.series.forEach(function (k) {\n        var d = k.options.label,\n            e = k.labelBySeries,\n            f = e && e.closest;\n        d.enabled && k.visible && (k.graph || k.area) && !k.isSeriesBoosting && (c.labelSeries.push(k), d.minFontSize && d.maxFontSize && (k.sum = k.yData.reduce(function (a, b) {\n          return (a || 0) + (b || 0);\n        }, 0), c.labelSeriesMaxSum = Math.max(c.labelSeriesMaxSum, k.sum)), a && (b = Math.max(b, n.animObject(k.options.animation).duration)), f && (void 0 !== f[0].plotX ? e.animate({\n          x: f[0].plotX + f[1],\n          y: f[0].plotY + f[2]\n        }) : e.attr({\n          opacity: 0\n        })));\n      });\n      c.seriesLabelTimer = n.syncTimeout(function () {\n        c.series && c.labelSeries && c.drawSeriesLabels();\n      }, c.renderer.forExport ? 0 : b);\n    });\n  })(r);\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./js/series-label.js?");

/***/ }),

/***/ "./js/targetblank.js":
/*!***************************!*\
  !*** ./js/targetblank.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("document.addEventListener(\"DOMContentLoaded\", function () {\n  var links = document.getElementsByTagName(\"a\");\n  Array.prototype.forEach.call(links, function (link) {\n    if (link.hostname !== window.location.hostname) {\n      link.target = \"_blank\";\n      link.rel = \"noopener noreferrer\";\n    }\n  });\n});\n\n//# sourceURL=webpack:///./js/targetblank.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ })

/******/ });</script>
		</article>
			<div class="wrapper">
				<div class="row-main">
					<section role="region" class="b-category">
						<div class="b-category__side">
							<h2 class="title title--icon">
								<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#">
									<span class="icon-svg icon-svg--bullet">
	<svg class="icon-svg__svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		<use xlink:href="./wrapper_files/icons-svg.svg#icon-bullet" x="0" y="0" width="100%" height="100%"></use>
	</svg>
</span>

									Zahraničí
								</a>
							</h2>

<div class="c-grid hide--m">
	<ul class="c-grid__list">

		<li class="c-grid__item">
			<div class="b-audio">
				<p class="b-audio__head">
					<span class="b-audio__play">
						<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="play-btn">
							Přehrát
							<span class="icon-svg icon-svg--play">
	<svg class="icon-svg__svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		<use xlink:href="./wrapper_files/icons-svg.svg#icon-play" x="0" y="0" width="100%" height="100%"></use>
	</svg>
</span>

						</a>
					</span>
					<span class="b-audio__meta text-uppercase"><time datetime="2016-10-18">18.10.</time> <a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#">Magazín Meteor</a></span>
				</p>
				<p class="b-audio__title">
					Planeta pavouků, hledá se plch velký a jak se rodí objevy?
				</p>
			</div>
		</li>
		<li class="c-grid__item">
			<div class="b-audio">
				<p class="b-audio__head">
					<span class="b-audio__play">
						<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="play-btn">
							Přehrát
							<span class="icon-svg icon-svg--play">
	<svg class="icon-svg__svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		<use xlink:href="./wrapper_files/icons-svg.svg#icon-play" x="0" y="0" width="100%" height="100%"></use>
	</svg>
</span>

						</a>
					</span>
					<span class="b-audio__meta text-uppercase"><time datetime="2016-10-18">18.10.</time> <a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#">Magazín Meteor</a></span>
				</p>
				<p class="b-audio__title">
					Planeta pavouků, hledá se plch velký a jak se rodí objevy?
				</p>
			</div>
		</li>

	</ul>
</div>
						</div>

						<div class="b-category__content">
							<div class="c-articles">
								<div class="c-articles__list">
									<article role="article" class="c-articles__item">
										<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="b-article">
											<div class="b-article__img img img--16x9 img--w480 img--w238--m" data-text-version="">
												<span class="img__holder">
													<img src="./wrapper_files/480x270.jpg" width="480" height="270" alt="">
												</span>
											</div>
											<div class="b-article__content">
												<h3 class="text-xl text-sm--m text-regular--m">
													Na Mars a zpět. Obama věří v cestu lidí na rudou planetu do roku 2030
												</h3>
												<p class="text-sm hide--m">
													Podle rozhodnutí ministerstva vnitra je přes 25 milionů za výpis trestných činů za posledních pět let adekvátní. Česko tak zatím nebude mít podrobnou mapu kriminality, která je v zahraničí běžná. Věcí se nyní...
												</p>
											</div>
										</a>
									</article>

									<article role="article" class="c-articles__item c-articles__item--w50p">
										<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="b-article">
											<div class="b-article__img img img--16x9 img--w238" data-text-version="">
												<span class="img__holder">
													<img src="./wrapper_files/238x134.jpg" width="238" height="134" alt="">
												</span>
											</div>
											<div class="b-article__content">
												<h3 class="text-sm--m text-md text-regular--m">
													Z dánské rybí farmy uplavalo 80 tisíc pstruhů. Pochytejte je, ohrožují ekosystém, vyzývají odborníci
												</h3>
											</div>
										</a>
									</article>

									<article role="article" class="c-articles__item c-articles__item--w50p">
										<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="b-article">
											<div class="b-article__img img img--16x9 img--w238" data-text-version="">
												<span class="img__holder">
													<img src="./wrapper_files/238x134.jpg" width="238" height="134" alt="">
												</span>
											</div>
											<div class="b-article__content">
												<h3 class="text-sm--m text-md text-regular--m">
													Video: 'Tanec' boeingu na Letišti Václava Havla. Piloty překvapil poryv větru
												</h3>
											</div>
										</a>
									</article>
								</div>

								<p class="c-articles__more hide--d">
									<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="link-more link-more--next">
										Další články
										<span class="icon-svg icon-svg--arrow-dots">
	<svg class="icon-svg__svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		<use xlink:href="./wrapper_files/icons-svg.svg#icon-arrow-dots" x="0" y="0" width="100%" height="100%"></use>
	</svg>
</span>

									</a>
								</p>
							</div>

							<div class="c-links hide--m">
								<ul class="c-links__list">
									<li class="c-links__item">
										<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="c-links__link">Archeologové našli pozůstatky římského tábora. Je nejsevernější na našem území</a>
									</li>
									<li class="c-links__item">
										<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="c-links__link">Nové i rekonstruované. Mezi stavbami roku je tunel Blanka i Hospital v Kuksu</a>
									</li>
									<li class="c-links__item">
										<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="c-links__link">Ve vesmíru je desetkrát více galaxií. Většinu z nich zatím nevidíme</a>
									</li>
								</ul>
							</div>
						</div>
					</section>
				</div>
			</div>
		</main>

<footer class="footer" role="contentinfo">
	<div class="row-main">
		<nav class="m-footer-m hide--d">
			<ul class="m-footer-m__list">
				<li class="m-footer-m__item">
					<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-footer-m__link">
						Cookies
					</a>
				</li>
				<li class="m-footer-m__item">
					<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-footer-m__link js-force-desktop">
						Plná verze
					</a>
				</li>
			</ul>

			<p class="m-footer-m__top">
				<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#top" class="link-top js-scroll-to">
					Nahoru
					<span class="icon-svg icon-svg--top">
	<svg class="icon-svg__svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		<use xlink:href="./wrapper_files/icons-svg.svg#icon-top" x="0" y="0" width="100%" height="100%"></use>
	</svg>
</span>

				</a>
			</p>
		</nav>


		<div class="footer__wrap hide--m">
			<p class="footer__logo">
				<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#">
					<span class="vhide">iRozhlas</span>
					<span class="icon-svg icon-svg--logo-irozhlas">
	<svg class="icon-svg__svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		<use xlink:href="./wrapper_files/icons-svg.svg#icon-logo-irozhlas" x="0" y="0" width="100%" height="100%"></use>
	</svg>
</span>

				</a>
			</p>

			<nav class="m-tools" aria-labelledby="m-tools">
				<p class="vhide" id="m-tools">Doplňková navigace</p>

				<ul class="m-tools__list">
					

					<li class="m-tools__item m-tools__item--mobile">
						<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-tools__link js-force-desktop-reset">
							<span class="m-tools__icon"><span class="icon-svg icon-svg--mobile">
	<svg class="icon-svg__svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		<use xlink:href="./wrapper_files/icons-svg.svg#icon-mobile" x="0" y="0" width="100%" height="100%"></use>
	</svg>
</span>
</span>
							<span class="m-tools__label">Mobilní<br> verze</span>
						</a>
					</li>
					<li class="m-tools__item">
						<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-tools__link">
							<span class="m-tools__icon"><span class="icon-svg icon-svg--rss">
	<svg class="icon-svg__svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		<use xlink:href="./wrapper_files/icons-svg.svg#icon-rss" x="0" y="0" width="100%" height="100%"></use>
	</svg>
</span>
</span>
							<span class="m-tools__label">RSS kanály</span>
						</a>
					</li>
				</ul>
			</nav>
		</div>

		<div class="footer__links">
			<nav class="m-footer hide--m" aria-labelledby="m-footer">
				<p id="m-footer" class="vhide">Navigace v zápatí</p>

				<ul class="m-footer__list">

					<li class="m-footer__item">
						<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-footer__link">Redakce</a>
					</li>
					<li class="m-footer__item">
						<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-footer__link">Mapa webu</a>
					</li>
					<li class="m-footer__item">
						<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-footer__link">Soukromí a cookies</a>
					</li>
					<li class="m-footer__item">
						<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-footer__link">Podmínky užití</a>
					</li>
					<li class="m-footer__item">
						<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-footer__link">Kontakty</a>
					</li>
					<li class="m-footer__item">
						<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-footer__link">Práce</a>
					</li>
				</ul>
			</nav>

			<p class="footer__copy">
				© 1997-2016 Český rozhlas
			</p>
		</div>
	</div>
</footer>

		<nav class="m-mobile">
<div class="m-mobile__panel">
	<p class="m-mobile__logo">
		<span class="vhide">Český rozhlas - Zprávy</span>
		<span class="icon-svg icon-svg--logo-irozhlas">
	<svg class="icon-svg__svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		<use xlink:href="./wrapper_files/icons-svg.svg#icon-logo-irozhlas" x="0" y="0" width="100%" height="100%"></use>
	</svg>
</span>

	</p>

	<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-mobile__close js-mobile-menu">
		<span class="vhide">Zavřít</span>
		<span class="icon-svg icon-svg--close">
	<svg class="icon-svg__svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		<use xlink:href="./wrapper_files/icons-svg.svg#icon-close" x="0" y="0" width="100%" height="100%"></use>
	</svg>
</span>

	</a>
</div>

<div class="m-mobile__wrap">
	<div class="m-mobile__group m-mobile__group--menu">
		<form class="m-mobile__search">
			<p class="inp inp--btn">
				<label for="search" class="vhide">Vyhledávání</label>
				<span class="inp__fix">
					<input type="text" class="inp__text inp__text--md" id="search" name="search">
				</span>
				<button class="btn btn--md btn--icon-blank" type="submit">
					<span class="btn__text">
						<span class="vhide">Vyhledat</span>
						<span class="icon-svg icon-svg--search">
	<svg class="icon-svg__svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		<use xlink:href="./wrapper_files/icons-svg.svg#icon-search" x="0" y="0" width="100%" height="100%"></use>
	</svg>
</span>

					</span>
				</button>
			</p>
		</form>

		<ul class="m-mobile__list m-mobile__list--striped">

			<li class="m-mobile__item">
				<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-mobile__link">Domácí</a>
			</li>
			<li class="m-mobile__item">
				<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-mobile__link">Svět</a>
			</li>
			<li class="m-mobile__item">
				<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-mobile__link">Regiony</a>
			</li>
			<li class="m-mobile__item">
				<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-mobile__link">Ekonomika</a>
			</li>
			<li class="m-mobile__item">
				<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-mobile__link">Sport</a>
			</li>
			<li class="m-mobile__item">
				<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-mobile__link">Věda</a>
			</li>
			<li class="m-mobile__item">
				<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-mobile__link">Kultura</a>
			</li>
			<li class="m-mobile__item">
				<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-mobile__link">Komentáře</a>
			</li>
			<li class="m-mobile__item">
				<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-mobile__link">Zelená vlna</a>
			</li>
			<li class="m-mobile__item">
				<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-mobile__link">Počasí</a>
			</li>
		</ul>
	</div>

	<div class="m-mobile__group m-mobile__group--submenu">
		<ul class="m-mobile__list">
			<li class="m-mobile__item">
				<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-mobile__link m-mobile__link--text-version js-text-version" data-toggled="Plná verze">
					Textová verze
				</a>
			</li>
			
			<li class="m-mobile__item">
				<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-mobile__link">
					Nejnovější zprávy
				</a>
			</li>
		</ul>
	</div>

	<div class="m-mobile__group m-mobile__group--text">
		<p class="m-socials m-socials--lg">
			<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-socials__link">
				<span class="vhide">Facebook</span>
				<span class="icon-svg icon-svg--facebook">
	<svg class="icon-svg__svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		<use xlink:href="./wrapper_files/icons-svg.svg#icon-facebook" x="0" y="0" width="100%" height="100%"></use>
	</svg>
</span>

			</a>
			<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-socials__link">
				<span class="vhide">Twitter</span>
				<span class="icon-svg icon-svg--twitter">
	<svg class="icon-svg__svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		<use xlink:href="./wrapper_files/icons-svg.svg#icon-twitter" x="0" y="0" width="100%" height="100%"></use>
	</svg>
</span>

			</a>
			<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-socials__link">
				<span class="vhide">Google+</span>
				<span class="icon-svg icon-svg--gplus">
	<svg class="icon-svg__svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		<use xlink:href="./wrapper_files/icons-svg.svg#icon-gplus" x="0" y="0" width="100%" height="100%"></use>
	</svg>
</span>

			</a>
		</p>

		<div class="m-text">
			<p>
				<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-text__invert js-inverse">
					Inverzně
				</a>
			</p>
		</div>
	</div>

	<div class="m-mobile__group m-mobile__group--submenu">
		<ul class="m-mobile__list">

			<li class="m-mobile__item">
				<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-mobile__link">Kontakty</a>
			</li>
			<li class="m-mobile__item">
				<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-mobile__link">Redakce</a>
			</li>
			<li class="m-mobile__item">
				<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-mobile__link">Cookies</a>
			</li>
		</ul>
	</div>

	<div class="m-mobile__group m-mobile__group--logos">
		<ul class="m-mobile__list">
			<li class="m-mobile__item">
				<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-mobile__link m-mobile__link--cesky-rozhlas">
					<span class="vhide">Český rozhlas</span>
				</a>
			</li>
			<li class="m-mobile__item">
				<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-mobile__link m-mobile__link--radiozurnal">
					<span class="vhide">Radiožurnál</span>
				</a>
			</li>
			<li class="m-mobile__item">
				<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-mobile__link m-mobile__link--plus">
					<span class="vhide">Plus</span>
				</a>
			</li>
		</ul>
	</div>
</div>

<a href="http://rozhlas2017.superkoderi.cz/tpl/14-datari.html#" class="m-mobile__panel js-mobile-menu">
	<span class="m-mobile__label">
		Zavřít menu
	</span>

	<span class="m-mobile__close">
		<span class="vhide">Zavřít</span>
		<span class="icon-svg icon-svg--close">
	<svg class="icon-svg__svg" xmlns:xlink="http://www.w3.org/1999/xlink">
		<use xlink:href="./wrapper_files/icons-svg.svg#icon-close" x="0" y="0" width="100%" height="100%"></use>
	</svg>
</span>

	</span>
</a>
		</nav>

		<!--[if (gte IE 9)|!(IE)]><!-->
		<script src="./wrapper_files/app.js"></script>
		<script>
			App.run({});
		</script>
		<!--<![endif]-->
	

</body></html>